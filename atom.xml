<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏·浅</title>
  
  <subtitle>Sue Shallow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Yeasion.github.io/"/>
  <updated>2019-04-04T13:15:21.890Z</updated>
  <id>http://Yeasion.github.io/</id>
  
  <author>
    <name>Sue Shallow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩阵树定理及其应用</title>
    <link href="http://Yeasion.github.io/2019/04/04/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/04/04/矩阵树定理及其应用/</id>
    <published>2019-04-04T11:25:59.000Z</published>
    <updated>2019-04-04T13:15:21.890Z</updated>
    
    <content type="html"><![CDATA[<p>这个东西首次出现在周冬的国家集训队论文里面，解决的问题叫做生成树计数问题。<br>顾名思义，就是让你求一张无向图中生成树的个数。<br>首先我们要知道三个概念。</p><ol><li>邻接矩阵A<br>这个东西不用我说了吧，就是对于每一条边$Edge_{ij}$，矩阵的$i$行$j$列和$j$行$i$列设为1，其他设为0。</li><li>度数矩阵D<br>啥意思呢，就是将每一个点的度数，其中对于每一个不相等的$i,j$有$D[i][j] = 0$</li><li>基尔霍夫矩阵C<br>$C = D - A$</li></ol><p>而Matrix-Tree定理就是说这个无向图的生成树个数就等于基尔霍夫矩阵的任意一个$N - 1$阶主子式的行列式的绝对值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个东西首次出现在周冬的国家集训队论文里面，解决的问题叫做生成树计数问题。&lt;br&gt;顾名思义，就是让你求一张无向图中生成树的个数。&lt;br&gt;首先我们要知道三个概念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邻接矩阵A&lt;br&gt;这个东西不用我说了吧，就是对于每一条边$Edge_{ij}$，矩阵的
      
    
    </summary>
    
    
      <category term="矩阵树定理" scheme="http://Yeasion.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
      <category term="最小生成树" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>卢卡斯定理与扩展卢卡斯定理</title>
    <link href="http://Yeasion.github.io/2019/04/04/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    <id>http://Yeasion.github.io/2019/04/04/卢卡斯定理与扩展卢卡斯定理/</id>
    <published>2019-04-04T09:48:15.000Z</published>
    <updated>2019-04-04T11:24:42.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>卢卡斯定理要解决的问题很简单：</p><script type="math/tex; mode=display">C_n^m ~mod~ p</script><p>如果$p$规定为质数，那么就用卢卡斯定理解决，否则就是扩展卢卡斯定理。<br>洛谷上两个模板题都有 <a href="https://www.luogu.org/problemnew/show/P3807" target="_blank" rel="noopener">Lucas</a> <a href="https://www.luogu.org/problemnew/show/P4720" target="_blank" rel="noopener">ExLucas</a></p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>如果你不知道前置的知识的话，最好还是去系统学习一下。</p><h4 id="1-乘法逆元"><a href="#1-乘法逆元" class="headerlink" title="1. 乘法逆元"></a>1. 乘法逆元</h4><blockquote><p>若$Ax \equiv 1 (mod~p)$且$A$与$p$互质，则称$A$的$mod~p$意义下的乘法逆元为$X$</p></blockquote><p>关于求逆元：<br>因为$(a,p) = 1$<br>所以$a^{p-1} \equiv 1 (mod~p)$<br>所以$a \times a ^{p - 2} \equiv 1 (mod~p)$<br>所以$m!(n - m)!$的逆元为$(m!(n - m)!) ^{p - 2}$<br>直接快速幂就可以了。</p><h4 id="2-扩展欧几里得"><a href="#2-扩展欧几里得" class="headerlink" title="2.扩展欧几里得"></a>2.扩展欧几里得</h4><blockquote><p>扩展欧几里得用来在求得$gcd(a,b)$的同时，找出整数$x,y$使其满足$ax + by = gcd(a,b)$</p></blockquote><h4 id="3-费马小定理"><a href="#3-费马小定理" class="headerlink" title="3.费马小定理"></a>3.费马小定理</h4><blockquote><p>$a^(p-1) \equiv 1 (mod~p)$。</p></blockquote><h4 id="4-中国剩余定理"><a href="#4-中国剩余定理" class="headerlink" title="4.中国剩余定理"></a>4.中国剩余定理</h4><p>还请移步博客<a href="https://yeasion.github.io/2019/02/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt/">欧几里得与扩展中国剩余定理Excrt</a></p><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>证明过程：<br>首先根据组合数的只是我们可以很显然推出</p><script type="math/tex; mode=display">C_p^i \equiv \frac pi C_{p-1}^{i-1} \equiv 0 (mod~p)</script><p>然后根据二项式定理得出：</p><script type="math/tex; mode=display">(1 + x)^p \equiv \sum_{i=0}^p C_p^0 X^i \equiv C_p^o1^pX^0 + C^p_p1^0X^p \equiv 1 + x^p (mod~p)</script><p>然后我们继续从二项式定理推出：</p><script type="math/tex; mode=display">C^b_a \equiv \prod_{i = 0}^p0 C_{a_ip^i}^{b_ip^i} (mod~p)</script><p>上式也就是所谓的卢卡斯定理，这玩意的用处就在于下面这个递推式：</p><script type="math/tex; mode=display">Lucas(n,m,p) = CC_{m \% p}^{n \% p} \times Lucas(\frac np, \frac mp, p</script><p>其中$Lucas(x,0,p) = 1$且$CC_m^n = (C_m^n)^(p-2) ~mod ~p$<br>实际上就是一个费马小定理和乘法逆元。<br>根据这个东西就可以很快地求出来上面的问题了。<br>如果你看不大懂，那就只需要记结论。。。。</p><script type="math/tex; mode=display">C_m^n ~mod~ p = (C_{m / p}^{n / p} ~mod~p) \times (C^{n ~mod~ p}_{m ~mod~ p} ~mod~p)~mod~p</script><p>然后直接递归调用$C_{m~mod~p}^{n~mod~p} ~mod~p$就可以了。<br>对于$C_m^n$的除法取模就需要用到逆元了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line">LL N, M, P, X[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">QuickPow</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line">LL Ans = <span class="number">1</span> ;<span class="keyword">if</span> (! B) <span class="keyword">return</span> <span class="number">1</span> % P ;</span><br><span class="line"><span class="keyword">while</span> (B) &#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) Ans = Ans * A % P ;</span><br><span class="line">A = A * A % P, B &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (B &gt; A) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">return</span> (X[A] * QuickPow(X[B], P - <span class="number">2</span>)) % P * QuickPow(X[A - B], P - <span class="number">2</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Lucas</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! B) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (C(A % P, B % P) * Lucas(A / P, B / P)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T = Read() ; <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">N = Read(), M = Read(), P = Read() ;</span><br><span class="line">X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= P ; i ++) </span><br><span class="line">X[i] = (X[i - <span class="number">1</span>] * i) % P ;</span><br><span class="line">LL Ans = Lucas(N + M, N) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展卢卡斯定理"><a href="#扩展卢卡斯定理" class="headerlink" title="扩展卢卡斯定理"></a>扩展卢卡斯定理</h3><p>令$P = \prod p_i^{c_i}$<br>假设我们知道$C_n^m ~mod~p_i^{c_i}$就可以直接上$Crt$，但是我们并不知道。（泪目<br>怎么求呢？<br>对于$C^n_m = \frac{n!}{(n-m)!m!}$<br>我们可以阶乘的变换。<br>假设我们现在要求$19! % 3$<br>我们将$1 \times…\times 19$中所有$3$的倍数拿出来合并。<br>那么我们就得到$\lfloor \frac{19}{3} \rfloor$个满足项，然后除以$3$之后，就得到$\lfloor \frac{19}{3} \rfloor !$,这一部分不好算，我们直接递归下去。<br>然后对于其他的项，可以看出来他们具有小于$3^k$的循环节这种东西，就可以暴力。<br>然后时间复杂度就很可观了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;卢卡斯定理要解决的问题很简单：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
C_n^m ~mod~
      
    
    </summary>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="扩展欧几里得" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="Lucas" scheme="http://Yeasion.github.io/tags/Lucas/"/>
    
      <category term="ExLucas" scheme="http://Yeasion.github.io/tags/ExLucas/"/>
    
  </entry>
  
  <entry>
    <title>TSP-旅行商问题</title>
    <link href="http://Yeasion.github.io/2019/03/19/TSP-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <id>http://Yeasion.github.io/2019/03/19/TSP-旅行商问题/</id>
    <published>2019-03-19T09:38:39.000Z</published>
    <updated>2019-03-20T08:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>$TSP$是一个“组合优化问题”，同时也是数学领域中一个较为著名的$NPC$问题。</p><blockquote><p>现在的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。</p></blockquote><p>可以发现这个问题并不是真正意义上的$NPC$，而是属于一个$NP-Hard$，因此可以求出较优解。<br>这个问题的实质就是求一个带权无向图中，找一个权值最小的哈密尔顿回路，在给出的节点数目非常小的情况下，我们可以考虑状压$DP$。<br>当然，我们知道没有什么算法是暴力搜索解决不了的，在没有十分优的解决方案的时候没我们自然想到枚举全排列。<br>但是这显然白搭，因为$O(N!)$的时间复杂度即使点数很小也是很难接受的。<br>于是考虑压缩状态。对于一种方案，我们用一个$N$位的二进制数表示，其中$1$表示第$i$个点被经过，若是$0$则是没有经过。<br>我们设$Dp[i][j]$表示路径状态为$i$，当前处于$j$节点的最短路径。<br>假设我们现在有一个$Dp[i][j]$，那么我们可以枚举一个点$k$，因为当前的$j$是刚刚经过，因此上一个状态一定没有经过$j$这个点。因此在上一个时刻的点的状态的第$j$位就一定是$0$，状态就是$i \times (1 &lt;&lt; k)$。<br>并且从$k$走到$j$需要$L[i][j]$（也就是两点之间的最短路），于是我们取遍所有的$k$取最小值即可。<br>得出递推关系式：</p><script type="math/tex; mode=display">Dp[i][j] = min(Dp[i][j], Dp[i * (1 << j)][k] + L[k][j])</script><p>目标的状态显然是$Dp[(1 &lt;&lt; N) - 1][N - 1]$（因为起点是$0$）。</p><p>以上需要用到不少的位运算，如果不是很懂的还请去学学为好。<br>下面给出的是$1 \leq N \leq 20$的数据，$L[i][j]$是两个点之间的距离。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">21</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][MAXN], L[MAXN][MAXN], Ans = <span class="number">10000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;<span class="keyword">return</span> (A &lt; B) ? A : B ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(Dp)) ;</span><br><span class="line">    Dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; j ++)</span><br><span class="line">        L[i][j] = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; (<span class="number">1</span> &lt;&lt; N) ; i += <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N ; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == k || !((i &gt;&gt; k) &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;</span><br><span class="line">            Dp[i][j] = Min(Dp[i][j], Dp[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + L[k][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++)</span><br><span class="line">        Ans = Min(Ans, Dp[(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>][i] + L[i][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      $TSP$问题，即旅行商问题，可以被证明具有$NPC$计算复杂度。假设有一个旅行的商人要拜访$N$个城市，他必须选择要走的路径，其限制是每个城市只能拜访一次，并且最后要回到原点。要求最小路径长度和。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态压缩" scheme="http://Yeasion.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="NPC问题" scheme="http://Yeasion.github.io/tags/NPC%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2010]生成字符串</title>
    <link href="http://Yeasion.github.io/2019/03/17/SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://Yeasion.github.io/2019/03/17/SCOI2010-生成字符串/</id>
    <published>2019-03-17T01:22:08.000Z</published>
    <updated>2019-03-17T02:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>这题首先就得有一个画坐标系的想法，这很智障，我一开始也没有想出来。<br>我们设$X = Num[1] + Num[0]$, $Y = Num[1] - Num[0]$<br>也就是将1的个数加上0的个数设为X横坐标，把其和设为纵坐标。<br>稍微画一下图，如果我们从原点开始向右上方走(y = x)，那么就是$X + 1, Y + 1$，表示我们选择了1,，如果朝右下角走$y = - x$那么就是$X + 1, Y - 1$，表示我们选择了0。<br>很显然最后的方案数就是从原点走到$(N + M),(N - M)$节点。<br>因为无论如何$X$都是加一，所以步数一定是$N + M$步，而我们要选出$M$次向下走，方案数就是$C^{N +M} _M$。<br>当然，这是没有考虑限制情况。题目要求$1$的个数不能超过$0$的个数。发现也就是不能超过$y = - 1$这条直线。而经过直线的方案数就是$C^{N +M} _{M - 1}$<br>然后最后的答案就是</p><script type="math/tex; mode=display">C^{N +M} _M - C^{N +M} _{M - 1}</script><p>这种东西直接预处理前缀积然后逆元一下就好了…<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1000010</span> &lt;&lt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">1000010</span> &lt;&lt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Mod = <span class="number">20100403</span> ;</span><br><span class="line"></span><br><span class="line">LL N, M, Fac[MAXN], Inv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">QUCIK_POW</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line">    LL Ans = <span class="number">1</span> ; <span class="keyword">while</span> (Y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod ;</span><br><span class="line">        X = X * X % Mod ; Y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line">    LL U = Fac[X] * Inv[Y] % Mod ;</span><br><span class="line">    <span class="keyword">return</span> U * Inv[X - Y] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ; Fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N + M ; i ++)</span><br><span class="line">        Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">    Inv[N + M] = QUCIK_POW(Fac[N + M], Mod - <span class="number">2</span>) ;   </span><br><span class="line">    <span class="keyword">for</span> (LL i = N + M - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)</span><br><span class="line">        Inv[i] = Inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (C(N + M, M) - C(N + M, M - <span class="number">1</span>) + Mod) % Mod) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      生成一个由$N$个$1$和$M$个$0$组成的字符串，要求任意前缀的$1$的个数不能少于$0$的个数。求满足该条件的字符串的个数。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="字符串" scheme="http://Yeasion.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="组合数学" scheme="http://Yeasion.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="逆元" scheme="http://Yeasion.github.io/tags/%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>[USACO15JAN]草鉴定</title>
    <link href="http://Yeasion.github.io/2019/03/12/USACO15JAN-%E8%8D%89%E9%89%B4%E5%AE%9A/"/>
    <id>http://Yeasion.github.io/2019/03/12/USACO15JAN-草鉴定/</id>
    <published>2019-03-12T09:15:29.000Z</published>
    <updated>2019-03-12T09:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3119" target="_blank" rel="noopener">Link</a><br>一道及其智障的题目，关键在于博主调这个智障题调了基本一天…<br>其实不是很难想，我们先缩一下点，把新图建出来，当然是因为要保证图无环，要不然下面就没法做了。<br>这里实际上要建两个新图，一个正着的，还有一个反图。<br>干什么用的呢？主要就是因为题目要求回到原点，这个玩意怎么实现的问题。<br>首先这个路经肯定是一个圈，然后我们就可以找一下这个圈的一个“转折节点”，实际上就是枚举一个中间节点$X$，然后吧路经分为$1 -&gt; X$和$X -&gt; 1$两个链，这就需要我们建一个反图来进行实现。<br>因为题目要求经过的点最多，因此我们就跑两个最长路。<br>第一个最长路记录正图的$1 - &gt; Point_i$节点为$D[i]$。<br>第二个最长路记录反图的$Point_i - &gt; 1$节点为$D2[i]$。（实际上也是从1节点出发）<br>然后对于这个逆行的边我们如下处理：<br>首先在$Tarjan$的时候进行一个记录$C[i]$表示$SCCi$号节点里面包含的原图的点数。<br>那么$C[B[i]]$就是表示原图$i$号节点所属的$SCC$节点包含的原图的点数。<br>对于逆行的边我们直接枚举<br>答案就是$min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]])$（V为反图）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010000</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, B[MAXN], Low[MAXN], Dfn[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; G[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; V[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> Ken, Top, S[MAXN], Cnt, C[MAXN],Ans ;</span><br><span class="line"><span class="keyword">bool</span> Insta[MAXN] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; Point[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H[MAXN], Tot ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T ;</span><br><span class="line">    E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> H2[MAXN], Tot2 ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    G[++ Tot2].F = F ; G[Tot2].T = T ;</span><br><span class="line">    G[Tot2].Next = H2[F], H2[F] = Tot2 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> H3[MAXN], Tot3 ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add3</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    V[++ Tot3].F = F ; V[Tot3].T = T ;</span><br><span class="line">    V[Tot3].Next = H3[F], H3[F] = Tot3 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Dfn[Now] = ++ Ken ; Low[Now] = Ken ;</span><br><span class="line">    S[++ Top] = Now ; Insta[Now] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ;  i ; i = E[i].Next)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[E[i].T]) &#123;</span><br><span class="line">            Tarjan(E[i].T) ;</span><br><span class="line">            Low[Now] = min(Low[Now], Low[E[i].T]) ;</span><br><span class="line">        &#125;   <span class="keyword">else</span> <span class="keyword">if</span> (Insta[E[i].T])</span><br><span class="line">            Low[Now] = min(Low[Now], Dfn[E[i].T]) ;</span><br><span class="line">    <span class="keyword">if</span> (Dfn[Now] == Low[Now]) &#123;</span><br><span class="line">        <span class="keyword">int</span> Pass ; Cnt ++ ;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Pass = S[Top --] ;</span><br><span class="line">            B[Pass] = Cnt ;</span><br><span class="line">            Point[Cnt].push_back(Pass) ;</span><br><span class="line">            C[Cnt] ++ ;</span><br><span class="line">            Insta[Pass] = <span class="literal">false</span> ;</span><br><span class="line">        &#125;   <span class="keyword">while</span> (Pass != Now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[MAXN], Vis[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(D, <span class="number">0</span>, <span class="keyword">sizeof</span>(D)) ;</span><br><span class="line">    D[B[<span class="number">1</span>]] = - C[B[<span class="number">1</span>]] ; Vis[B[<span class="number">1</span>]] = <span class="number">1</span> ; Q.push(B[<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; Vis[Now] = <span class="literal">false</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H2[Now] ; i ; i = G[i].Next)</span><br><span class="line">            <span class="keyword">if</span> (D[G[i].T] &gt; D[Now] - C[G[i].T]) &#123;</span><br><span class="line">                D[G[i].T] = D[Now] - C[G[i].T] ;</span><br><span class="line">                <span class="keyword">if</span> (! Vis[G[i].T])</span><br><span class="line">                    Vis[G[i].T] = <span class="number">1</span>, Q.push(G[i].T) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D2[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(D2, <span class="number">0</span>, <span class="keyword">sizeof</span>(D2)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vis)) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) Q.pop() ;</span><br><span class="line">    D2[B[<span class="number">1</span>]] = - C[B[<span class="number">1</span>]] ; Vis[B[<span class="number">1</span>]] = <span class="number">1</span> ; Q.push(B[<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; Vis[Now] = <span class="literal">false</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H3[Now] ; i ; i = V[i].Next)</span><br><span class="line">            <span class="keyword">if</span> (D2[V[i].T] &gt; D2[Now] - C[V[i].T]) &#123;</span><br><span class="line">                D2[V[i].T] = D2[Now] - C[V[i].T] ;</span><br><span class="line">                <span class="keyword">if</span> (! Vis[V[i].T])</span><br><span class="line">                    Vis[V[i].T] = <span class="number">1</span>, Q.push(V[i].T) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A = Read(), B = Read() ;</span><br><span class="line">        Add(A, B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[i]) Tarjan(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Cnt ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Point[i].size() ; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = H[Point[i][j]] ; k ; k = E[k].Next)</span><br><span class="line">            <span class="keyword">if</span> (B[Point[i][j]] != B[E[k].T]) &#123;</span><br><span class="line">                Add2(B[Point[i][j]], B[E[k].T]) ;</span><br><span class="line">                Add3(B[E[k].T], B[Point[i][j]]) ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    Spfa() ; Spfa2() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Cnt ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = H3[i] ; j ; j = V[j].Next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (D[V[j].F] &lt; <span class="number">0</span> &amp;&amp; D2[V[j].T] &lt; <span class="number">0</span>)</span><br><span class="line">            Ans = min(Ans, D[V[j].F] + D2[V[j].T] + C[B[<span class="number">1</span>]]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, - Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有一个有向图，Bessie可以从$1$号节点开始然后最后回到$1$号节点，其中可以逆行一次，求能够经过的最多的节点数。
    
    </summary>
    
    
      <category term="拓扑排序" scheme="http://Yeasion.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Tarjan" scheme="http://Yeasion.github.io/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2009]Elaxia的路线</title>
    <link href="http://Yeasion.github.io/2019/03/10/SDOI2009-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF/"/>
    <id>http://Yeasion.github.io/2019/03/10/SDOI2009-Elaxia的路线/</id>
    <published>2019-03-10T08:23:53.000Z</published>
    <updated>2019-03-10T08:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2149" target="_blank" rel="noopener">Link</a><br>很经典的图论题目，分析下来不是特别有难度，算是比较简单的一类拓扑题吧。<br>首先对于题目给定的$S1,S2,T1,T2$肯定要分别求一遍最短路，而我们选择的是从这四个节点出发分别求对所有点的最短路，得到$Dist[1 -&gt; 4][i]$分别表示$S1,T1,S2,T2$出发到第$i$个节点的最短路。<br>因为题目是无向图，所以考虑重新建图变成$DAG$。<br>在这之前我们要知道一个结论，就是这个最长公共路经一定是一条链，具体很好推，瞎证一证就可以了。<br>所以如果我们在这里有了一张关于$S1 -&gt; T2$的所有最短路组成的$DAG$，那么其最长公共路经一定在这个图上，反过来$S2-&gt;T2$也是成立的。<br>所有我们取一个交集，就知道怎么建图了：<br>1.首先大循环是建一个$S1-&gt;T1$的图，对于某一条边$(Now-&gt;To)$，我们只需要判断$S1-&gt;Now-&gt;To-&gt;T1$这条路经是不是$S1-&gt;T1$的最短路就可以了。<br>于是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dist[<span class="number">1</span>][E[i].F]  + E[i].L  + Dist[<span class="number">2</span>][E[i].T]  == Dist[<span class="number">1</span>][T1])</span><br></pre></td></tr></table></figure><p>2.之后循环的是$S2-&gt;T2$，和上面一样，但是为了保证$S2-&gt;Now-&gt;T-&gt;T2$和$S2-&gt;T-&gt;Now-&gt;T2$这两种情况都可以考虑到，我们需要分别考虑。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Tot ; i ++)</span><br><span class="line">    <span class="keyword">if</span> (Dist[<span class="number">1</span>][E[i].F]  + E[i].L  + Dist[<span class="number">2</span>][E[i].T]  == Dist[<span class="number">1</span>][T1]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dist[<span class="number">3</span>][E[i].F] + E[i].L + Dist[<span class="number">4</span>][E[i].T] == Dist[<span class="number">3</span>][T2])</span><br><span class="line">        Add2(E[i].F, E[i].T, E[i].L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Dist[<span class="number">3</span>][E[i].T] + E[i].L + Dist[<span class="number">4</span>][E[i].F] == Dist[<span class="number">3</span>][T2])</span><br><span class="line">        Add2(E[i].F, E[i].T, E[i].L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> Add2(E[i].F, E[i].T, E[i].L, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这个建新图的函数$Add2()$中最后有一个关于$1$和$0$的参数，这个是为了表达在拓扑排序中是否需要计入答案的,也就是说这条边是不是在两条最短路的交集上（好绕~。<br>然后就是一个拓扑排序了，直接从$S1$跑到$T1$，然后在其中对答案取$max$就可以了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">800010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, D[MAXN], H[MAXN], Tot, Ans[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> S1, S2, T1, T2, Dist[<span class="number">6</span>][MAXN], Ind[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> F ; <span class="keyword">int</span> T ; <span class="keyword">int</span> Next ; <span class="keyword">int</span> L ;</span><br><span class="line">&#125;   E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H2[MAXN], Tot2 ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F ; <span class="keyword">int</span> T ; <span class="keyword">int</span> Next ; <span class="keyword">int</span> L ;</span><br><span class="line">    <span class="keyword">bool</span> P ;</span><br><span class="line">&#125;   Ed[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Num ; <span class="keyword">long</span> <span class="keyword">long</span> Len ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> NODE &amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Len &gt; B.Len ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   Node ;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN] ;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;NODE&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F, E[Tot].T = T, E[Tot].L = L ;</span><br><span class="line">    E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    Ed[++ Tot2].F = F, Ed[Tot2].T = T, Ed[Tot2].L = L ;</span><br><span class="line">    Ed[Tot2].Next = H2[F], H2[F] = Tot2, Ed[Tot2].P = P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> Num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(D, <span class="number">127</span>, <span class="keyword">sizeof</span>(D)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vis)) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) Q.pop() ;</span><br><span class="line">    D[S] = <span class="number">0</span> ; Vis[S] = <span class="number">0</span> ; Node.Num = S ; </span><br><span class="line">    Node.Len = <span class="number">0</span> ; Q.push(Node) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        NODE Now = Q.top() ; Q.pop() ; </span><br><span class="line">        <span class="keyword">if</span> (Vis[Now.Num]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now.Num] ; i ; i = E[i].Next)</span><br><span class="line">            <span class="keyword">if</span> (! Vis[E[i].T])</span><br><span class="line">            <span class="keyword">if</span> (D[E[i].T] &gt; D[Now.Num] + E[i].L) &#123;</span><br><span class="line">                D[E[i].T] = D[Now.Num] + E[i].L ;</span><br><span class="line">                Q.push(Node = &#123;E[i].T, D[E[i].T]&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line">        Dist[Num][i] = D[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Que ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Que.push(S1) ;</span><br><span class="line">    <span class="keyword">while</span> (! Que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Que.front() ; Que.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H2[Now] ; i ; i = Ed[i].Next) &#123;</span><br><span class="line">            Ind[Ed[i].T] -- ;</span><br><span class="line">            <span class="keyword">if</span> (! Ind[Ed[i].T]) Que.push(Ed[i].T) ;</span><br><span class="line">            Ans[Ed[i].T] = max(Ans[Ed[i].T], Ans[Now] + Ed[i].L * Ed[i].P) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read() ;</span><br><span class="line">    S1 = Read(), T1 = Read(), S2 = Read(), T2 = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> F = Read(), T = Read(), L = Read() ;</span><br><span class="line">        Add(F, T, L) ; Add(T, F, L) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(S1, <span class="number">1</span>) ; Dijkstra(S2, <span class="number">3</span>) ; </span><br><span class="line">    Dijkstra(T1, <span class="number">2</span>) ; Dijkstra(T2, <span class="number">4</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Tot ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Dist[<span class="number">1</span>][E[i].F]  + E[i].L  + Dist[<span class="number">2</span>][E[i].T]  == Dist[<span class="number">1</span>][T1]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dist[<span class="number">3</span>][E[i].F] + E[i].L + Dist[<span class="number">4</span>][E[i].T] == Dist[<span class="number">3</span>][T2])</span><br><span class="line">            Add2(E[i].F, E[i].T, E[i].L, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Dist[<span class="number">3</span>][E[i].T] + E[i].L + Dist[<span class="number">4</span>][E[i].F] == Dist[<span class="number">3</span>][T2])</span><br><span class="line">            Add2(E[i].F, E[i].T, E[i].L, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> Add2(E[i].F, E[i].T, E[i].L, <span class="number">0</span>) ;</span><br><span class="line">        Ind[E[i].T] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    Topo() ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[T1]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      求无向图中两对点之间的最短路的最长公共路经。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="拓扑排序" scheme="http://Yeasion.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[ZJOI2004]嗅探器</title>
    <link href="http://Yeasion.github.io/2019/03/10/ZJOI2004-%E5%97%85%E6%8E%A2%E5%99%A8/"/>
    <id>http://Yeasion.github.io/2019/03/10/ZJOI2004-嗅探器/</id>
    <published>2019-03-10T02:12:04.000Z</published>
    <updated>2019-03-10T02:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5058" target="_blank" rel="noopener">Link</a><br>2004年的水题，10分钟就过了…我也不知道为什么难度是省选/NOI-，可能是恶意评分吧。<br>很简单，这个节点一定在两个中心节点中间的割点上。<br>然后我们还有两个需要判断的东西：</p><blockquote><ol><li>$Dfn[T] &gt;= Dfn[E[i].T]$<br>啥意思呢，就是说$T$，也就是我们在这两个中心节点中选的一个当做终点，要在$E[i].T$之后被搜到，这样可以保证使得$Now$是必经之路。</li><li>$Low[T] &gt;= Dfn[Now]$<br>也就是保证要经过$Now$点。<br>以上两个都是为了确保$Now$是两个中心节点的必经之路。<br>然后还要记得判断一下$Now != S &amp;&amp; Now != T$，不在两个中心节点上。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">100000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Dfn[MAXN], Low[MAXN], Tot, H[MAXN], Ken ;</span><br><span class="line"><span class="keyword">bool</span> Cut[MAXN] ; <span class="keyword">int</span> S, T, Ans = Inf ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F, T, Next ;</span><br><span class="line">&#125;   E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F, E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Dfn[Now] = Low[Now] = ++ Ken ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[E[i].T]) &#123;</span><br><span class="line">            Tarjan(E[i].T) ; </span><br><span class="line">            Low[Now] = min(Low[E[i].T], Low[Now]) ;</span><br><span class="line">            <span class="keyword">if</span> (Now != S &amp;&amp; Now != T)</span><br><span class="line">            <span class="keyword">if</span> (Dfn[Now] &lt;= Low[E[i].T])</span><br><span class="line">            <span class="keyword">if</span> (Dfn[E[i].T] &lt;= Dfn[T])</span><br><span class="line">            <span class="keyword">if</span> (Dfn[S] &lt;= Low[T]) </span><br><span class="line">                Ans = min(Ans, Now) ;</span><br><span class="line">        &#125;   Low[Now] = min(Low[Now], Dfn[E[i].T]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> A, B ;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line">        Add(A, B) ; Add(B, A) ;</span><br><span class="line">    &#125;   <span class="keyword">while</span> (A + B) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T ; </span><br><span class="line">    Tarjan(S) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans == Inf) <span class="built_in">puts</span>(<span class="string">"No solution"</span>) ;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ;&#125; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定一张不保证联通的图，图中有两个中心节点，现在要求寻找一个节点使得节点与两个中心节点都联通。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="Tarjan" scheme="http://Yeasion.github.io/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>[Noip2013]车站分级</title>
    <link href="http://Yeasion.github.io/2019/03/09/Noip2013-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/"/>
    <id>http://Yeasion.github.io/2019/03/09/Noip2013-车站分级/</id>
    <published>2019-03-09T12:42:52.000Z</published>
    <updated>2019-03-09T13:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1983" target="_blank" rel="noopener">Link</a><br>很脑缺的一道题，我也不知道自己为什么要整这个。<br>首先我们把题目转化一下，也就是在$i$车站之后没有停靠的火车站，其级别肯定都是低于$i$的级别。<br>于是我们有了一堆车站的大小关系，选择从小级别的车站像大级别的车站连边，然后跑一下拓扑排序就行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Train[MAXN][MAXN], S[MAXN], H[MAXN], Tot, Ans ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN], Link[MAXN][MAXN] ; <span class="keyword">int</span> Ind[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> F ; <span class="keyword">int</span> T ; <span class="keyword">int</span> Next ;&#125; E[MAXN &lt;&lt; <span class="number">10</span>] ;</span><br><span class="line"><span class="comment">//数组大小一定要开够，不然会爆炸.....</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span> <span class="keyword">int</span> Num ; <span class="keyword">int</span> Level ;&#125; G ;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node2&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Ind[i]) Q.push(&#123;i, <span class="number">1</span>&#125;) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;   </span><br><span class="line">        <span class="keyword">int</span> Now = Q.front().Num, L = Q.front().Level ;</span><br><span class="line">        Q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next) &#123;</span><br><span class="line">            Ind[E[i].T] -- ;</span><br><span class="line">            <span class="keyword">if</span> (! Ind[E[i].T]) Q.push(&#123;E[i].T, L + <span class="number">1</span>&#125;), </span><br><span class="line">                               Ans = max(Ans, L + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">        S[i] = Read() ;</span><br><span class="line">        <span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S[i] ; j ++)</span><br><span class="line">            Train[i][j] = Read(), V[Train[i][j]] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Train[i][<span class="number">1</span>] ; j &lt;= Train[i][S[i]] ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! V[j]) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= S[i] ; k ++)</span><br><span class="line">                <span class="keyword">if</span> (! Link[j][Train[i][k]]) &#123;</span><br><span class="line">                    Ind[Train[i][k]] ++ ;</span><br><span class="line">                    Add(j, Train[i][k]) ;</span><br><span class="line">                    Link[j][Train[i][k]] = <span class="number">1</span> ;</span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   Topo() ; <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给定$N$个车站，每个车站有每个车站的级别，规定一辆火车如果停靠在过了一个级别为$X$的车站，那么之后所有级别大于等于$X$的车站都要停靠。现在给出$M$个车次的停靠结果，问这$N$个火车站最少要分为多少个不同的级别才能使$M$个方案都合法。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Noip" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/Noip/"/>
    
    
      <category term="拓扑排序" scheme="http://Yeasion.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2014]数表</title>
    <link href="http://Yeasion.github.io/2019/03/08/SDOI2014-%E6%95%B0%E8%A1%A8/"/>
    <id>http://Yeasion.github.io/2019/03/08/SDOI2014-数表/</id>
    <published>2019-03-08T12:19:35.000Z</published>
    <updated>2019-03-10T02:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/solution/P3312" target="_blank" rel="noopener">Link</a><br>对于</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j))</script><p>这个式子来说，我们首先把它变换一下<br>改变枚举顺序</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ N \sum_{j = 1} ^ M [gcd(i,j) == d]</script><p>把$d$除过去</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} [gcd(i,j) == 1]</script><p>把最后的式子莫比乌斯反演一下</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} \sum _{x | i, x | j} \mu (x)</script><p>把$x$的枚举挪到前面去。</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum _{x = 1} ^ {N / d}\mu (x) \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor</script><p>设$T = dx$，然后再变一下枚举顺序。</p><script type="math/tex; mode=display">\sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \sum_{d | T} F(d) \mu (\frac{T}{d})</script><p>然后发现出现了狄雷克利卷积，这就非常棒。然后我们记一个</p><script type="math/tex; mode=display">G(T) = \sum_{d | T} F(d) \mu (\frac{T}{d})</script><p>然后式子变成</p><script type="math/tex; mode=display">\sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor G(T)</script><p>这道题比较难的地方就在于其要求不大于$a$。于是我们将原来的$F(x)$函数加上一个$a$的限制。然后发现$F(d) \leq a$时对答案产生贡献。<br>对于随着$a$的变化而变化的$G(x)$，采取离线筛选然后升序排序的情况。<br>然后问题转化成了一个很熟悉的形式：</p><ol><li>每次加入$d$满足$F(d) \leq a$</li><li>查询前缀和。<br>然后我们就可以用树状数组来进行维护。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> Mod = (<span class="number">1L</span>L &lt;&lt; <span class="number">31</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> U[MAXN], F[MAXN], S[MAXN], P[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Sum[MAXN], Ans[MAXN], Tot, B[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N, M, A, Num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; Y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A &lt; Y.A ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   E[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node2 &amp; Y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> S[X] &lt; S[Y.X] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    S[<span class="number">1</span>] = U[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! B[i]) &#123;</span><br><span class="line">            P[Tot ++] = i ; U[i] = - <span class="number">1</span> ;</span><br><span class="line">            S[i] = i + <span class="number">1</span> ; F[i] = i + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0</span> ; j &lt; Tot ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * P[j] &gt; MAXN) <span class="keyword">break</span> ;</span><br><span class="line">            B[i * P[j]] = <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                U[i * P[j]] = <span class="number">0</span> ; </span><br><span class="line">                F[i * P[j]] = F[i] * P[j] + <span class="number">1</span> ;</span><br><span class="line">                S[i * P[j]] = S[i] / F[i] * F[i * P[j]] ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            U[i * P[j]] = - U[i] ; </span><br><span class="line">            F[i * P[j]] = P[j] + <span class="number">1</span> ;</span><br><span class="line">            S[i * P[j]] = S[i] * (P[j] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) G[i].X = i ;</span><br><span class="line">    sort(G + <span class="number">1</span>, G + MAXN + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123; <span class="keyword">return</span> Now &amp; (- Now) ; &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now, <span class="keyword">long</span> <span class="keyword">long</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Now &lt;= MAXN) &#123;</span><br><span class="line">        Sum[Now] = ((LL) Sum[Now] + K) % Mod ;</span><br><span class="line">        Now += Lowbit(Now) ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i * Now &lt;= MAXN ; i ++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; U[i] &lt;&lt; " " &lt;&lt; S[Now]&lt;&lt; " " &lt;&lt; (LL) U[i] * S[Now] % Mod &lt;&lt; endl ;</span></span><br><span class="line">        <span class="comment">// system("pause") ;</span></span><br><span class="line">        Add(Now * i, (LL) U[i] * S[Now] % Mod) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Query</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (Now &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Ans = ((LL) Ans + Sum[Now]) % Mod ;</span><br><span class="line">        Now &amp;= Now - <span class="number">1</span> ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Answer</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span>, ll = <span class="number">0</span>, rr ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r ; l &lt;= L ; l = r + <span class="number">1</span>, ll = rr) &#123;</span><br><span class="line">        r = min (L / (L / l), R / (R / l)) ;</span><br><span class="line">        rr = Query(r) ;</span><br><span class="line">        Ans = (Ans + ((LL) rr - ll) % Mod * (L / l) % Mod * (R / l) % Mod) % Mod;</span><br><span class="line">    &#125;   <span class="keyword">return</span> ((LL) Ans + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = Read() ; Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++) &#123;</span><br><span class="line">        E[i].N = Read(), E[i].M = Read(), E[i].A = Read() ;</span><br><span class="line">        <span class="keyword">if</span> (E[i].N &gt; E[i].M) swap(E[i].N, E[i].M) ;</span><br><span class="line">        E[i].Num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + T + <span class="number">1</span>) ; <span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= MAXN &amp;&amp; S[G[j].X] &lt;= E[i].A ; j ++)</span><br><span class="line">            Change(G[j].X) ;</span><br><span class="line">        Ans[E[i].Num] = Answer(E[i].N, E[i].M) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定$N$和$M$，$F(X)$表示$X$的约数和，求$$\sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j)) ~mod ~ 2 ^{31}$$
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="前缀和" scheme="http://Yeasion.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>[POI2011]MET-Meteors</title>
    <link href="http://Yeasion.github.io/2019/03/05/POI2011-MET-Meteors/"/>
    <id>http://Yeasion.github.io/2019/03/05/POI2011-MET-Meteors/</id>
    <published>2019-03-05T09:27:05.000Z</published>
    <updated>2019-03-05T09:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3527" target="_blank" rel="noopener">Link</a><br>考虑朴素算法，循环$K$次，每次循环$1$到$N$增加相应的$[L,R,A]$，然后$O(N)$判断某一个数是不是已经合法。这样的算法的时间复杂度是$O(N^3)$，那么我们考虑逐步优化。</p><ol><li>首先区间加我们肯定可以使用线段树或者树状数组，这里使用的是后者。</li><li>改换一下枚举顺序就可以变成先枚举每一个数，然后枚举$K$次，然后我们发现枚举$K$次的这个步骤是单调的，因为对于某一个数，如果在$X$次区间加之后没有合法，那么在之前肯定也是不合法的，如果在$X$次区间加之后是合法的，那么在这之后肯定也是合法的，所以这个枚举$K$的步骤是单调的，于是可以考虑二分答案。<br>那么总步骤就得出来了：<blockquote><ol><li>枚举每一个位置</li><li>二分区间加的次数</li><li>树状数组区间加</li></ol></blockquote></li></ol><p>总时间复杂度$O(Nlog^2N)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给定一个环，每个节点有一个所属国家，$K$次事件，每次对$[L,R]$区间上的每个点点权加上一个值$A$，求每个国家最早多少次操作之后所有点的点权和能达到一个特定值。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/POI/"/>
    
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="整体二分" scheme="http://Yeasion.github.io/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[NOI2010]超级钢琴</title>
    <link href="http://Yeasion.github.io/2019/03/03/NOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/"/>
    <id>http://Yeasion.github.io/2019/03/03/NOI2010-超级钢琴/</id>
    <published>2019-03-03T06:43:20.000Z</published>
    <updated>2019-03-04T09:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2048" target="_blank" rel="noopener">Link</a><br>我们先来考虑朴素算法：将所有的方案求出来，然后排序。但是这样当然是不可能过的。<br>对于某一个区间的综合我们肯定很自然地想到前缀和。<br>那首先定住一个左节点$X$，那么这个区间的右端点肯定处于$[X + L - 1, X + R - 1]$之间。<br>那么如果我们想要求这个区间里面的最大值，可以考虑使用询问时间复杂度为$O(1)$的$ST$表。<br>如果右端点为$Y$，那么区间的值就是$Sum[Y] - Sum[X]$，那么我们可以直接寻找右端点区间中的$Sum[i]$的最大值。<br>然后我们就得到了一堆区间的最大值，一共应该是$N - R + 1$，但是$K$是有可能大于这个数的，因此我们不能只求这个区间的最大值。<br>于是考虑将这个区间二分。<br>具体来说，就是首先将所有以$i$左端点，右端点在$[X + L - 1, X + R - 1]$的一个结构体存储到一个大根堆中，当然，本人使用的是单调队列，因为这样结构比较清晰。<br>然后循环$K$次，每次取出堆顶计入答案。<br>接下来的操作是以当前答案所处的右端点为中间，二分$[X + L - 1, X + R - 1]$这个区间，分别加入单调队列。因为如果想要寻找原来右端点区间中的第二大，第三大，我们选择去掉当前的最大值，然后将它的左边和右边分别入队，算法正确性就可以保证了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line">LL N, K, L, R, Muc[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  Sum[MAXN], Max[MAXN][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ST_BUILD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Max[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; (<span class="number">1</span> &lt;&lt; j) &lt;= N ; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Max[i][j - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">int</span> Y = Max[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[X] &gt; Sum[Y]) Max[i][j] = X ;</span><br><span class="line">        <span class="keyword">else</span> Max[i][j] = Y ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = log2(R - L + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> X = Max[L][T], Y = Max[R - (<span class="number">1</span> &lt;&lt; T) + <span class="number">1</span>][T] ;</span><br><span class="line">    <span class="keyword">return</span> Sum[X] &gt; Sum[Y] ? X : Y ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, L, R, P ;</span><br><span class="line">    Q() &#123;&#125; Q (<span class="keyword">int</span> X, <span class="keyword">int</span> L, <span class="keyword">int</span> R) : X(X), L(L), R(R), P(Query(L, R)) &#123;&#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Q &amp; A, <span class="keyword">const</span> Q &amp; B) &#123;</span><br><span class="line">            <span class="keyword">return</span> Sum[A.P] - Sum[A.X - <span class="number">1</span>] &lt; Sum[B.P] - Sum[B.X - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Q&gt; E ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), K = Read(), L = Read(), R = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        Muc[i] = Read() ;</span><br><span class="line">        Sum[i] = Sum[i - <span class="number">1</span>] + Muc[i] ;</span><br><span class="line">    &#125;   ST_BUILD() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i + L - <span class="number">1</span> &lt;= N) </span><br><span class="line">            E.push(Q(i, i + L - <span class="number">1</span>, min(i + R - <span class="number">1</span>, N))) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = E.top().X, l = E.top().L, r = E.top().R, P = E.top().P ;</span><br><span class="line">        E.pop() ; Ans += Sum[P] - Sum[X - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (l != P) E.push(Q(X, l, P - <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (r != P) E.push(Q(X, P + <span class="number">1</span>, r)) ;</span><br><span class="line"></span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      定义超级和弦为区间内长度处于$[L,R]$之间的一段连续区间和。两个超级和弦相同当且仅当这两个超级和弦所包含的音符集合相同。要求在序列中选出K个不同的超级和弦，使得所有超级和弦的和最大。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="NOI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/NOI/"/>
    
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="前缀和" scheme="http://Yeasion.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="堆" scheme="http://Yeasion.github.io/tags/%E5%A0%86/"/>
    
      <category term="ST表" scheme="http://Yeasion.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2009]粉刷匠</title>
    <link href="http://Yeasion.github.io/2019/03/03/SCOI2009-%E7%B2%89%E5%88%B7%E5%8C%A0/"/>
    <id>http://Yeasion.github.io/2019/03/03/SCOI2009-粉刷匠/</id>
    <published>2019-03-03T01:00:39.000Z</published>
    <updated>2019-03-03T06:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4158" target="_blank" rel="noopener">Link</a><br>2019的四川NOI题目，很经典的动态规划题目。<br>首先设$Dp[i][j][k][l]$表示当到达$(i,~j)$点的时候恰好用了$k$次粉刷的机会，其中$l$只有$0$和$1$两种取值，因为题目中说的一个格子如果没有被粉刷或者粉刷上了错误的颜色都算粉刷错误，因此我们可以将这两种情况分开来看，统一成$0$，如果粉刷对了就是$1$。<br>状态转移：<br>对于每一次换木板的时候要刷一次，那么最优情况下，也就是跟前一个木板完全一样的情况下，我们将上一块木板的$Dp$转移过来就可以了。记住要把$1$和$0$的状态都转移过来。</p><script type="math/tex; mode=display">Dp[i][j][k][0] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) ;</script><script type="math/tex; mode=display">Dp[i][j][k][1] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) + 1 ;</script><p>然后对于上一个格子和当前格子的颜色都一样的话，我们就像换行一样进行处理。将上一个格子的状态直接转移过来就可以了。</p><script type="math/tex; mode=display">Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1,</script><script type="math/tex; mode=display">Dp[i][j][k][0] = Dp[i][j - 1][k][0] ;</script><p>如果上一个格子的颜色与当前格子的颜色不一样，那么可以选择</p><ol><li>继续上一个格子的颜色，不减少机会，但是当前的格子就错误了。</li><li>减少一次机会，换一个k，当前的格子粉刷正确。<script type="math/tex; mode=display">Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ;</script><script type="math/tex; mode=display">Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ;</script>所以从思路上来说是非常简单的，只要你能想到是几维的Dp，接下来的转移方程基本是水到渠成的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">60</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">60</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">2510</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K, Color[MAXN][MAXM], Dp[MAXN][MAXM][MAXT][<span class="number">2</span>], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read(), K = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="built_in">string</span> A ; <span class="built_in">cin</span> &gt;&gt; A ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">            Color[i][j] = A[j - <span class="number">1</span>] - <span class="string">'0'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= K ; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) Dp[i][j][k][<span class="number">0</span>] = max(Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">0</span>], Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">1</span>]),</span><br><span class="line">                    Dp[i][j][k][<span class="number">1</span>] = max(Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">0</span>], Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (Color[i][j] == Color[i][j - <span class="number">1</span>])</span><br><span class="line">            Dp[i][j][k][<span class="number">1</span>] = Dp[i][j - <span class="number">1</span>][k][<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">            Dp[i][j][k][<span class="number">0</span>] = Dp[i][j - <span class="number">1</span>][k][<span class="number">0</span>] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Dp[i][j][k][<span class="number">1</span>] = max(Dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>, Dp[i][j - <span class="number">1</span>][k][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line">                Dp[i][j][k][<span class="number">0</span>] = max(Dp[i][j - <span class="number">1</span>][k][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        Ans = max(Ans, max(Dp[i][j][k][<span class="number">0</span>], Dp[i][j][k][<span class="number">1</span>])) ;</span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>没有写滚动数组，追求完美的当然可以滚动，但是不滚动数组也依然能过啦~。</p>]]></content>
    
    <summary type="html">
    
      粉刷$N$条木板，每条木板有$M$个格子，只能被涂成蓝色或者红色，每次粉刷只能选择一条木板上的一段连续的格子。每个格子最多只能被粉刷一次。最多能粉刷$T$次，求最多能粉刷多少个格子。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="http://Yeasion.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2009]虔诚的墓主人</title>
    <link href="http://Yeasion.github.io/2019/02/25/SDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA/"/>
    <id>http://Yeasion.github.io/2019/02/25/SDOI2009-虔诚的墓主人/</id>
    <published>2019-02-25T08:57:23.000Z</published>
    <updated>2019-03-03T06:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154" target="_blank" rel="noopener">Link</a></p><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><p>转化一下题目的要求，假设我们知道点$(i,j)$的上下左右的常青树的个数分别为$U[i][j]$，$D[i][j]$，$L[i][j]$和$R[i][j]$，那么依据一个很简单的组合数学我们知道：</p><script type="math/tex; mode=display">Ans = C_{K}^{U[i][j]} \times C_{K}^{D[i][j]} \times C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}</script><p>其中$C$为组合。基本的思路就是这样，但是我们要考虑优化。<br>从空间上来说，$1 \leq N, M \leq 1000000000$，肯定会直接爆炸（并且空间限制还是$128MB$）。题目并不要求十分确切的常青树位置，因此可以直接离散化。于是我们可以将坐标离散到一个$W \times W$的图中，因为$1 \leq W \leq 10000$，因此空间的问题就直接解决了。<br>然后是时间，对于每一个墓地，原始做法是$O(N^2)$的求出上下左右的四个数组，但是最终的时间复杂度是$O(N^4)$。于是对于优化来说这里用到一个<strong>扫描线</strong>的思想。<br>对于扫描线的具体讲解可以直接$Google$，这里只是针对题目讲方法罢了。<br>将所有的常青树按照$X$为第一关键字，$Y$为第二关键字的方法升序排序。<br>对于同一行的两个常青树，如果中间没有任何常青树，那么发现中间的所有的墓地的$L[i][j]$和$R[i][j]$都相等，因此只需要前缀和预处理出来</p><script type="math/tex; mode=display">\sum_{i}^{N} \sum_{j}^M C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}</script><p>即可，下面要求的就只剩下了$U[i][j]$和$D[i][j]$。</p><p>维护上下所有常青树的乘积，而左右乘积的改变次数就等于常青树的个数，而考虑其他行的时候上下乘积的改变次数也就是常青树的个数。</p><p>于是我们要维护上下组合数的乘积的区间和，这种维护显然就可以线段树或者树状数组。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>对于同一行的两个数$A$和$B$，$Ans += C_{k}^{L[A]} \times C_{k}^{R[B]}$，然后用树状数组维护$A$和$B$点的$C_{k}^{U[i]} \times  C_{k}^{D[i]}$的和。（省略掉了列，因为是同一行嘛）</p><p>答案实际上就是</p><script type="math/tex; mode=display">\sum C_{k}^{L[A]} \times C_{k}^{R[B]} \times \sum [C_{k}^{U[i]} \times  C_{k}^{D[i]}]</script><p>从左向右处理的时候，修改树状数组该点横坐标位置上的数值为</p><script type="math/tex; mode=display">C_{k}^{U[i]} \times C_{k}^{D[i]} - C_{k}^{U[i] + 1} \times C_{k}^{D[i] +1}</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7ffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">2147483647</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, W, K, S[MAXN], C[MAXN][<span class="number">11</span>] ;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN], Ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, L, R, U, D ;</span><br><span class="line">&#125;   E[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Sum[MAXN] ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Now &amp; ( - Now) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> Now, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Now &lt;= W) &#123;</span><br><span class="line">            Sum[Now] += K ;</span><br><span class="line">            Now += Lowbit(Now) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (Now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Ans += Sum[Now] ;</span><br><span class="line">            Now -= Lowbit(Now) ;</span><br><span class="line">        &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   Bit ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CMP</span><span class="params">(Node A, Node B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.Y != B.Y) <span class="keyword">return</span> A.Y &lt; B.Y ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.X &lt; B.X ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= min(K, i); j ++)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + W + <span class="number">1</span>, CMP) ;</span><br><span class="line">    <span class="keyword">int</span> Ken = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i - <span class="number">1</span>].Y) Ken ++ ;</span><br><span class="line">        <span class="keyword">else</span> Ken = <span class="number">1</span> ;  E[i].L = Ken ;</span><br><span class="line">        S[E[i].X] ++ ; E[i].U = S[E[i].X] ;</span><br><span class="line">    &#125;   Ken = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = W ; i &gt;= <span class="number">1</span> ; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i + <span class="number">1</span>].Y) Ken ++ ;</span><br><span class="line">        <span class="keyword">else</span> Ken = <span class="number">1</span> ; E[i].R = Ken ;</span><br><span class="line">        E[i].D = S[E[i].X] - E[i].U ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read(), W = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        E[i].X = Read(), E[i].Y = Read() ;</span><br><span class="line">        X[i] = E[i].X ; Y[i] = E[i].Y ;</span><br><span class="line">    &#125;   K = Read() ;</span><br><span class="line">    sort(X + <span class="number">1</span>, X + W + <span class="number">1</span>) ;</span><br><span class="line">    sort(Y + <span class="number">1</span>, Y + W + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= W ; i ++) &#123;</span><br><span class="line">        E[i].X = lower_bound(X + <span class="number">1</span>, X + W + <span class="number">1</span>, E[i].X) - X ;</span><br><span class="line">        E[i].Y = lower_bound(Y + <span class="number">1</span>, Y + W + <span class="number">1</span>, E[i].Y) - Y ;</span><br><span class="line">    &#125;   Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> V = Bit.Query(E[i].X) - Bit.Query(E[i].X - <span class="number">1</span>) ;</span><br><span class="line">        Bit.Add(E[i].X, - V) ;</span><br><span class="line">        Bit.Add(E[i].X, C[E[i].U][K] * C[E[i].D][K]) ;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i - <span class="number">1</span>].Y)</span><br><span class="line">            Ans = Ans + C[E[i - <span class="number">1</span>].L][K] * C[E[i].R][K] * </span><br><span class="line">            (Bit.Query(E[i].X - <span class="number">1</span>) - Bit.Query(E[i - <span class="number">1</span>].X));</span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans &amp; Mod) ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有人说可不可以搞一个二维线段树，思路上来说是可行的，但是空间上大概会爆炸吧~。<br>最后在冲浪的时候发现由于模数为$2147483647$所以可以自然溢出然后最后$ \&amp; 2147483646$就可以了。</p>]]></content>
    
    <summary type="html">
    
      在$N \times M$的墓地中，每一个墓碑的虔诚度为上下左右恰好有$K$棵常青树组成的十字架的个数，要求计算墓地中所有墓碑的虔诚度之和。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="组合数学" scheme="http://Yeasion.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线段树" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="离散化" scheme="http://Yeasion.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[POI2012]FES-Festival</title>
    <link href="http://Yeasion.github.io/2019/02/23/POI2012-FES-Festival/"/>
    <id>http://Yeasion.github.io/2019/02/23/POI2012-FES-Festival/</id>
    <published>2019-02-23T12:01:01.000Z</published>
    <updated>2019-03-09T13:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3530" target="_blank" rel="noopener">Link</a><br>看到题目首先肯定想到差分约束，当然这也是一个差分约束的题。<br>题目比较难想的地方在于建图，设$Dist[i][j]$表示$max\{A_i - A_j\}$，也就是$A_i$最多能比$A_j$大多少。那么根据题意我们知道对于第一种情况，应该是</p><script type="math/tex; mode=display">Dist[X][Y] = 1,~Dist[Y][X] = - 1</script><p>然后对于第二种情况，题目对数量上并没有限制，限制的只是大小关系，然而我们转化一下依然能知道$A_Y - A_X \geq 0$，对此我们选择从$Y$向$X$连一条边权为零的单项边，然后$Dist[Y][X] = 0$，对于这种情况我们连边的目的不是为了限制数值，而是为了限制关系，大小关系。<br>由于限制条件可以叠加，于是对于每一个建边都要取$min$。<br>然后首先要考虑的肯定是合法问题。稍加分析我们可以知道图如果存在<strong>非零环</strong>，肯定是不合法的，于是我们考虑判断非零环。<br>一般来说判负环就是简单地跑一遍$Spfa$然后记录每一个点入队的次数就可以解决。但是这个题有一点问题。就是这个图并不一定是联通的。所以不论以哪一个节点作为起点都是不能保证的。因此舍弃$Spfa$，观察数据发现$N \leq 600$非常的小，完全可以考虑$Floyed$，使用弗洛伊德的判断负环的方式就是看有没有$Dist[i][i] != 0$，然后弗洛伊德怎么解决问题了呢？<br>因为图并不是联通的，但是只要每一个强连通分量合法就可以了，于是我们考虑$Tarjan$缩点，然后对于每一个强联通分量分别求解。<br>在三重循环的过程中判断$i,j,k$是不是都属于一个强连通分量，然后就可以有一个小小的优化。<br>缩完点之后发现剩下的就是连接每一个联通块的零权边，对答案并没有影响，只会影响关系，并且我们设的$Dist[i][j]$表示的是$i,j$的最大差值，于是就可以寻找每一个强联通分量里面的最大值。并且每一个强联通分量在数值上没有关系，因此将答案直接累加即可，最后输出答案加上强连通分量的数量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RE register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">610</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">1000000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M1, M2, D[MAXN], H[MAXN], Tot ;</span><br><span class="line"><span class="keyword">int</span> Low[MAXN], Dfn[MAXN], B[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> S[MAXN], Top, Ken, Cnt, Ans ; </span><br><span class="line"><span class="keyword">bool</span> Insta[MAXN], Inq[MAXN], V[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Num[MAXN], Max, Dist[MAXN][MAXN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F, T, L, Next ;</span><br><span class="line">&#125;   E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F  = F, E[Tot].T = T ;</span><br><span class="line">    E[Tot].L = L ; E[Tot].Next = H[F] ; </span><br><span class="line">    H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Dfn[Now] = Low[Now] = ++ Ken ;</span><br><span class="line">    S[++ Top] = Now ; Insta[Now] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next) </span><br><span class="line">        <span class="keyword">if</span> (! Dfn[E[i].T]) &#123;</span><br><span class="line">            Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Insta[E[i].T]) Low[Now] = min(Dfn[E[i].T], Low[Now]) ;</span><br><span class="line">    <span class="keyword">if</span> (Dfn[Now] == Low[Now]) &#123;</span><br><span class="line">        Cnt ++ ; <span class="keyword">int</span> Pass ;</span><br><span class="line">        <span class="keyword">do</span> &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Insta[Pass] = <span class="literal">false</span> ;</span><br><span class="line">        &#125;   <span class="keyword">while</span> (Pass != Now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M1 = Read(), M2 = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        Dist[i][j] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M1 ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Read(), Y = Read() ;</span><br><span class="line">        Add(X, Y, <span class="number">1</span>) ; Add(Y, X, - <span class="number">1</span>) ;</span><br><span class="line">        Dist[X][Y] = min(Dist[X][Y], <span class="number">1</span>) ;</span><br><span class="line">        Dist[Y][X] = min(Dist[Y][X],  - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Dist[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M2 ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Read(), Y = Read() ;</span><br><span class="line">        Add(Y, X, <span class="number">0</span>) ;</span><br><span class="line">        Dist[Y][X] = min(Dist[Y][X], <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[i]) Tarjan(i) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N ; k ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (B[k] == B[i])</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> (B[i] == B[j])</span><br><span class="line">        Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Dist[i][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"NIE"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> (B[i] == B[j])</span><br><span class="line">        D[B[i]] = max(D[B[i]], Dist[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Ans += D[i] ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans + Cnt) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后发现弗洛伊德跑还是比较慢，最后加了很多$register$和$inline$才勉强卡过去。后来知道有一个非常神奇的深搜版$Spfa$，应该是可以更好地解决这个问题的。</p>]]></content>
    
    <summary type="html">
    
      给定多组限制，分为两类，分别为$$Ax +1 = Ay$$ $$Ax \leq Ay$$在使得等式成立的情况下，求这些数的取值的方案数为多少。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/POI/"/>
    
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Tarjan" scheme="http://Yeasion.github.io/tags/Tarjan/"/>
    
      <category term="Floyed" scheme="http://Yeasion.github.io/tags/Floyed/"/>
    
      <category term="差分约束系统" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>[国家集训队]墨墨的等式</title>
    <link href="http://Yeasion.github.io/2019/02/17/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%A2%A8%E5%A2%A8%E7%9A%84%E7%AD%89%E5%BC%8F/"/>
    <id>http://Yeasion.github.io/2019/02/17/国家集训队-墨墨的等式/</id>
    <published>2019-02-17T01:06:24.000Z</published>
    <updated>2019-03-09T13:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2371" target="_blank" rel="noopener">Link</a><br>题意大概就是求$B_l,B_r$范围内$B$的个数使等式</p><script type="math/tex; mode=display">\sum_{i = 1}^N a_Nx_N = B</script><p>存在非负整数解。其实转化一下题意也就是</p><blockquote><p>在N种物品中任意选择，物品有一个价值，使得最后的总价值处于给定区间内。</p></blockquote><p>这很显然是一个完全背包，而且是类似于一种模板题，但是这道题的数据范围是$B \leq 10^{12}$，因此这么做显然是不行的，但是我们可以从完全背包的视角出发思考题目。<br>我们取出最小的$a$为$a_{min}$,并且假设我们现在知道了一种方案，物体的总重为$D[i]$，并且满足<script type="math/tex">K ~mod~ a_{min} = i</script>，在这两种条件下$D[i]$为最小值。<br>那么显然，对于任意一个同样满足上述两个条件的总重X，$X \leq D[i]$，并且因为$X ~mod~ a_{min} = D[i] ~mod~ a_{min}$，所以可以知道$X$方案可以由$D[i]$方案加上若干个$a_{min}$得到。<br>现在我们考虑加入一个物体$Now$，那么有</p><script type="math/tex; mode=display">D[(i + Now) ~mod~ a_{min}]</script><p>可以从$d[i] + Now$而来。于是可以考虑从i向$(i + Now) ~mod~ a_{min}$连一条比边权为$Now$的边，而求$D[i]$的最小值也就被转化成了最短路问题。<br>那么算法就得出来了：</p><blockquote><ol><li>首先求一下$a_{min}$的最小值保存下来。</li><li>跑最短路，预处理出D数组。</li><li>枚举所有的D，计算mod T = i的数在区间$B_l,B_r$中有多少个。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500010</span> ;</span><br><span class="line">LL Inf = (LL)<span class="number">1</span> &lt;&lt; <span class="number">60</span> ;</span><br><span class="line"></span><br><span class="line">LL N, L, R, a[MAXN], H[MAXN], Tot, D[MAXM] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> F, T, L, Next ;&#125; E[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q ; <span class="keyword">bool</span> F[MAXM] ; LL K, Ans ;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ;</span><br><span class="line">    E[Tot].Next = H[F] ; H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; K ; i ++) D[i] = Inf ;</span><br><span class="line">    D[S] = <span class="number">0</span> ; F[S] = <span class="number">1</span> ; Q.push(S) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; F[Now] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> T = (Now + a[i]) % K ;</span><br><span class="line">            <span class="keyword">if</span> (D[T] &gt; D[Now] + a[i]) &#123;</span><br><span class="line">                D[T] = D[Now] + a[i] ;</span><br><span class="line">                <span class="keyword">if</span> (! F[T]) Q.push(T), F[T] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), L = Read(), R = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) a[i] = Read() ;</span><br><span class="line">    sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>) ; K = a[<span class="number">1</span>] ; <span class="comment">//储存最小的a。</span></span><br><span class="line">    Spfa(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; K ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (D[i] != Inf) D[i] = (D[i] - i) / K ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; K ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (D[i] != Inf) &#123;</span><br><span class="line">            <span class="keyword">int</span> K1 = (L - i - <span class="number">1</span>) / K - D[i] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> K2 = (R - i) / K - D[i] + <span class="number">1</span> ;</span><br><span class="line">            Ans = Ans - max(K1, <span class="number">0</span>) + max(K2, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在求解用$\{a_i\}$能组成多少个在$B_l, B_r$范围内的数的问题其实是很经典的图论问题，像这种建图困难，但是最短路很好跑的题目便可以称为是建图题了。</p>]]></content>
    
    <summary type="html">
    
      给定$N$，${a_i}$一个正整数$B$的范围$B_l,B_r$，求$$\sum_{i = 1}^N a_Nx_N = B$$在$B_l,B_r$范围中有多少$B$使等式存在非负整数解。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="国家集训队" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[国家集训队]Crash的数字表格</title>
    <link href="http://Yeasion.github.io/2019/02/16/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
    <id>http://Yeasion.github.io/2019/02/16/国家集训队-Crash的数字表格/</id>
    <published>2019-02-16T03:35:36.000Z</published>
    <updated>2019-03-09T13:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1829" target="_blank" rel="noopener">Link</a><br>如题，给定$N$和$M$，求</p><script type="math/tex; mode=display">\sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)</script><p>有人说这道题是BZOJ上面的JZPTAB，但其实不是，JZBTAB虽然具体问题和改题是一样的，但是那道题是多组询问，比这道题还要难一些。<br>首先我们知道$lcm(i,j) = \frac{i \times j}{gcd(i,j)}$，那么题目转化为</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j=1}^M \frac{i \times j}{gcd(i,j)}</script><p>然后我们枚举最大公约数，式子转化为</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} \sum_{i = 1} ^ N \sum_{j = 1}^ M \frac{i \times j}{d} [gcd(i,j) == d]</script><p>提出d,式子变成</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d}[gcd(i, j) == 1] \times ij</script><p>并且我们知道</p><script type="math/tex; mode=display">\sum_{d|N}\mu (d) = [N == 1]</script><p>直接带入上面的式子可以得到</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d} \sum_{x|gcd(i,j)} \mu (x) \times ij</script><p>保留前缀和$S[i]$，优先枚举$x$。</p><script type="math/tex; mode=display">\sum _{d = 1} ^ N d \sum_{x = 1}^{n / d} x ^ 2 μ (x) S(\frac {N}{dx}) S(\frac {M}{dx})</script><p>优先枚举$S$</p><script type="math/tex; mode=display">\sum_{dx = 1}^{N} S(\frac{N}{dx} S(\frac{M}{dx})dx \sum_{e|dx}e \mu(dx))</script><p>对于其中的$f(dx) = dx \sum_{e|dx}e \mu(dx)$可以线性筛，有式子</p><script type="math/tex; mode=display">f(dxp) = f(dx)f(p)</script><p>之后的式子可以整除分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">20101009</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, F[MAXN], P[MAXN], Tot ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN] ;<span class="keyword">int</span> Sum[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MOD</span> <span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Now &gt;= Mod) <span class="keyword">return</span> Now - Mod ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Now ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= min(N, M) ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) &#123;</span><br><span class="line">P[++ Tot] = i, F[i] = MOD (Mod + <span class="number">1</span> - i) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt;= min(N, M) ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) F[i * P[j]] = <span class="number">1L</span>L * F[i] * F[P[j]] % Mod ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">F[i * P[j]] = F[i] ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= min(N, M) ; i ++)</span><br><span class="line">F[i] = MOD(F[i - <span class="number">1</span>] + <span class="number">1l</span>l * F[i] * i % Mod) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= max(N, M) ; i ++)</span><br><span class="line">Sum[i] = MOD(Sum[i - <span class="number">1</span>] + i) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ; Init() ; Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= min(N, M) ; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(N / (N / l), M / (M / l)) ;</span><br><span class="line"><span class="keyword">int</span> Ans2 = MOD(F[r] - F[l - <span class="number">1</span>] + Mod) ;</span><br><span class="line">Ans = MOD(Ans + <span class="number">1L</span>L * Ans2 * Sum[N / l] % Mod * Sum[M / l] % Mod) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans % Mod) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的式子确实难推，但是时间复杂度化简到$O(N)$左右也就可以了，据说BZOJ上面的题目是真正的JZPTAB是多组数据，时间复杂度要推倒$O(\sqrt N)$才行。至于那种级别的题目，即使没有眼见为实，笔者也是有做不了的自知之明的…如果有想要了解的朋友还请另寻高就吧。</p>]]></content>
    
    <summary type="html">
    
      给定$N$和$M$，求$$\sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)$$
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="国家集训队" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得与扩展中国剩余定理ExCrt</title>
    <link href="http://Yeasion.github.io/2019/02/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt/"/>
    <id>http://Yeasion.github.io/2019/02/15/欧几里得与扩展中国剩余定理ExCrt/</id>
    <published>2019-02-15T07:27:39.000Z</published>
    <updated>2019-04-05T03:18:48.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>为什么要放欧几里得算法，因为这个玩意是扩展欧几里得的铺垫，为什么要将扩展欧几里得，因为这个玩意是中国剩余定理的铺垫。<br>很简单，就是要我们求$gcd(i,j)$。由于证明过程十分繁琐并且没有什么很大的意义，所以便不多管闲事地证明了，结论也很简单：$gcd(i,j) = gcd(j, i \% j)$。于是可以不断递归，直到j变成0，然后返回i就可以了，很常见的方法，直接放代码了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X ;</span><br><span class="line"><span class="keyword">return</span> Gcd(Y, X % Y) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>裴蜀定理是扩展欧几里得算法的第二个铺垫，也是一个关于最大公约数的定理。<br>假设有一个线性方程$ax + by = c$，问这个方程有没有整数解，那么根据裴蜀定理我们就知道当$gcd(a,b) | c$的时候线性方程才可能有整数解。简单的证明就是$gcd(a,b)$显然$|(ax+by)$。对于$gcd(a,b)|c$的情况有没有整数解我们便需要用到扩展欧几里得。</p><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>对于</p><script type="math/tex; mode=display">ax + by = gcd(a,b)</script><p>当$a &lt; 0$的时候，式子就可以变成</p><script type="math/tex; mode=display">|a| (-x) + by = gcd(|a|, b)</script><p>可以知道这个式子必然是有整数解的。我们可以对于$(a,b)$进行欧几里得算法，得到最大公约数，然后保存辗转相除法中的式子倒推便可以得到$ax + by = gcd(a,b)$的整数解。那么也就是证明了裴蜀定理，同时也给出了计算线性方程的整数解的方法。<br>关于推导呢？<br>$xa + yb = d$且有$x’b + y’(a \% b) = d$<br>则$x’b + y’(a = \lfloor \frac ab \rfloor b) = d$<br>$y’a + (x’ - y’ \lfloor \frac a b \rfloor) b = d$<br>可得$x = y’, y = x’ - y \lfloor \frac ab \rfloor$<br>推导完毕。。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; X, <span class="keyword">int</span> &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;X = <span class="number">1</span>, Y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line"><span class="keyword">int</span> R = Exgcd(b, a % b, X, Y) ;</span><br><span class="line"><span class="keyword">int</span> E = X ; X = Y ; Y = E - a / b * Y ;</span><br><span class="line"><span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>此算法称为扩展中国剩余定理，而中国剩余定理满足$m_i$之间两两互质，我们先从中国剩余定理说起。<br>还是使用上面的式子，假设方程组有解。那么我们设$M = \prod_{i = 1}^nm_i$，（当然也可以设$M = Lct({m_i})$，效果是一样的）且有n个$M_i = M / m_i$，也就是除了第i个以外其他n-1个$m_i$的乘积。以及$t_i = M_i^{-1}$，则我们知道</p><script type="math/tex; mode=display">t_iM_i \equiv 1 (mod ~ m_i)</script><p>于是有结论：方程组的通解形式为</p><script type="math/tex; mode=display">\sum _{i = 1}^n a_it_iM_i + kM</script><p>以上是通解形式，而通解有无数个，对于每一个解加上$kM$依然是方程组的解，其中$k \in Z$。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>关于证明，因为我们知道<script type="math/tex">t_iM_i \equiv 1 (mod ~ 1)</script><br>所以有</p><script type="math/tex; mode=display">a_it_iM_i \equiv a_i (mod ~ m_i)</script><p>而因为所有的$m_i$之间两两互质，因此对于除了$m_i$之外的所有的$m_j$都有</p><script type="math/tex; mode=display">a_it_iM_i \equiv 0 (mod ~ m_j)</script><p>因此</p><script type="math/tex; mode=display">x = \sum _{i = 1}^ n a_it_iM_i</script><p>满足</p><script type="math/tex; mode=display">x = a_i t_i M_i + \sum _{j ≠ i}a_j t_j+M j \equiv a_i + \sum_{j ≠ i} 0 \equiv a_i (mod ~ m_i)</script><p>因此，$x \equiv a_i (mod ~ m_i)$，所以$x$就是方程的一个特殊解。而至于为什么加上若干个$M$都是解我想就不用我再证明了吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN], m[MAXN], n ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) M *= m[i] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x, y ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M_i = M / m[i] ;</span><br><span class="line">Exgcd(M_i, m[i], x, y) ;</span><br><span class="line">X = (X + M_i * x * a[i]) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (X + M) % M ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p>然后关于扩展中国剩余定理，相较之就是取消掉了$m_i$两两互质这个条件。<br>我们依然假设$M = \sum_{i = 1}^{k - 1} m_i$，那么假设我们已经知道了前$k-1$个式子的方程通解为<br>$x + i \times M$，那么在加入第$i$个方程后的通解，只消求出一个满足</p><script type="math/tex; mode=display">x + t * M \equiv a_k (mod~m_k)</script><p>的$t$就可以。</p><script type="math/tex; mode=display">t \times M \equiv a_k - x~(mod ~ m_k)</script><p>直接欧几里得求解$t$即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[MAXN], B[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Exgcd</span><span class="params">(LL a, LL b, LL &amp; X, LL &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">X = <span class="number">1</span> ; Y = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line">LL R = Exgcd(b, a % b, X, Y), E = X ; </span><br><span class="line">X = Y ; Y = E - a / b * Y ;<span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Quick_Mul</span><span class="params">(LL X, LL Y, LL Mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;<span class="keyword">while</span> (Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = (Ans + X) % Mod ;</span><br><span class="line">X = (X + X) % Mod ; Y &gt;&gt;= <span class="number">1</span>  ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X, Y, M = B[<span class="number">1</span>], Ans = A[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">LL a = M, b = B[i], C = (A[i] - Ans % b + b) % b ;</span><br><span class="line">LL R = Exgcd(a, b, X, Y), E = b / R ;</span><br><span class="line"><span class="keyword">if</span> (C % R != <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span> ;</span><br><span class="line">X = Quick_Mul(X, C / R, E) ; Ans += X * M ;</span><br><span class="line">M = M * E ; Ans = (Ans % M + M) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (Ans % M + M) % M ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line"> B[i] = Read(), A[i] = Read() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, Excrt()) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>培训的时候听$zhx$神仙讲了大骗分法：大数翻倍法。<br>很简单，就是对于最大的$a_i$不断地把它加上$p_i$，然后合法检查就可以了。<br>时间复杂度大概在$O(\sum_i p_i)$到$O(max(p))0$之间，据说是可以用来做题的，但是唯一不能适用的情况就是两组方程，其中$p \in 10^9$。<br>嗯，骗分大法好。</p>]]></content>
    
    <summary type="html">
    
      欧几里得及其扩展算法用于计算最大公约数的有关问题。而扩展中国剩余定理用于计算给定$N$组非负整数$a_i$和$m_i$，求解关于$x$的方程组的最小非负整数解。两者在数论中均是很重要的算法。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="http://Yeasion.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="扩展欧几里得" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="扩展中国剩余定理" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>线性积分与傅里叶变换</title>
    <link href="http://Yeasion.github.io/2019/02/13/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://Yeasion.github.io/2019/02/13/线性积分与傅里叶变换/</id>
    <published>2019-02-13T07:17:33.000Z</published>
    <updated>2019-03-10T00:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章被题目大致分为了两个部分：<strong>线性积分</strong>和 <strong>傅里叶变换</strong>。其实这么分实际上是不甚妥当的，因为傅里叶变换就是<strong>线性积分变换</strong>中的一种。如果要结合题目细讲，写起来怕是一个浩大的工程了，因此讲解的内容大多就仅止步于在信息学奥赛中的应用。当然，博主也会尽力深挖，争取让文章不只是初步。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很多人学快速傅里叶变换，学它的微分关系，学它的卷积特性，但是始终都没有思考过这个玩意是干嘛用的。毕竟本篇文章实际上想要讲的就是傅里叶变换，我们也首先要了解到傅里叶变换的作用是什么。</p><p>从数学上来说，傅里叶变换是用于解决两个多项式的 <strong>卷积</strong>，简单来说就是两个多项式相乘的次数，如果直接暴力计算，那么时间复杂度应该是$O(N^2)$，而快速傅里叶变换可以将时间复杂度降为$O(NlogN)$。这在时间维度上就体现了它宝贵的价值，因为多项式相乘的普遍性，复杂的快速傅里叶变换也渐渐走进人们的视野。</p><p>而从物理学或者工程学中，傅里叶变换的常见用途是 <strong>信号处理</strong>，而所属的<strong>信息与系统</strong>又是大学中大部分工科的基础，足以见其重要性。具体的讲就是 <strong>将给定信号把时间映射到振幅</strong>。而关于时间和频率的有关内容还请参考Heinrich关于傅里叶变换的教程：<a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程</a> ，例如其在讯号处理的经典应用就是将讯号分解为振幅分量和频率分量。</p><h2 id="线性积分变换"><a href="#线性积分变换" class="headerlink" title="线性积分变换"></a>线性积分变换</h2><blockquote><p><strong>积分变换</strong>是数学中作用于函数的<strong>算子</strong>，用以处理<strong>微分方程</strong>等问题。</p></blockquote><p>一个十分生涩的定义，我们假设当前有一个函数$f(x)$，将操作$T$表示为一个积分转换，而$f$经过此积分变换后的函数表示为$Tf(y)$：<script type="math/tex">Tf(y) = \int_{x_1}^{x_2}K(x, y)f(x) dx</script>。</p><p>其中$K()$是一个确定的含有两个参数的函数，称为此次<strong>积分变换</strong>的<strong>核函数</strong>（简称<strong>核</strong>）。而核使我们自己选择的，当我们选择不同的核函数$K()$或者积分域$(x_1,x_2)$就得到了不同的积分变换，这应该是很显然的。而相对应的，积分变换也有相对的<strong>反积分变换</strong>，也就是：<script type="math/tex">f(x) = \int_{y_1}^{y_2}K^{-1}(y, x)Tf(y)dy</script></p><p>其中$K^{-1}(y, x)$被称为<strong>反核</strong>。</p><p>而积分变换与反积分变换构成了<strong>傅里叶变换</strong>的框架，在傅里叶变换中，核函数为$\frac{e^{ixy}}{\sqrt{2 \pi}}$，其积分域为$-\infty, \infty$。</p><p>下面我们会从基础开始一步步地将傅里叶变换拆成我们好理解的东西。</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>我想来到这里的人肯定不需要我再讲这东西了，如果果真有人不会，还请自行维基。为了讲解需要，在此强调几个多项式的概念性内容：</p><blockquote><p>多项式的框架式形式：<script type="math/tex">\sum_{i = 0}^{N - 1}a_ix_i</script></p><p>若其最高次的非零系数为$a_k$，则该多项式的次数为k。</p><p>任何一个严格大于其次数的整数都是这个多项式的次数界。</p></blockquote><p>对于多项式的计算，加法显然很简单。<script type="math/tex">C(x) = A(x) + B(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i = \sum_{i = 1}^{N - 1}c_ix^i</script></p><p>只需要将对应次数的系数相加即可，我们可以在$O(N)$的时间复杂度内得到答案。</p><p>而对于多项式乘法，方法是将$A(x)$中的每一项与$B(x)$中的每一项相乘，之后合并同类项即可。<script type="math/tex">C(x) = \sum_{i = 0}^{2N - 2}c_ix_i</script>其中$c_i = \sum_{j = 0}^ia_jb_i-j$称为两个多项式的<strong>卷积</strong>，表示为$a \otimes b$</p><p>对于一个多项式来说我们有两种表示方法：<strong>系数表示法</strong>和<strong>点值表示法</strong>，其实两种表示方法应该是等价的，但是在计算上来说，对于点值表示的多项式，求解的时间复杂度是$O(N)$，这已经非常优秀，但是系数表示的多项式的暴力求解却是$O(N^2)$，而快速傅里叶变换就可以做到将系数表示的多项式在$O(NlogN)$的时间内求解。</p><p>对于点值表示的多项式求值运算的逆运算（已知点值表示的多项式求系数表示）称为<strong>插值</strong>，关于插值内容还请参照博主的另一篇博客：<a href="https://yeasion.github.io/2019/02/01/%E5%AF%B9%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E8%BF%90%E7%94%A8/">对插值法及拉格朗日插值多项式的初步理解运用</a>。</p><h3 id="单位复数根"><a href="#单位复数根" class="headerlink" title="单位复数根"></a>单位复数根</h3><blockquote><p>N次单位复数根$\omega$满足$\omega ^N = 1$</p></blockquote><p>定义很好理解，但是这一部分作为前置知识的内容实际上算是难点了。下图表示了$n$个单位复数根均匀的分布在以复平面的原点为圆心的单位半径的圆上。</p><p><img src="https://pic.superbed.cn/item/5c63f23f5f3e509ed958a959" alt="pic_Danweifushugen"></p><p>而这究竟是怎么理解呢？Heinrich的教程很形象的做了解释：</p><p>我们假设有一条长度为1的线段在一条数轴上，那么乘以-1之后的线段就与其相反，而$i = \sqrt{-1}$，那么我们将其乘以i的线段就在一个垂直的虚数轴上，于是我们就得到了一个由一个实数轴做x轴，一个虚数轴做y轴的<strong>复平面</strong>。</p><p>然后这里就可以引入另一个重要的公式：<strong>欧拉公式</strong>：$e^{ix} = cosx + i sinx$。运用这个式子我们就得到了上图的8次单位复数根，并且也知道<strong>n次单位复数根一共有n个</strong>。而这些单位根就是$e^{\frac{2 \pi i k}{n}}$我们把n次单位根的第m个写作$\omega_n^m$。</p><p>下面是单位复数根的几个性质或推论：</p><blockquote><ol><li>$\omega _{d \times n}^{d \times m} = \omega _n^m$，其中$d &gt; 0$</li><li>对于任何偶数$n&gt;0$有$\omega _n^{n/2} = \omega_2 = -1$ </li><li>对于偶数$n&gt;0$，n个n次单位复数根的平方的集合就是$\frac n2$个$\frac n2$次单位复数根的集合。</li><li>对于任意$n \geq1$ 和不能被n整除的非负整数k，有$\sum_{i = 0}^{N - 1}(\omega_n^m)^i = 0$</li></ol></blockquote><p>至于具体的证明就不再说了，都是很简单的推论，博友们大可自行脑补，权当是练习了。</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>好了铺垫完所有的前置知识之后我们终于开始了傅里叶变换的内容。对于一个次数界为n的多项式$F(x) = \sum_{i = 1} ^{n - 1}a_ix^i$，我们在插值方面的知识可以知道n个点就可以确定这个多项式，那么我们同样也可以代入n次的n个单位复数根，来确定这个多项式，可以    求出其结果<script type="math/tex">k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}</script>。</p><p>而$y​$就被称为是系数向量a的<strong>离散傅里叶变换</strong>。</p><p>这个东西计算的时间复杂度依然是$O(N^2)$，那它到底有什么用处呢？这在算法上或许无法体现，但是它是傅里叶变换在时域和频域上都呈现离散的形式，具体依然可以参考Heinrich的讲解，使其在频谱分析和数据压缩等领域发挥了巨大优势。</p><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>也就是常说的<strong>FFT</strong>，可以说是对于DFT（离散傅里叶变换）在时间复杂度上的一大改进。</p><p>设多项式$F(x)$的系数向量$a(a_0, a_1, a_2…a_{n - 1})$，对于多项式$F(x) = \sum_{i = 0} ^ {n - 1}a_ix_i$来说，可以按照下标的奇偶性分为两个部分：</p><script type="math/tex; mode=display">F(x) = (a_0 + a_2x^2 +...+ a_{n - 2}x^{n - 2}) + (a_1 + a_3x^3...a_{n - 1}x^{n - 1})</script><p>我们设</p><script type="math/tex; mode=display">F_1(x) = a_0 + a_2x + a_4x^+...+ a_{n - 2}x^{\frac n2 - 1}</script><script type="math/tex; mode=display">F_2(x) = a_1 + a_3x + a_5x^+...+ a_{n - 1}x^{\frac n2 - 1}</script><p>则</p><script type="math/tex; mode=display">F(x) = F_1(x^2) + xF_2(x^2)</script><p>和离散傅里叶变换一样，我们把$\omega _n^k$代入得到</p><script type="math/tex; mode=display">F(\omega _n^k) = F_1(\omega _n^{2k}) + \omega _n^kF_2(\omega _n^{2k})</script><p>然后同理，将$\omega _n^{k + \frac n2}$代入可以得到：</p><script type="math/tex; mode=display">F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k + n}) - F(\omega _n^kF_2(F(\omega _n^{2k} \times \omega_n^n)</script><p>最后得到</p><script type="math/tex; mode=display">F(F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k}) - \omega _n^kF_2(\omega _n^{2k})</script><p>如此我们发现，两个式子化简后，只有一个常数项相反，其他都相同，于是再计算出第一个式子的时候我们可以$O(1)$求出第二个式子，并且发现两个式子将最初的范围缩小了一半，于是原问题缩小了一般，然后我们发现子问题也满足原问题性质，$k$与$k +\frac n2$同时取遍了(0, n - 1)，于是时间复杂度缩小到$O(NlogN)$。</p><p>这个算法在FFT的计算中最为常见，是在1965年由<strong>J.W.Cooley</strong>和<strong>J.W.Tuky</strong>提出的，因此也被称为<strong>Cooley-Tukey算法</strong>，实际上是基于分治的思想实现的，</p><h3 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h3><p>也称为傅里叶反变换，上文我们在线性积分变换中提到过反积分变换，而<strong>傅里叶反变换</strong>就是傅里叶变换的<strong>反积分变换</strong>，在数学中的意义是点值表示的多项式转化为系数表示，也就是说我们要从点值向量$(a_0, a_1, a_2…a_{n - 1})$得到系数向量$(y_0, y_1, y_2…y_{n - 1})$。则我们可以设$(y_0, y_1, y_2…y_{n - 1})$是$(a_0, a_1, a_2…a_{n - 1})$进行傅里叶逆变换后的结果，并<br>设有多项式$F(x) = \sum_{i = 0} ^{n - 1}y_0x^i$，<br>假设有向量$(c_0, c_1, c_2…c_{n - 1})$表示多项式在$\omega_n^0, \omega_n^{-1}…\omega_n^{1 - n}$上的点值表示，则向量c满足</p><script type="math/tex; mode=display">c_k = \sum_{i = 0} ^{n - 1}y_i(\omega_n^{-k})^i</script><p>然后我们考虑将式子展开。</p><script type="math/tex; mode=display">c_k = \sum_{i = 0} ^ {n - 1}y_i(\omega _n^{-k}) ^ i</script><script type="math/tex; mode=display">= \sum_{i = 0} ^ {n - 1}(\sum_{j = 0} ^ {n - 1}a_j(\omega _n^{j} k) ^ j)(\omega_n^{-k})^i</script><script type="math/tex; mode=display">= \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i ~=~ \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)</script><script type="math/tex; mode=display">= \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1}a_j(\omega_n^{j - k})^i ~=~ \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)</script><p>设一个式子</p><script type="math/tex; mode=display">S(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^i</script><p>在两边同时乘一个$\omega_n^k$得：</p><script type="math/tex; mode=display">\omega_n^kS(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^{(i+1)}</script><p>将前后两个式子相减，得到</p><script type="math/tex; mode=display">\omega _n^kS(\omega_n^k) - S(\omega _n^k) = (\omega_n^k)^n - 1</script><script type="math/tex; mode=display">S(\omega _n^k) = \frac {(\omega_n^k)^n - 1}{\omega_n^k - 1}= 0</script><p>则当$k = 0$的时候，其值为0</p><p>而原来的式子</p><script type="math/tex; mode=display">c_k = \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0} ^ {j - k})^i = \sum_{j = 0} ^ {n-1}a_jS(\omega_n^{j - k})</script><p>当$j = k$的时候$S = n$，否则$S = 0$，所以<script type="math/tex">a_i = \frac 1n c_i</script></p><p>这样我们得到了点值和系数的关系式，所以，从结论来说，将单位根幂上-1，然后做一次快速傅里叶变换，将结果的数除以n就是傅里叶逆变换的结果。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>一般的分治都会采用递归操作实现，但是在FFT中递归实现的效率比较低，所以大多数情况下采用迭代操作实现。我们观察二进制下的序列规律<br><img src="https://pic.superbed.cn/item/5c6522ae5f3e509ed96baca2" alt="pic"><br>发现分治到边界条件的时候每个数的下标等于原下标的二进制翻转，于是我们省去了分奇偶的操作，直接枚举每一个二进制位，然后向上合并就可以了。下面是迭代操作实现的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span> ; <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; l) &lt; N) l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"> <span class="keyword">int</span> T = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; l ; j ++)</span><br><span class="line"> <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) T /= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>)) ;</span><br><span class="line"> <span class="keyword">if</span> (i &lt; t) swap(a[i], a[T]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>我们把$\omega_n^k$称为<strong>旋转因子</strong>并保留下来，进入两个向量$a_k^0$和$a_k^1$时，旋转因子$\omega_n^k$乘以$a_k^1$，输出与$a_k^0$的和与差，这一个操作被称为<strong>蝴蝶操作</strong>。那这个东西究竟有什么作用呢？</p><p>重新考虑我们向上合并两个子问题时，假设有$A_1(\omega_{n/2}^k)$储存在$a(k)$中，$A_2(\omega _{n/2}^k)$储存在$a(k +\frac n2)$中，并且这两个值将要被储存在$b(k)$和$b(k + \frac n2)$中，则合并的操作可以如下表示：</p><script type="math/tex; mode=display">b(k) ← a(k) + a(k +\frac n2) \times\omega_n^k</script><script type="math/tex; mode=display">b(k +\frac n2) ← a(k) - a(k +\frac n2) \times\omega_n^k</script><p>于是我们考虑将两个值存放在原来的a中，取消b数组的存在，但是需要覆盖原来的值，所以就需要一个临时变量T。</p><script type="math/tex; mode=display">T ←a(k +\frac n2) \times\omega_n^k</script><script type="math/tex; mode=display">a(k +\frac n2) ← a(k) - T</script><script type="math/tex; mode=display">a(k) ← a(k) - T</script><p>名字很好听，其实操作很简单，仅仅有一行而已。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, l, r[MAXN], L = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    <span class="keyword">complex</span> (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;x = xx, y = yy ;&#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x + b.x , a.y + b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x - b.x , a.y - b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x * b.x - a.y * b.y , a.x * b.y + a.y * b.x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> *A, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++) <span class="keyword">if</span> (i &lt; r[i]) swap(A[i], A[r[i]]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span> ; Mid &lt; L ; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">W</span><span class="params">(<span class="built_in">cos</span>(Pi / Mid), type * <span class="built_in">sin</span>(Pi / Mid))</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = Mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; L ; j += R) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; Mid ;k ++, w = w * W) &#123;</span><br><span class="line">    <span class="keyword">complex</span> x = A[j + k], y = w * A[j + Mid + k] ;</span><br><span class="line">    A[j + k] = x + y ; A[j + Mid + k] = x - y ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = Read(), M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; i ++) a[i].x = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i ++) b[i].x = Read() ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= N + M) L &lt;&lt;= <span class="number">1</span>, l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++)</span><br><span class="line">r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">FFT (a, <span class="number">1</span>) ; FFT (b, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; i ++) a[i] = a[i] * b[i] ; </span><br><span class="line">    FFT(a, - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N + M ; i ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(a[i].x/ L + <span class="number">0.5</span>)) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h5 id="同济高等数学，"><a href="#同济高等数学，" class="headerlink" title="同济高等数学，"></a>同济高等数学，</h5><h5 id="Thomas-H-Cormen算法导论，"><a href="#Thomas-H-Cormen算法导论，" class="headerlink" title="Thomas H.Cormen算法导论，"></a>Thomas H.Cormen算法导论，</h5><h5 id="Miskcoo-从多项式乘法到快速傅里叶变换，"><a href="#Miskcoo-从多项式乘法到快速傅里叶变换，" class="headerlink" title="Miskcoo 从多项式乘法到快速傅里叶变换，"></a><a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-10" target="_blank" rel="noopener">Miskcoo 从多项式乘法到快速傅里叶变换</a>，</h5><h5 id="郭晓旭-FFT讲义，"><a href="#郭晓旭-FFT讲义，" class="headerlink" title="郭晓旭 FFT讲义，"></a><a href="https://pan.baidu.com/wap/album/file?uk=3325080974&amp;album_id=2474841267539644259&amp;fsid=845742707277510&amp;adapt=pc&amp;fr=ftw" target="_blank" rel="noopener">郭晓旭 FFT讲义</a>，</h5><h5 id="维基百科-傅里叶变换，"><a href="#维基百科-傅里叶变换，" class="headerlink" title="维基百科 傅里叶变换，"></a><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">维基百科 傅里叶变换</a>，</h5><h5 id="白霂凡-Fast-Fourier-Transform，"><a href="#白霂凡-Fast-Fourier-Transform，" class="headerlink" title="白霂凡 Fast Fourier Transform，"></a><a href="https://zhuanlan.zhihu.com/p/31584464" target="_blank" rel="noopener">白霂凡 Fast Fourier Transform</a>，</h5><h5 id="Menci-FFT学习笔记，"><a href="#Menci-FFT学习笔记，" class="headerlink" title="Menci FFT学习笔记，"></a><a href="https://oi.men.ci/fft-notes/" target="_blank" rel="noopener">Menci FFT学习笔记</a>，</h5><h5 id="Heinrich-傅里叶分析之掐死教程，"><a href="#Heinrich-傅里叶分析之掐死教程，" class="headerlink" title="Heinrich 傅里叶分析之掐死教程，"></a><a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">Heinrich 傅里叶分析之掐死教程</a>，</h5><h5 id="attack-快速傅里叶变换-FFT-详解"><a href="#attack-快速傅里叶变换-FFT-详解" class="headerlink" title="attack 快速傅里叶变换(FFT)详解"></a><a href="http://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">attack 快速傅里叶变换(FFT)详解</a></h5>]]></content>
    
    <summary type="html">
    
      $$k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}$$ $$C(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i$$ 如何快速求两个多项式的卷积以及线性积分变换的基本内容。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="傅里叶变换" scheme="http://Yeasion.github.io/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="线性积分变换" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2015]约数个数和</title>
    <link href="http://Yeasion.github.io/2019/02/13/SDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
    <id>http://Yeasion.github.io/2019/02/13/SDOI2015-约数个数和/</id>
    <published>2019-02-13T02:55:53.000Z</published>
    <updated>2019-03-09T13:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，设$d(x)$表示$x$的约数个数，求<script type="math/tex">\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)</script><br>首先要知道约数个数的一种表示方法：<script type="math/tex">d(i,j) = \sum_{x|i} \sum_{y_j}[gcd(x,y) == 1]</script><br>然后题目所求就变成了</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j = 1}^M \sum_{k | i} \sum_{l | j}[gcd(k,l) == 1]</script><p>化简，改变量之后式子变为</p><script type="math/tex; mode=display">\sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == 1)(\frac Mi)(\frac Mj)</script><p>考虑莫比乌斯反演,设</p><script type="math/tex; mode=display">f(X) = \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == x)(\frac Ni)(\frac Mj)</script><script type="math/tex; mode=display">F(x) = \sum_{x|n}f(n)</script><script type="math/tex; mode=display">→ F(x) = \sum_{i = }^N \sum_{j = 1}^{N / x}(x|gcd())(\frac Ni)(\frac Mj)</script><script type="math/tex; mode=display">→ F(x) = \sum_{i = }^N \sum_{j = 1}^{M / x}(\frac {N}{ix})(\frac {M}{jx})</script><p>考虑优化算法时间复杂度，可以预处理出$\sum_{i = 1}^N(\frac Ni)$和$\sum_{j = 1}^M (\frac Mj)$，连带着莫比乌斯函数可以直接O(N)预处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题答案化简为$f(1)$。反演后得到<script type="math/tex">f(1) = \sum{x = 1}^N \mu (x) F(x)</script></p><script type="math/tex; mode=display">= \sum_{x = 1}^N \mu(x) \sum_{i = 1}^{N/x} \sum _{j = 1}^{M / x} (\frac Ni) (\frac Mj)</script><p>进行数论分块就可以了，总体时间复杂度$O(T\sqrt N)$，其中T为数据组数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, U[MAXN], P[MAXN], Tot ;</span><br><span class="line"><span class="keyword">int</span> S[MAXN], Sum[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN] ;<span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T = Read() ; Init () ;</span><br><span class="line"><span class="keyword">while</span> (T --) &#123;Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= min(N, M) ; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(N / (N / l), M / (M / l)) ;</span><br><span class="line">Ans += <span class="number">1l</span>l * (S[r] - S[l - <span class="number">1</span>]) * Sum[N / l] * Sum[M / l] ;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设$d(x)$为$x$的约数个数，给定$N$，$M$，求$$\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)$$
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="数论 莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演初步与实际应用</title>
    <link href="http://Yeasion.github.io/2019/02/02/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%88%9D%E6%AD%A5%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/02/02/莫比乌斯反演初步和实际应用/</id>
    <published>2019-02-02T01:48:43.000Z</published>
    <updated>2019-03-10T00:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫比乌斯反演初步和实际应用"><a href="#莫比乌斯反演初步和实际应用" class="headerlink" title="莫比乌斯反演初步和实际应用"></a>莫比乌斯反演初步和实际应用</h1><h3 id="定义和一般形式及其证明"><a href="#定义和一般形式及其证明" class="headerlink" title="定义和一般形式及其证明"></a>定义和一般形式及其证明</h3><blockquote><p>假设有数论函数关系式$F(N) = \sum_{x|N}f(x)$，则有$f(N) = \sum_{x|N}\mu(x)F(\frac Nx) = \sum_{x|N}\mu(\frac xN)F(x)$</p></blockquote><p>此为基本定义，但是看到这个函数也有限制就是必须是数论函数。，也就是定义域为正整数，对应集合为复数的函数。下面是函数的一般形式。</p><blockquote><p>假设d定义在$[1,∞)$上的复值函数$G(N) = \sum_{x = 1}^NF(\frac Nx)$，则有$F(N) = \sum_{x = 1}^N\mu(x)G(\frac Nx)$</p></blockquote><p>而这个$\mu(x)$函数就是莫比乌斯函数，其定义如下：</p><blockquote><p>$x= 1$时，$\mu(x) = 1$。</p><p>$x = P_1P_2…P_M$，（$P$为互异素数），则$\mu(x) = (-1)^M$</p><p>其他情况下$\mu(x) = 0$</p></blockquote><p>由定义可以得到莫比乌斯函数的两个重要性质：</p><blockquote><p><img src="https://img-blog.csdn.net/20140416161656796" alt="pic"></p><p>对任意<strong>正整数</strong>$N$有$\sum_{x|N}\frac{\mu(x)}{x} = \frac{\varphi(N)}{N}$</p></blockquote><p><strong>证明 :</strong></p><p>设有</p><script type="math/tex; mode=display">\sum_{x|N}\mu(x) = [N = 1], f(N) = \sum_{x|N}[\frac Nx = 1]f(x)</script><p>代入得</p><script type="math/tex; mode=display">f(N) = \sum_{x|N}\sum_{y|\frac Nx}\mu(y)f(x)</script><p>由于$\sum_{x|N}\sum_{y|\frac Nx}$的限制条件为$xy|N$，所以等式写成:</p><script type="math/tex; mode=display">f(N) = \sum_{y|N}\mu(y)\sum_{x|\frac Ny}f(x) = \sum_{y|N}\mu(y)F(\frac Ny)</script><p>证明完毕。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用线性筛法求莫比乌斯函数，时间复杂度$O(N)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[++ Tot] = i, Mu[i] = - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= Tot &amp;&amp; P[j] &lt; N ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i] ;</span><br><span class="line"><span class="keyword">else</span> &#123;Mu[i * P[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：YY的GCD"><a href="#例题：YY的GCD" class="headerlink" title="例题：YY的GCD"></a>例题：YY的GCD</h3><blockquote><p>给定$N, M$，求所有的$X \leq N,~Y \leq M$中$gcd(X, Y)$是质数的点对有多少对。</p></blockquote><p>类似于一个模板题，因为其思维难度不是很大。考虑公式化题目描述，即求：<script type="math/tex">\sum_{X = 1}^N \sum_{Y = 1}^M [gcd(i,j) == P]</script></p><p>设$f(x)​$为满足$gcd(X, Y) = X​$的$(X, Y)​$的对数，$F(X)​$为满足$X|gcd(X, Y)​$二点$(X, Y)​$的对数。得到</p><script type="math/tex; mode=display">F(N) = \sum_{x|N}f(x)​</script><p>所以根据莫比乌斯反演定理，得​</p><script type="math/tex; mode=display">f(N) = \sum_{x|N}\mu(\frac xN)F(x) =\sum_{x|N}\mu(\frac xN)\frac{N \times M}{X^2}​</script><p>而题目要求其$gcd(X,Y)$是一个质数也就是说</p><script type="math/tex; mode=display">Ans = \sum_P^{min(N, M} \sum_i^N\sum_j^M[gcd(i,j) = P] = \sum_P^{Minn(N,M)}f(P)</script><p>设$T = PX$，则式子变为</p><script type="math/tex; mode=display">\sum_{T = 1}^{Min(N,M)}\frac{N \times M}{T^2}(\sum_{G|T}\mu(\frac TG))</script><p>于是为了提高速度，可以预处理$\sum_{G|T}\mu(\frac TG)$。于是此题就以较快得速度解决了。</p><p>但是如果是多组数据还是有可能会$TLE$，所以如果想要更快，还可以使用整除分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T, N, M, V[MAXN], P[MAXN], Mu[MAXN], Tot ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S[MAXN], Ans, G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[Tot ++] = i, Mu[i] = - <span class="number">1</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i],</span><br><span class="line">G[i * P[j]] = Mu[i] - G[i] ; <span class="keyword">else</span> &#123;</span><br><span class="line">Mu[i * P[j]] = <span class="number">0</span> ; G[i * P[j]] = Mu[i] ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i ++) S[i] = S[i - <span class="number">1</span>] + G[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MU() ;</span><br><span class="line">T = Read() ; <span class="keyword">while</span> (T --) &#123; </span><br><span class="line">Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read(), M = Read() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= min(N, M) ; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">j = min(N / (N / i), M / (M / i)) ;</span><br><span class="line">Ans += (N / i) * (M / i) * (S[j] - S[i - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      $$F(N) = \sum_{x|N}f(x)$$ $$f(N) = \sum_{x|N}\mu(x)F(\frac Nx)$$ 在数论中占有重要地位的莫比乌斯反演，可以大大简化运算。本文初步探析莫比乌斯函数的定义，证明和代码实现。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
</feed>
