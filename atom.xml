<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏·浅</title>
  
  <subtitle>Sue Shallow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Yeasion.github.io/"/>
  <updated>2019-02-15T11:05:50.368Z</updated>
  <id>http://Yeasion.github.io/</id>
  
  <author>
    <name>Sue Shallow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欧几里得与扩展中国剩余定理ExCrt</title>
    <link href="http://Yeasion.github.io/2019/02/15/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt/"/>
    <id>http://Yeasion.github.io/2019/02/15/扩展中国剩余定理ExCrt/</id>
    <published>2019-02-15T07:27:39.000Z</published>
    <updated>2019-02-15T11:05:50.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>为什么要放欧几里得算法，因为这个玩意是扩展欧几里得的铺垫，为什么要将扩展欧几里得，因为这个玩意是中国剩余定理的铺垫。<br>很简单，就是要我们求$gcd(i,j)$。由于证明过程十分繁琐并且没有什么很大的意义，所以便不多管闲事地证明了，结论也很简单：$gcd(i,j) = gcd(j, i % j)$。于是可以不断递归，直到j变成0，然后返回i就可以了，很常见的方法，直接放代码了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X ;</span><br><span class="line"><span class="keyword">return</span> Gcd(Y, X % Y) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>裴蜀定理是扩展欧几里得算法的第二个铺垫，也是一个关于最大公约数的定理。<br>假设有一个线性方程$ax + by = c$，问这个方程有没有整数解，那么根据裴蜀定理我们就知道当$gcd(a,b) | c$的时候线性方程才可能有整数解。简单的证明就是$gcd(a,b)$显然$|(ax+by)$。对于$gcd(a,b)|c$的情况有没有整数解我们便需要用到扩展欧几里得。</p><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>对于$$ax + by = gcd(a,b)$$，当$a &lt; 0$的时候，式子就可以变成<br>$$|a| (-x) + by = gcd(|a|, b)$$,可以知道这个式子必然是有整数解的。我们可以对于$(a,b)$进行欧几里得算法，得到最大公约数，然后保存辗转相除法中的式子倒推便可以得到$ax + by = gcd(a,b)$的整数解。那么也就是证明了裴蜀定理，同时也给出了计算线性方程的整数解的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; X, <span class="keyword">int</span> &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;X = <span class="number">1</span>, Y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line"><span class="keyword">int</span> R = Exgcd(b, a % b, X, Y) ;</span><br><span class="line"><span class="keyword">int</span> E = X ; X = Y ; Y = E - a / b * Y ;</span><br><span class="line"><span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>此算法称为扩展中国剩余定理，而中国剩余定理满足$m_i$之间两两互质，我们先从中国剩余定理说起。<br>还是使用上面的式子，假设方程组有解。那么我们设$M = \prod_{i = 1}^nm_i$，（当然也可以设$M = Lct({m_i})$，效果是一样的）且有n个$M_i = M / m_i$，也就是除了第i个以外其他n-1个$m_i$的乘积。以及$t_i = M_i^{-1}$，则我们知道<br>$$t_iM_i \equiv 1 (mod ~ m_i)$$<br>于是有结论：方程组的通解形式为$$\sum _{i = 1}^n a_it_iM_i + kM$$<br>以上是通解形式，而通解有无数个，对于每一个解加上$kM$依然是方程组的解，其中$k \in Z$。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>关于证明，因为我们知道$$t_iM_i \equiv 1 (mod ~ 1)$$<br>所以有$$a_it_iM_i \equiv a_i (mod ~ m_i)$$<br>而因为所有的$m_i$之间两两互质，因此对于除了$m_i$之外的所有的$m_j$都有$$a_it_iM_i \equiv 0 (mod ~ m_j)$$<br>因此$$x = \sum _{i = 1}^ n a_it_iM_i$$满足$$x = a_it_iM_i + \sum _{j ≠ i}a_jt_j_+Mj \equiv a_i + \sum_{j ≠ i} 0 \equiv a_i (mid ~ m_i)$$<br>因此，$x \equiv a_i (mod ~ m_i)$，所以$x$就是方程的一个特殊解。而至于为什么加上若干个$M$都是解我想就不用我再证明了吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN], m[MAXN], n ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) M *= m[i] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x, y ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M_i = M / m[i] ;</span><br><span class="line">Exgcd(M_i, m[i], x, y) ;</span><br><span class="line">X = (X + M_i * x * a[i]) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (X + M) % M ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p>然后关于扩展中国剩余定理，相较之就是取消掉了$m_i$两两互质这个条件。<br>我们依然假设$M = \sum_{i = 1}^{k - 1} m_i$，那么假设我们已经知道了前$k-1$个式子的方程通解为$x + i <em> M$，那么在加入第i个方程后的通解，只消求出一个满足$x + t </em> M \equiv a_k (mod~m_k)$的$t$就可以。<br>$$t \times M \equiv a_k - x~(mod ~ m_k)$$<br>直接欧几里得求解$t$即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[MAXN], B[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Exgcd</span><span class="params">(LL a, LL b, LL &amp; X, LL &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">X = <span class="number">1</span> ; Y = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line">LL R = Exgcd(b, a % b, X, Y), E = X ; </span><br><span class="line">X = Y ; Y = E - a / b * Y ;<span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Quick_Mul</span><span class="params">(LL X, LL Y, LL Mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;<span class="keyword">while</span> (Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = (Ans + X) % Mod ;</span><br><span class="line">X = (X + X) % Mod ; Y &gt;&gt;= <span class="number">1</span>  ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X, Y, M = B[<span class="number">1</span>], Ans = A[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">LL a = M, b = B[i], C = (A[i] - Ans % b + b) % b ;</span><br><span class="line">LL R = Exgcd(a, b, X, Y), E = b / R ;</span><br><span class="line"><span class="keyword">if</span> (C % R != <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span> ;</span><br><span class="line">X = Quick_Mul(X, C / R, E) ; Ans += X * M ;</span><br><span class="line">M = M * E ; Ans = (Ans % M + M) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (Ans % M + M) % M ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line"> B[i] = Read(), A[i] = Read() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, Excrt()) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给定$N$组非负整数$a_i$和$m_i$，求解关于$x$的方程组的最小非负整数解。
    
    </summary>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="http://Yeasion.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="扩展欧几里得" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="扩展中国剩余定理" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>线性积分与傅里叶变换</title>
    <link href="http://Yeasion.github.io/2019/02/13/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://Yeasion.github.io/2019/02/13/线性积分与傅里叶变换/</id>
    <published>2019-02-13T07:17:33.000Z</published>
    <updated>2019-02-14T10:32:35.169Z</updated>
    
    <content type="html"><![CDATA[<p>文章被题目大致分为了两个部分：<strong>线性积分</strong>和<strong>傅里叶变换</strong>。其实这么分实际上是不甚妥当的，因为傅里叶变换就是<strong>线性积分变换</strong>中的一种。如果要结合题目细讲，写起来怕是一个浩大的工程了，因此讲解的内容大多就仅止步于在信息学奥赛中的应用。当然，博主也会尽力深挖，争取让文章不只是初步。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很多人学快速傅里叶变换，学它的微分关系，学它的卷积特性，但是始终都没有思考过这个玩意是干嘛用的。毕竟本篇文章实际上想要讲的就是傅里叶变换，我们也首先要了解到傅里叶变换的作用是什么。</p><p>从数学上来说，傅里叶变换是用于解决两个多项式的<strong>卷积</strong>，简单来说就是两个多项式相乘的次数，如果直接暴力计算，那么时间复杂度应该是$O(N^2)$，而快速傅里叶变换可以将时间复杂度降为$O(NlogN)$。这在时间维度上就体现了它宝贵的价值，因为多项式相乘的普遍性，复杂的快速傅里叶变换也渐渐走进人们的视野。</p><p>而从物理学或者工程学中，傅里叶变换的常见用途是<strong>信号处理</strong>，而所属的<strong>信息与系统</strong>又是大学中大部分工科的基础，足以见其重要性。具体的讲就是<strong>将给定信号把时间映射到振幅</strong>。而关于时间和频率的有关内容还请参考Heinrich关于傅里叶变换的教程：<a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程</a> ，例如其在讯号处理的经典应用就是将讯号分解为振幅分量和频率分量。</p><h2 id="线性积分变换"><a href="#线性积分变换" class="headerlink" title="线性积分变换"></a>线性积分变换</h2><blockquote><p><strong>积分变换</strong>是数学中作用于函数的<strong>算子</strong>，用以处理<strong>微分方程</strong>等问题。</p></blockquote><p>一个十分生涩的定义，我们假设当前有一个函数$f(x)$，将操作$T$表示为一个积分转换，而$f$经过此积分变换后的函数表示为$Tf(y)$：$$Tf(y) = \int_{x_1}^{x_2}K(x, y)f(x) dx$$。</p><p>其中$K()$是一个确定的含有两个参数的函数，称为此次<strong>积分变换</strong>的<strong>核函数</strong>（简称<strong>核</strong>）。而核使我们自己选择的，当我们选择不同的核函数$K()$或者积分域$(x_1,x_2)$就得到了不同的积分变换，这应该是很显然的。而相对应的，积分变换也有相对的<strong>反积分变换</strong>，也就是：$$f(x) = \int_{y_1}^{y_2}K^{-1}(y, x)Tf(y)dy$$</p><p>其中$K^{-1}(y, x)$被称为<strong>反核</strong>。</p><p>而积分变换与反积分变换构成了<strong>傅里叶变换</strong>的框架，在傅里叶变换中，核函数为$\frac{e^{ixy}}{\sqrt{2 \pi}}$，其积分域为$-\infty, \infty$。</p><p>下面我们会从基础开始一步步地将傅里叶变换拆成我们好理解的东西。</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>我想来到这里的人肯定不需要我再讲这东西了，如果果真有人不会，还请自行维基。为了讲解需要，在此强调几个多项式的概念性内容：</p><blockquote><p>多项式的框架式形式：$$\sum_{i = 0}^{N - 1}a_ix_i$$</p><p>若其最高次的非零系数为$a_k$，则该多项式的次数为k。</p><p>任何一个严格大于其次数的整数都是这个多项式的次数界。</p></blockquote><p>对于多项式的计算，加法显然很简单。$$C(x) = A(x) + B(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i = \sum_{i = 1}^{N - 1}c_ix^i$$</p><p>只需要将对应次数的系数相加即可，我们可以在$O(N)$的时间复杂度内得到答案。</p><p>而对于多项式乘法，方法是将$A(x)$中的每一项与$B(x)$中的每一项相乘，之后合并同类项即可。$$C(x) = \sum_{i = 0}^{2N - 2}c_ix_i$$其中$c_i = \sum_{j = 0}^ia_jb_i-j$称为两个多项式的<strong>卷积</strong>，表示为$a \otimes b$</p><p>对于一个多项式来说我们有两种表示方法：<strong>系数表示法</strong>和<strong>点值表示法</strong>，其实两种表示方法应该是等价的，但是在计算上来说，对于点值表示的多项式，求解的时间复杂度是$O(N)$，这已经非常优秀，但是系数表示的多项式的暴力求解却是$O(N^2)$，而快速傅里叶变换就可以做到将系数表示的多项式在$O(NlogN)$的时间内求解。</p><p>对于点值表示的多项式求值运算的逆运算（已知点值表示的多项式求系数表示）称为<strong>插值</strong>，关于插值内容还请参照博主的另一篇博客：<a href="https://yeasion.github.io/2019/02/01/%E5%AF%B9%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E8%BF%90%E7%94%A8/">对插值法及拉格朗日插值多项式的初步理解运用</a>。</p><h3 id="单位复数根"><a href="#单位复数根" class="headerlink" title="单位复数根"></a>单位复数根</h3><blockquote><p>N次单位复数根$\omega$满足$\omega ^N = 1$</p></blockquote><p>定义很好理解，但是这一部分作为前置知识的内容实际上算是难点了。下图表示了$n$个单位复数根均匀的分布在以复平面的原点为圆心的单位半径的圆上。</p><p><img src="https://pic.superbed.cn/item/5c63f23f5f3e509ed958a959" alt="pic_Danweifushugen"></p><p>而这究竟是怎么理解呢？Heinrich的教程很形象的做了解释：</p><p>我们假设有一条长度为1的线段在一条数轴上，那么乘以-1之后的线段就与其相反，而$i = \sqrt{-1}$，那么我们将其乘以i的线段就在一个垂直的虚数轴上，于是我们就得到了一个由一个实数轴做x轴，一个虚数轴做y轴的<strong>复平面</strong>。</p><p>然后这里就可以引入另一个重要的公式：<strong>欧拉公式</strong>：$e^{ix} = cosx + i sinx$。运用这个式子我们就得到了上图的8次单位复数根，并且也知道<strong>n次单位复数根一共有n个</strong>。而这些单位根就是$e^{\frac{2 \pi i k}{n}}$我们把n次单位根的第m个写作$\omega_n^m$。</p><p>下面是单位复数根的几个性质或推论：</p><blockquote><ol><li>$\omega _{d \times n}^{d \times m} = \omega _n^m$，其中$d &gt; 0$</li><li>对于任何偶数$n&gt;0$有$\omega _n^{n/2} = \omega_2 = -1$ </li><li>对于偶数$n&gt;0$，n个n次单位复数根的平方的集合就是$\frac n2$个$\frac n2$次单位复数根的集合。</li><li>对于任意$n \geq1$ 和不能被n整除的非负整数k，有$\sum_{i = 0}^{N - 1}(\omega_n^m)^i = 0$</li></ol></blockquote><p>至于具体的证明就不再说了，都是很简单的推论，博友们大可自行脑补，权当是练习了。</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>好了铺垫完所有的前置知识之后我们终于开始了傅里叶变换的内容。对于一个次数界为n的多项式$F(x) = \sum_{i = 1} ^{n - 1}a_ix^i$，我们在插值方面的知识可以知道n个点就可以确定这个多项式，那么我们同样也可以代入n次的n个单位复数根，来确定这个多项式，可以    求出其结果$$k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}$$。</p><p>而$y​$就被称为是系数向量a的<strong>离散傅里叶变换</strong>。</p><p>这个东西计算的时间复杂度依然是$O(N^2)$，那它到底有什么用处呢？这在算法上或许无法体现，但是它是傅里叶变换在时域和频域上都呈现离散的形式，具体依然可以参考Heinrich的讲解，使其在频谱分析和数据压缩等领域发挥了巨大优势。</p><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>也就是常说的<strong>FFT</strong>，可以说是对于DFT（离散傅里叶变换）在时间复杂度上的一大改进。</p><p>设多项式$F(x)$的系数向量$a(a_0, a_1, a_2…a_{n - 1})$，对于多项式$F(x) = \sum_{i = 0} ^ {n - 1}a_ix_i$来说，可以按照下标的奇偶性分为两个部分：<br>$$F(x) = (a_0 + a_2x^2 +…+ a_{n - 2}x^{n - 2}) + (a_1 + a_3x^3…a_{n - 1}x^{n - 1})$$<br>我们设$$F_1(x) = a_0 + a_2x + a_4x^+…+ a_{n - 2}x^{\frac n2 - 1}$$<br>$$F_1(x) = a_1 + a_3x + a_5x^+…+ a_{n - 1}x^{\frac n2 - 1}$$<br>则$F(x) = F_1(x^2) + xF_2(x^2)$<br>和离散傅里叶变换一样，我们把$\omega _n^k$代入得到$$F(\omega _n^k) = F_1(\omega _n^{2k}) + \omega _n^kF_2(\omega _n^{2k})$$<br>然后同理，将$\omega _n^{k + \frac n2}$代入可以得到：$F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k + n}) - F(\omega _n^kF_2(F(\omega _n^{2k} \times \omega_n^n)$<br>最后得到$$F(F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k}) - \omega _n^kF_2(\omega _n^{2k})$$。<br>如此我们发现，两个式子化简后，只有一个常数项相反，其他都相同，于是再计算出第一个式子的时候我们可以$O(1)$求出第二个式子，并且发现两个式子将最初的范围缩小了一半，于是原问题缩小了一般，然后我们发现子问题也满足原问题性质，$k$与$k +\frac n2$同时取遍了(0, n - 1)，于是时间复杂度缩小到$O(NlogN)$。</p><p>这个算法在FFT的计算中最为常见，是在1965年由<strong>J.W.Cooley</strong>和<strong>J.W.Tuky</strong>提出的，因此也被称为<strong>Cooley-Tukey算法</strong>，实际上是基于分治的思想实现的，</p><h3 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h3><p>也称为傅里叶反变换，上文我们在线性积分变换中提到过反积分变换，而<strong>傅里叶反变换</strong>就是傅里叶变换的<strong>反积分变换</strong>，在数学中的意义是点值表示的多项式转化为系数表示，也就是说我们要从点值向量$(a_0, a_1, a_2…a_{n - 1})$得到系数向量$(y_0, y_1, y_2…y_{n - 1})$。则我们可以设$(y_0, y_1, y_2…y_{n - 1})$是$(a_0, a_1, a_2…a_{n - 1})$进行傅里叶逆变换后的结果，并<br>设有多项式$F(x) = \sum_{i = 0} ^{n - 1}y_0x^i$，<br>假设有向量$(c_0, c_1, c_2…c_{n - 1})$表示多项式在$\omega_n^0, \omega_n^{-1}…\omega_n^{1 - n}$上的点值表示，则向量c满足$$c_k = \sum_{i = 0} ^{n - 1}y_i(\omega_n^{-k})^i$$，然后我们考虑将式子展开。</p><p>$$c_k = \sum_{i = 0} ^ {n - 1}y_i(\omega _n^{-k}) ^ i $$</p><p>$$ = \sum_{i = 0} ^ {n - 1}(\sum_{j = 0} ^ {n - 1}a_j(\omega _n^{j} k) ^ j)(\omega_n^{-k})^i$$</p><p>$$= \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i ~=~ \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)$$</p><p>$$ = \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1}a_j(\omega_n^{j - k})^i ~=~ \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)$$</p><p>设一个式子$$S(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^i$$</p><p>在两边同时乘一个$\omega_n^k$得：$$\omega_n^kS(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^{(i+1)}$$</p><p>将前后两个式子相减，得到$\omega _n^kS(\omega_n^k) - S(\omega _n^k) = (\omega_n^k)^n - 1$</p><p>$$S(\omega _n^k) = \frac {(\omega_n^k)^n - 1}{\omega_n^k - 1}= 0 $$则当$k = 0$的时候，其值为0</p><p>而原来的式子$$c_k = \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0} ^ {j - k})^i = \sum_{j = 0} ^ {n-1}a_jS(\omega_n^{j - k})$$</p><p>当$j = k$的时候$S = n$，否则$S = 0$，所以$$a_i = \frac 1n c_i$$</p><p>这样我们得到了点值和系数的关系式，所以，从结论来说，将单位根幂上-1，然后做一次快速傅里叶变换，将结果的数除以n就是傅里叶逆变换的结果。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>一般的分治都会采用递归操作实现，但是在FFT中递归实现的效率比较低，所以大多数情况下采用迭代操作实现。我们观察二进制下的序列规律<br><img src="https://pic.superbed.cn/item/5c6522ae5f3e509ed96baca2" alt="pic"><br>发现分治到边界条件的时候每个数的下标等于原下标的二进制翻转，于是我们省去了分奇偶的操作，直接枚举每一个二进制位，然后向上合并就可以了。下面是迭代操作实现的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span> ; <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; l) &lt; N) l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"> <span class="keyword">int</span> T = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; l ; j ++)</span><br><span class="line"> <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) T /= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>)) ;</span><br><span class="line"> <span class="keyword">if</span> (i &lt; t) swap(a[i], a[T]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>我们把$\omega_n^k$称为<strong>旋转因子</strong>并保留下来，进入两个向量$a_k^0$和$a_k^1$时，旋转因子$\omega_n^k$乘以$a_k^1$，输出与$a_k^0$的和与差，这一个操作被称为<strong>蝴蝶操作</strong>。那这个东西究竟有什么作用呢？</p><p>重新考虑我们向上合并两个子问题时，假设有$A_1(\omega_{n/2}^k)$储存在$a(k)$中，$A_2(\omega _{n/2}^k)$储存在$a(k +\frac n2)$中，并且这两个值将要被储存在$b(k)$和$b(k + \frac n2)$中，则合并的操作可以如下表示：</p><p>$$b(k) ← a(k) + a(k +\frac n2) \times\omega_n^k$$</p><p>$$b(k +\frac n2) ← a(k) - a(k +\frac n2) \times\omega_n^k$$</p><p>于是我们考虑将两个值存放在原来的a中，取消b数组的存在，但是需要覆盖原来的值，所以就需要一个临时变量T。</p><p>$$T ←a(k +\frac n2) \times\omega_n^k$$</p><p>$$a(k +\frac n2) ← a(k) - T$$</p><p>$$a(k) ← a(k) - T$$</p><p>名字很好听，其实操作很简单，仅仅有一行而已。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, l, r[MAXN], L = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    <span class="keyword">complex</span> (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;x = xx, y = yy ;&#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x + b.x , a.y + b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x - b.x , a.y - b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x * b.x - a.y * b.y , a.x * b.y + a.y * b.x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> *A, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++) <span class="keyword">if</span> (i &lt; r[i]) swap(A[i], A[r[i]]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span> ; Mid &lt; L ; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">W</span><span class="params">(<span class="built_in">cos</span>(Pi / Mid), type * <span class="built_in">sin</span>(Pi / Mid))</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = Mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; L ; j += R) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; Mid ;k ++, w = w * W) &#123;</span><br><span class="line">    <span class="keyword">complex</span> x = A[j + k], y = w * A[j + Mid + k] ;</span><br><span class="line">    A[j + k] = x + y ; A[j + Mid + k] = x - y ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = Read(), M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; i ++) a[i].x = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i ++) b[i].x = Read() ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= N + M) L &lt;&lt;= <span class="number">1</span>, l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++)</span><br><span class="line">r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">FFT (a, <span class="number">1</span>) ; FFT (b, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; i ++) a[i] = a[i] * b[i] ; </span><br><span class="line">    FFT(a, - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N + M ; i ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(a[i].x/ L + <span class="number">0.5</span>)) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h5 id="同济高等数学，"><a href="#同济高等数学，" class="headerlink" title="同济高等数学，"></a>同济高等数学，</h5><h5 id="Thomas-H-Cormen算法导论，"><a href="#Thomas-H-Cormen算法导论，" class="headerlink" title="Thomas H.Cormen算法导论，"></a>Thomas H.Cormen算法导论，</h5><h5 id="Miskcoo-从多项式乘法到快速傅里叶变换，"><a href="#Miskcoo-从多项式乘法到快速傅里叶变换，" class="headerlink" title="Miskcoo 从多项式乘法到快速傅里叶变换，"></a><a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-10" target="_blank" rel="noopener">Miskcoo 从多项式乘法到快速傅里叶变换</a>，</h5><h5 id="郭晓旭-FFT讲义，"><a href="#郭晓旭-FFT讲义，" class="headerlink" title="郭晓旭 FFT讲义，"></a><a href="https://pan.baidu.com/wap/album/file?uk=3325080974&amp;album_id=2474841267539644259&amp;fsid=845742707277510&amp;adapt=pc&amp;fr=ftw" target="_blank" rel="noopener">郭晓旭 FFT讲义</a>，</h5><h5 id="维基百科-傅里叶变换，"><a href="#维基百科-傅里叶变换，" class="headerlink" title="维基百科 傅里叶变换，"></a><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">维基百科 傅里叶变换</a>，</h5><h5 id="白霂凡-Fast-Fourier-Transform，"><a href="#白霂凡-Fast-Fourier-Transform，" class="headerlink" title="白霂凡 Fast Fourier Transform，"></a><a href="https://zhuanlan.zhihu.com/p/31584464" target="_blank" rel="noopener">白霂凡 Fast Fourier Transform</a>，</h5><h5 id="Menci-FFT学习笔记，"><a href="#Menci-FFT学习笔记，" class="headerlink" title="Menci FFT学习笔记，"></a><a href="https://oi.men.ci/fft-notes/" target="_blank" rel="noopener">Menci FFT学习笔记</a>，</h5><h5 id="Heinrich-傅里叶分析之掐死教程，"><a href="#Heinrich-傅里叶分析之掐死教程，" class="headerlink" title="Heinrich 傅里叶分析之掐死教程，"></a><a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">Heinrich 傅里叶分析之掐死教程</a>，</h5><h5 id="attack-快速傅里叶变换-FFT-详解"><a href="#attack-快速傅里叶变换-FFT-详解" class="headerlink" title="attack 快速傅里叶变换(FFT)详解"></a><a href="http://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">attack 快速傅里叶变换(FFT)详解</a></h5>]]></content>
    
    <summary type="html">
    
      $$k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}$$ $$C(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i$$ 如何快速求两个多项式的卷积以及线性积分变换的基本内容。
    
    </summary>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="傅里叶变换" scheme="http://Yeasion.github.io/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="线性积分变换" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2015]约数个数和</title>
    <link href="http://Yeasion.github.io/2019/02/13/SDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
    <id>http://Yeasion.github.io/2019/02/13/SDOI2015-约数个数和/</id>
    <published>2019-02-13T02:55:53.000Z</published>
    <updated>2019-02-14T13:53:30.857Z</updated>
    
    <content type="html"><![CDATA[<p>如题，设$d(x)$表示$x$的约数个数，求$$\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)$$<br>首先要知道约数个数的一种表示方法：$$d(i,j) = \sum_{x|i} \sum_{y_j}[gcd(x,y) == 1]$$<br>然后题目所求就变成了<br>$$\sum_{i = 1}^N \sum_{j = 1}^M \sum_{k | i} \sum_{l | j}[gcd(k,l) == 1]$$<br>化简，改变量之后式子变为<br>$$\sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == 1)(\frac Mi)(\frac Mj)$$<br>考虑莫比乌斯反演,设<br>$$f(X) = \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == x)(\frac Ni)(\frac Mj)$$</p><p>$$F(x) = \sum_{x|n}f(n)$$<br>$$→ F(x) = \sum_{i = }^N \sum_{j = 1}^{N / x}(x|gcd())(\frac Ni)(\frac Mj)$$<br>$$→ F(x) = \sum_{i = }^N \sum_{j = 1}^{M / x}(\frac {N}{ix})(\frac {M}{jx})$$<br>考虑优化算法时间复杂度，可以预处理出$\sum_{i = 1}^N(\frac Ni)$和$\sum_{j = 1}^M (\frac Mj)$，连带着莫比乌斯函数可以直接O(N)预处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题答案化简为$f(1)$。反演后得到$$f(1) = \sum{x = 1}^N \mu (x) F(x)$$<br>$$<br>= \sum_{x = 1}^N \mu(x) \sum_{i = 1}^{N/x} \sum _{j = 1}^{M / x} (\frac Ni) (\frac Mj)<br>$$</p><p>进行数论分块就可以了，总体时间复杂度$O(T\sqrt N)$，其中T为数据组数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, U[MAXN], P[MAXN], Tot ;</span><br><span class="line"><span class="keyword">int</span> S[MAXN], Sum[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN] ;<span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T = Read() ; Init () ;</span><br><span class="line"><span class="keyword">while</span> (T --) &#123;Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= min(N, M) ; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(N / (N / l), M / (M / l)) ;</span><br><span class="line">Ans += <span class="number">1l</span>l * (S[r] - S[l - <span class="number">1</span>]) * Sum[N / l] * Sum[M / l] ;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设$d(x)$为$x$的约数个数，给定$N$，$M$，求$$\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)$$
    
    </summary>
    
    
      <category term="数论 莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演初步与实际应用</title>
    <link href="http://Yeasion.github.io/2019/02/02/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%88%9D%E6%AD%A5%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/02/02/莫比乌斯反演初步和实际应用/</id>
    <published>2019-02-02T01:48:43.000Z</published>
    <updated>2019-02-12T12:41:57.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫比乌斯反演初步和实际应用"><a href="#莫比乌斯反演初步和实际应用" class="headerlink" title="莫比乌斯反演初步和实际应用"></a>莫比乌斯反演初步和实际应用</h1><h3 id="定义和一般形式及其证明"><a href="#定义和一般形式及其证明" class="headerlink" title="定义和一般形式及其证明"></a>定义和一般形式及其证明</h3><blockquote><p>假设有数论函数关系式$F(N) = \sum_{x|N}f(x)$，则有$f(N) = \sum_{x|N}\mu(x)F(\frac Nx) = \sum_{x|N}\mu(\frac xN)F(x)$</p></blockquote><p>此为基本定义，但是看到这个函数也有限制就是必须是数论函数。，也就是定义域为正整数，对应集合为复数的函数。下面是函数的一般形式。</p><blockquote><p>假设d定义在$[1,∞)$上的复值函数$G(N) = \sum_{x = 1}^NF(\frac Nx)$，则有$F(N) = \sum_{x = 1}^N\mu(x)G(\frac Nx)$</p></blockquote><p>而这个$\mu(x)$函数就是莫比乌斯函数，其定义如下：</p><blockquote><p>$x= 1$时，$\mu(x) = 1$。</p><p>$x = P_1P_2…P_M$，（$P$为互异素数），则$\mu(x) = (-1)^M$</p><p>其他情况下$\mu(x) = 0$</p></blockquote><p>由定义可以得到莫比乌斯函数的两个重要性质：</p><blockquote><p><img src="https://img-blog.csdn.net/20140416161656796" alt="pic"></p><p>对任意<strong>正整数</strong>$N$有$\sum_{x|N}\frac{\mu(x)}{x} = \frac{\varphi(N)}{N}$</p></blockquote><p><strong>证明 :</strong></p><p>设有$\sum_{x|N}\mu(x) = [N = 1]$，且$f(N) = \sum_{x|N}[\frac Nx = 1]f(x)$，代入得$f(N) = \sum_{x|N}\sum_{y|\frac Nx}\mu(y)f(x)$。</p><p>由于$\sum_{x|N}\sum_{y|\frac Nx}$的限制条件为$xy|N$，所以等式写成:$$f(N) = \sum_{y|N}\mu(y)\sum_{x|\frac Ny}f(x) = \sum_{y|N}\mu(y)F(\frac Ny)$$</p><p>证明完毕。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用线性筛法求莫比乌斯函数，时间复杂度$O(N)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[++ Tot] = i, Mu[i] = - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= Tot &amp;&amp; P[j] &lt; N ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i] ;</span><br><span class="line"><span class="keyword">else</span> &#123;Mu[i * P[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：YY的GCD"><a href="#例题：YY的GCD" class="headerlink" title="例题：YY的GCD"></a>例题：YY的GCD</h3><blockquote><p>给定$N, M$，求所有的$X \leq N,~Y \leq M$中$gcd(X, Y)$是质数的点对有多少对。</p></blockquote><p>类似于一个模板题，因为其思维难度不是很大。考虑公式化题目描述，即求：$$\sum_{X = 1}^N \sum_{Y = 1}^M [gcd(i,j) == P]$$</p><p>设$f(x)​$为满足$gcd(X, Y) = X​$的$(X, Y)​$的对数，$F(X)​$为满足$X|gcd(X, Y)​$二点$(X, Y)​$的对数。得到$$F(N) = \sum_{x|N}f(x)​$$$，所以根据莫比乌斯反演定理，得​$$f(N) = \sum_{x|N}\mu(\frac xN)F(x) =\sum_{x|N}\mu(\frac xN)\frac{N \times M}{X^2}​$$，</p><p>而题目要求其$gcd(X,Y)$是一个质数也就是说$$Ans = \sum_P^{min(N, M} \sum_i^N\sum_j^M[gcd(i,j) = P] = \sum_P^{Minn(N,M)}f(P)$$</p><p>设$T = PX$，则式子变为$$\sum_{T = 1}^{Min(N,M)}\frac{N \times M}{T^2}(\sum_{G|T}\mu(\frac TG))$$</p><p>于是为了提高速度，可以预处理$\sum_{G|T}\mu(\frac TG)$。于是此题就以较快得速度解决了。</p><p>但是如果是多组数据还是有可能会$TLE$，所以如果想要更快，还可以使用整除分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T, N, M, V[MAXN], P[MAXN], Mu[MAXN], Tot ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S[MAXN], Ans, G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[Tot ++] = i, Mu[i] = - <span class="number">1</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i],</span><br><span class="line">G[i * P[j]] = Mu[i] - G[i] ; <span class="keyword">else</span> &#123;</span><br><span class="line">Mu[i * P[j]] = <span class="number">0</span> ; G[i * P[j]] = Mu[i] ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i ++) S[i] = S[i - <span class="number">1</span>] + G[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MU() ;</span><br><span class="line">T = Read() ; <span class="keyword">while</span> (T --) &#123; </span><br><span class="line">Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read(), M = Read() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= min(N, M) ; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">j = min(N / (N / i), M / (M / i)) ;</span><br><span class="line">Ans += (N / i) * (M / i) * (S[j] - S[i - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      $$F(N) = \sum_{x|N}f(x)$$ $$f(N) = \sum_{x|N}\mu(x)F(\frac Nx)$$ 在数论中占有重要地位的莫比乌斯反演，可以大大简化运算。本文初步探析莫比乌斯函数的定义，证明和代码实现。
    
    </summary>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>对插值法及拉格朗日插值多项式的初步理解运用</title>
    <link href="http://Yeasion.github.io/2019/02/01/%E5%AF%B9%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E8%BF%90%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/02/01/对插值法及拉格朗日插值多项式的初步理解运用/</id>
    <published>2019-02-01T12:26:21.000Z</published>
    <updated>2019-02-12T12:41:57.017Z</updated>
    
    <content type="html"><![CDATA[<p>$Interpolation$：<br>“插值”，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。</p><h2 id="一：什么是插值"><a href="#一：什么是插值" class="headerlink" title="一：什么是插值"></a>一：什么是插值</h2><p>插值是属于数学数值分析领域的内容，常被称作<strong>内插</strong>或者<strong>插值</strong>。接下来给出定义：</p><blockquote><p>给定N个数据离散点$(x_k,y_k)$，其中$k = 1,2,3…N$。对于$x$求$x$对应的$y$值叫做内插。<br>L_n(x) = \sum_{k = 0}^ny_kl_k(x)<br>定义域在区间$[A,B]$上有意函数$F$，已知函数$G$在$[A,B]$范围内满足$G(x_i) = F(x_i) = 1,2…N$</p></blockquote><blockquote><p>则称$G(x)$为$F(x)$关于节点${x_i}_{i = 0}^N$上的插值函数。</p></blockquote><p>假设我们已经求得$x_i$集合中的最大值$MAX$和最小值$MIN$</p><blockquote><p>用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in (MIN, MAX)$处的近似值的方法称为内插法。</p><p>用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in [A, B]$但$x \notin [MIN, MAX]$处的近似值的方法称为外插法。</p></blockquote><p>那么你现在已经基本了解了什么是插值，下面我们来看一些关于插值方法的东西。</p><h2 id="二：插值方法简介"><a href="#二：插值方法简介" class="headerlink" title="二：插值方法简介"></a>二：插值方法简介</h2><h3 id="1-片段插值"><a href="#1-片段插值" class="headerlink" title="1.片段插值"></a>1.片段插值</h3><p>这种插值方法几乎不能算是插值了，所实话如果没有维基百科编者根本就不知道有这种插值方法以及这样也能算是插值。</p><p>简单来说就是找到离$x$最近的采样点$x_i$，然后将$y$值分配为$y_i$。因此它的别称就是<strong>最近邻插值</strong>。但是就和wiki说的一样，这种插值方法是几乎碰不到的，因为出不了什么很高深的符合当前阶段学习的题目，但同时如果可以使用这种方法，无疑将使时间和复杂性都大大降低。</p><h3 id="2-线性插值"><a href="#2-线性插值" class="headerlink" title="2.线性插值"></a>2.线性插值</h3><p>这种插值从某种意义上说是利用了斜率，但实际上就是很简单的取平均值而已。</p><p>假设我们已知了所有自然数采样点${x_i}$，而我们要求的插值点是$x_{i+0.5}$,那么发现当前插值点是处于$x_i和x_{i+1}$之间，那么我们取的分配值就是$\frac{y_i+y_{i + 1}}{2}$。以数学公式的方法表达就是：</p><blockquote><p>$y = y_a + (y_b - y_a) \frac{x - x_a}{x_b - x_a}$</p><p>$G(x) = y_a \frac{x - x_b}{x_a - x_b} + y_b \frac{x - x_a}{x_b - x_a}$</p></blockquote><p>发现$G(x)$实际上是两个一次多项式的组合。也就是说，我们过这两个点分别作一次多项式$l_a = \frac{x - x_b}{x_a - x_b},~l_2 =  \frac{x - x_a}{x_b - x_a}$，那么$G(x) = y_al_a + y_bl_b$。</p><p>而实际上上述两种插值方法都存在误差，撇开片段插值不谈，线性插值的误差来源只要是因为插值点$x_k$是不可微分的，而计算得出的误差是$|F(x) - G(x)| \leq C(x_b - x_a)^2~where~C= \frac18max_{r \in[x_a, x_b]}|g^{‘’}(r)|$</p><p>其与数据点的距离平方成正比。</p><p>我们发现前两者的不同在于第一个找到了一个采样点进行插值，而线性插值则找到了两个点，因为两点确定一个一次函数。相同的，我们也有三点确定的二次函数的抛物线插值法，这里不再进行分析。</p><h3 id="3-多项式插值"><a href="#3-多项式插值" class="headerlink" title="3.多项式插值"></a>3.多项式插值</h3><blockquote><p>已知函数$F(x)$在$[A, B]$上$N + 1$个点处的函数值${y_i}_{i = 0}^N$，求次数不超过$N$的多项式$G(x) = c_0 +c_1x+…+c_Nx^N$使得$G(x) = F(x)$称为多项式插值。</p></blockquote><p><strong>定理</strong>：多项式插值函数存在且唯一：我们都知道过$N + 1$个点做一个$N$次函数最多只能做一个，而做一个$≥N$次的函数却可以有无数个。</p><h2 id="三：拉格朗日插值法"><a href="#三：拉格朗日插值法" class="headerlink" title="三：拉格朗日插值法"></a>三：拉格朗日插值法</h2><p>建立插值多项式的方法（简称为插值法）最基本的是需要求解线性方程组，而这是最为冗杂，最为复杂的算法，一般没有特殊情况是不会用这种方法构造插值多项式的。因此经过前人的努力，引入了一种更为简单，实现更为便捷的插值法：拉格朗日插值法。与之相通的有牛顿插值法，而我们又知道多项式插值函数的唯一性，因此恒有$L_n(x) = N_n(x)$。（L：拉格朗日，N：牛顿）。</p><p>在准备好了解拉格朗日插值法之前，我们先引入一个基函数的概念。</p><p>记$H_n(x)$为次数不超过$N$的多项式全集，也就是有$H_0(x),H_1(x)…H_n(x)$，设其构成$H_n(x)$的一组基，则插值多项式可表示为$G(x) = a_0H_0(x) + … + a_nH_n(x)$。</p><p>那么我们只要寻找到合适的基函数和插值多项式在这组基下的线性表示系数，就可以通过基函数构造插值多项式，也就是<strong>基函数插值法</strong>。</p><p>回到拉格朗日插值上来，我们首先寻找基函数。</p><blockquote><p>设$l_k(x)$是$n$次多项式，在节点$x_0，x_1…x_n$上满足$l_k(x_i) = 1 ~(i  = k)$或$l_k(x_i) = 0~(i ≠ k)$，则称$l_k(x)$为节点${x_i}_{i = 0}^N$上的$n$次拉格朗日插值基函数。</p></blockquote><p>构造法可以知道$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$</p><p>知道基函数之后我们用基函数求$G(x) = a_0l_0(x) + … + a_nl_n(x)$，带入$G(x_i) = y_i$可得</p><p>$L_n(x) = \sum_{k = 0}^ny_kl_k(x)$</p><p>上方的$L_n(x)$就是我们的拉格朗日插值多项式，具有结构清晰紧凑的特点，是用于理论分析的一般手法。根据插值误差估计定理可以估计出误差为：$\frac{y_{n + 1}(ζ)}{(n + 1) !} \omega_{n+1}(x)$，其小于$\frac{M_{n+1}}{(n+1)!}|\omega_{n+1}|(x)$。</p><h2 id="重心拉格朗日插值法"><a href="#重心拉格朗日插值法" class="headerlink" title="重心拉格朗日插值法"></a>重心拉格朗日插值法</h2><p>按照维基百科说的，这是对拉格朗日插值法的一种改进。当然，指的是速度上的，误差方面并没有什么差别。</p><p>按照均摊来说，如果用朴素拉格朗日插值法求插值函数，时间复杂度是$O(N^2)$，而中心拉格朗日插值法可以将时间复杂度压缩到$O(N)$。讲了整整一个量级，不可谓不改进。但从大多数方面来说，朴素拉格朗日也足足够用了。</p><p>实质上一致的前提下，中心拉格朗日插值法改写了拉格朗日基本多项式$l_j(x)$。</p><p>$l(x) = \prod_{i = 0}^K(X - X_K)$，使$l_j(x) = \frac{l(x)}{x - x_j} \times \frac{1}{\prod _{i = 0}^K(x_j - x_i)}$</p><p>然后定义一个重心权$w_j = \prod_{i = 0}^K\frac{1}{x_j - x_i}$，则$L(x) = l(x)\sum_{j = 0}^K \frac{w_j \times y_j}{x - x_j}$。</p><p>然后这个玩意怎么改进拉格朗日了呢？</p><blockquote><p>当插值点的个数增加一个的时候，将每一个$w_j$都除以)$(x_j - x_{K + 1})$，得到$w_{k + 1}$，直接省掉了一个循环，因此复杂度变为了$O(N)$。</p></blockquote><p>（维基百科原话，还是能看懂的。）</p><p>据说这个重心拉格朗日插值法不仅仅速度更优，并且省掉了多项式$l(x)$的计算，还有说什么不同于第一型的拉格朗日插值函数的向后稳定，这个改进后的第二型拉格朗日插值函数是向前稳定的，勒贝格常数非常小，因为什么切比雪夫节点插值的极佳稳定性之类的。</p><p>当然，这种切比雪夫节点、勒贝格常数之类的就不是我们此次要学习的范围了，读者只要重心拉格朗日插值法把朴素拉格朗日插值法速度上甩了一大截就可以了。追求完美的读者可以试着一学。</p><h2 id="拉格朗日插值基函数的性质及其应用"><a href="#拉格朗日插值基函数的性质及其应用" class="headerlink" title="拉格朗日插值基函数的性质及其应用"></a>拉格朗日插值基函数的性质及其应用</h2><blockquote><ol><li>当$F(x)$为一个多项式且次数$\leq n$时，有$F^{(n+1)}(x) \equiv 0$，所以$R_n(x) = F(x) - L_n(X) \equiv 0$，（R为误差）<strong>因此$n$次插值多项式对于次数$\leq n$的多项式是精确的</strong>。</li><li>若$F(x) = x^k$其中$k \leq n$，那么$R_n(x) = x^k - \sum_{j = 0}^nX^kl_j(x) = 0$。特别的，当$k = 0$的时候有$\sum_{j = 0}^nl_j(x) = 1$。</li></ol></blockquote><p>结合上面的性质及其公式，我们尝试解决一些实际问题。从最经典的应用开始，熟练地运用拉格朗日公式解决插值类问题。</p><h3 id="连续自然数幂和（差分表）"><a href="#连续自然数幂和（差分表）" class="headerlink" title="连续自然数幂和（差分表）"></a>连续自然数幂和（差分表）</h3><blockquote><p>已知$K$，求$\sum _{i = 1}^Ni^K$</p></blockquote><p>首先介绍一个叫做“差分表”的小知识点。这个名字我们很自然想到差分的思想，而我们平常用的差分（$a[i + 1] - a[i]$）只是叫做<strong>一阶差分</strong>，根据这个最基本的，我们定义出”<strong>差分表</strong>“的东西。</p><blockquote><p>对于函数$F(x)$，把$F’(X) = F(X + 1) - F(X)$叫做一阶差分，称$F’(X)$叫做差分算子。引申出对于$K &gt; 1$，有$F’^K(X) = F’^{K - 1}(X + 1) - F’^{K - 1}(X)$为$K$阶差分。</p></blockquote><blockquote><p>算出所有的$F’^K(X)$，将$X = 1,2,3…H$，代入每一个$F’^K(X)$，得到一个二维的表。即是差分表。</p></blockquote><p><img src="https://pic.superbed.cn/item/5c5427615f3e509ed9a278be" alt="Pic20000"></p><p>可以观察到列数递减，我们把所有的数插空排列，便形成了差分表的基本形状。</p><p>接着是引入的两个定理，可以直接使用：</p><blockquote><p>如果多项式的次数为$N$，则对于所有大于$N$的$K$，多项式的$K$阶差分都恒等于$0$。</p></blockquote><blockquote><p>假设多项式$F(X)$的差分表的左斜列中各个元素依次是$D_0,D_1…D_M$，那么对于这个多项式的和恒有：</p><p>$Sum(X) = \sum_{X = 0}^NF(X) = D_0C_{N + 1}^1 + D_1C_{N + 2}^1 + H + D_MC_{N + 1}^{M + 1}$</p></blockquote><p>以这个差分表作为工具，我们尝试从简单开始逐步解决这个问题。</p><p>首先假设$F(X) = X$，那么    我们构造出差分表的样子大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0   1   2   3   4   5   6 ……</span><br><span class="line">  1   1   1   1   1   1 ……</span><br><span class="line">    0   0   0   0   0 ……</span><br></pre></td></tr></table></figure><p>所以$Ans = 1 + 2 + H + N = 0 \times C_{N + 1}^1 + 1 \times C_{N + 2}^2$</p><p>所以$Ans = \frac{N(N + 1)}{2}$</p><p>接着引申到$F(X) = X^2$，建立出差分表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0^2   1^2   2^2   3^2   4^2   5^2   6^2 ……</span><br><span class="line">    1     3     5     7     9     11 ……</span><br><span class="line">       2     2     2     2     2 ……</span><br><span class="line">          0     0     0     0 ……</span><br></pre></td></tr></table></figure><p>答案就是$1^2 + 2^2 + H + N^2 = 0C_{N + 1}^1 + 1C_{N + 2}^1 + H + 2C_{N + 1}^{M + 1}$</p><p>所以答案为$\frac{N(N + 1)(2N + 1)}{6}$</p><p>因此我们引出了$Ans(K)$就是一个关于$N$的$K + 1$次多项式。</p><p>知道如此结论，我们就可以选择$K + 1$个点然后利用拉格朗日插值公式进行计算了。夫再度$O(K)$。</p><h3 id="例题：Study"><a href="#例题：Study" class="headerlink" title="例题：Study"></a>例题：Study</h3><blockquote><p>给定了$K, A, N, D$，求$\sum_{i = 0}^N \sum_{j = 1}^{A + iD} \sum_{l = 1}^jl^K$</p></blockquote><p>实际上和上面那个题没有什么很大的区别，式子虽然很长，我们从里到外分开考虑即可</p><p>最里面的$\sum_{l=1}^jl^k$是一个关于$j$的$k+1$次的多项式。把其差分表的第一条对角线求出来。</p><p>然后$\sum_{j=1}^{A+iD}\sum_{l=1}^jl^k$是关于$i$的$k+2$次的多项式。$O(k^2)$求出$i=0,1,…k+2$的值。</p><p>所以答案就是一个关于$N$的$k+3$次的多项式。求其第一条对角线即可。</p><hr><h2 id="拉格朗日插值法的代码实现"><a href="#拉格朗日插值法的代码实现" class="headerlink" title="拉格朗日插值法的代码实现"></a>拉格朗日插值法的代码实现</h2><p>经过上述的学习之后，代码实现可能反而是小事了。给出模板题的连接：<a href="https://www.luogu.org/problemnew/show/P4781" target="_blank" rel="noopener">拉格朗日插值法</a></p><blockquote><p>给出$N$个点$(X_i,Y_i)$，确定一个唯一的$N - 1$次多项式，代入$k$求值。</p></blockquote><p>代入所有的点，按照上述的讲解，爆搞就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">QuickPow</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">1</span> ; <span class="keyword">while</span> (Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod ;</span><br><span class="line">Y &gt;&gt;= <span class="number">1</span> ; X = X * X % Mod ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; K = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) X[i] = Read(), Y[i] = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> Ken = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">Ken = Ken * (X[i] - X[j] + Mod) % Mod ;</span><br><span class="line">&#125;Ken = QuickPow(Ken, Mod - <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">Ken = Ken * (K - X[j] + Mod) % Mod ;</span><br><span class="line">&#125;Ken = Ken * Y[i] % Mod ;</span><br><span class="line">Ans = Ans + Ken % Mod ;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans % Mod) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>都是说拉格朗日插值法好用，之后才知道它的优点在哪：</p><blockquote><p>代替线性，抛物线之类的插值方法繁琐的公式结构和计算方法，其公式结构整齐紧凑，好看得多。</p></blockquote><p>可能有人感觉很好笑，但是这确实是很重要的一点。考场上推出来超级复杂繁琐的方程式会让你心态爆炸的，因此简单整齐的公式结构也是十分重要的，好写好看，这可能也是他广为人用的原因之一吧。</p><p>但当然，数学仍然是不完整的，对于采样点较多的情况时出现的龙格现象，也表明拉格朗日插值法具有数值不稳定的特点，因此大多数情况，拉格朗日插值法仍用于解决次数较低的插值多项式问题。</p><p>牛顿插值法不再将了，因为其本质是一样的，充其量走了不同的路子而已，想学的朋友可以去了解一下。</p>]]></content>
    
    <summary type="html">
    
      $$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$$ $$L_n(x) = \sum_{k = 0}^ny_kl_k(x)$$ 插值，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。本文主要介绍拉格朗日插值法，具体包括其工作原理，改进法，性质应用和代码实现。
    
    </summary>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="拉格朗日插值法" scheme="http://Yeasion.github.io/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    
      <category term="差分法" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈关于动态规划问题的优化方案</title>
    <link href="http://Yeasion.github.io/2019/02/01/%E6%B5%85%E8%B0%88%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://Yeasion.github.io/2019/02/01/浅谈关于动态规划问题的优化方案/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-02-12T12:41:57.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈关于动态规划问题的优化方案"><a href="#浅谈关于动态规划问题的优化方案" class="headerlink" title="浅谈关于动态规划问题的优化方案"></a>浅谈关于动态规划问题的优化方案</h1><h2 id="1-单调队列优化"><a href="#1-单调队列优化" class="headerlink" title="1.单调队列优化"></a>1.单调队列优化</h2><p> 单调队列是一种具有单调性的队列，其中的元素全部按照递增或者递减的顺序排列，就比如下面这个递减队列。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxgb732mtj30dr054jr7.jpg" alt="picture"><br> 假如说我们要在队尾加入一个$5$，那么我们入队的步骤就是这样的：</p><blockquote><p> 发现队尾$1$，(q[tail])，$1&lt;5$，则将1退出(tail–)<br> 发现队尾$2$，(q[tail])，$2&lt;5$，则将2退出(tail–)<br> 发现队尾$3$，(q[tail])，$3&lt;5$，则将3退出(tail–)<br> 发现队尾$8$，(q[tail])，$8&gt;5$，停止退出队尾，将$5$入队。</p></blockquote><p><strong>经过上述步骤之后队列变为了{8,5}，依然满足递减的单调性，而实际上这也就是单调队列的基本操作。而维护递增的方式也是一样的。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">int</span> N, A[MAXN], Q[MAXN], Head = <span class="number">1</span>, Tail = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) A[j] = Read() ;</span><br><span class="line">Q[<span class="number">1</span>] = A[<span class="number">1</span>] ; <span class="comment">//将第一个元素入队。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt;= Tail &amp;&amp; Q[Tail] &lt; A[j])</span><br><span class="line"><span class="comment">//如果队列不为并且队尾元素小于A[i]</span></span><br><span class="line">Tail -- ; <span class="comment">// 弹出队尾元素</span></span><br><span class="line">Q[++ Tail] = A[j] ; <span class="comment">// 入队。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 【例题1】<br> 我们现在有一个整数序列$A(a[MAXN])$，长度为$n$，又知两个参数$k$和$m$，要求：从$A$序列中找出$k$个不相交的区间，每段区间长度$len$&lt;=$m$，要求所有k个区间的区间和最大。</p><p> 考虑最基本的$DP$,设$dp[i][j]$表示从前$j$个数里面选出来$i$个长度不超过m的不相交区间的区间和最大值，然后我们再枚举一个$k$，指选择$[k+1,j]$这个子区间。然后我们创造一个前缀和数组$sum[MAXN]$，那么$[k+1,j]$这个区间的区间和就是$sum[j]-sum[k]$。子问题分为两块：$j$选入子区间，或者$j$不选入子区间，从$j-m$到$j$范围内枚举一个$k$使得$dp[i-][k]+sum[j]-sum[k]$最大，然后与$dp[i][j-1]$取一个$max$可得答案。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Sum[i] = S[i - <span class="number">1</span>] + A[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> Ans = - Inf ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j - M ; k &lt;= j ; k ++)</span><br><span class="line">Ans = max(Ans, Dp[i - <span class="number">1</span>][k] + Sum[j] - Sum[i]) ;</span><br><span class="line">Dp[i][j] = max(Ans, Dp[i][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 这样的$DP$时间复杂度为$O(nmk)$，显然太大，于是我们考虑优化。<br> 我们可以看到$DP$的原式子是$\color{red}{dp[i][j]=max(dp[i][j-1],max(f[i-1][k]+sum[j]-sum[k]));}$<br> 我们发现在里面的$k$的最优化枚举当中，sum[j]是不随k的枚举变化的，所以我们可以将sum[j]提出来变成：$\color{red}{dp[i][j]=max(dp[i][j-1],sum[j]+max(f[i-1][k]-sum[k]));}$<br> 可以知道在整个式子里面最耗时间的就是最后关于$dp[i-1][k]-sum[k]$最大值的枚举，所以只要快速计算出来了$dp[i-1][k]-sum[k]$就可以快速计算整个式子。我们来看$dp[i-1][k]-sum[k]$的范围是在$[0][0],[0][1],….[0][m-1],[1][m],[2][m+1],…,[n-m][n-1]$这些区间上的最大值，也就是所有的$[j][i+j-1]$的区间。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxhphwrmij30mr042q2t.jpg" alt="picture2"><br> 我们发现这些区间的左右端点都是单调递增的，所以我们可以利用单调队列在$O(1)$的时间内解决这些区间。然后我们就将时间优化到了$O(nk)$。</p><h2 id="【例题2】-NOI2005-瑰丽华尔兹-link"><a href="#【例题2】-NOI2005-瑰丽华尔兹-link" class="headerlink" title="【例题2】$[NOI2005]$瑰丽华尔兹(link)"></a>【例题2】$[NOI2005]$瑰丽华尔兹(<a href="https://www.luogu.org/problemnew/show/P2254" target="_blank" rel="noopener">link</a>)</h2><p> 一个$n×m$的矩形网格。你初始站在$(x,y)$这。有些格子有障碍而有些没有。有$K$个时间段。第$i$个时间段从$s[i]$持续到$t[i]$（包括两端）这段时间内网格会向某个方向（上下左右之一）倾斜。所以每个时间段内的每个时间单位，你可以选择在原地不动，或者向倾斜的方向走一格（当然你不能走到障碍上或是走出网格）。<br> 求你最多能走多少格。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxigg49rfj30rh0etjrn.jpg" alt="picture3"><br> 如上图所示，黑色方块为障碍，$S$为起始点。<br> 按照最常的$DP$思路来看，我们设$dp[k][i][j]$为在k时间点，从$(x,y)$节点走到了$(i,j)$节点的时候最长走了多长。初始化$dp[0][i][j]$全部为$?∞$，而$dp[0][x1][y1]0$=$0$($x1,y1$为初始位置)，考虑子问题就是：从那边来？$k$时刻是从那个方向来还是不动？我们以第$k$时刻向右倾斜为例。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxiqemby7j30t10f2ta3.jpg" alt="picture4"><br> 如果是向右倾斜，那么上一层状态就是在$(i,j-1)$地点，那么结合两个子问题我们可以得出$DP$方程式：$dp[k][i][j]=max(dp[k-1][i][j],dp[k-1][i][j-1]+1);$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= Len ; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">Dp[k][i][j] = max(Dp[k - <span class="number">1</span>][i][j], Dp[k - <span class="number">1</span>][i][j - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure></p><p> 那么这样的时间复杂度就是$O(nm\sum_{i=1}^{K}(t[i]-s[i]+1))$，是无法通过这个题的全部数据的。然后我们紧接着考虑怎么优化。关于位置的$n^2$枚举我们没有什么办法，但是关于$K$我们可以进行优化，时间点很多有$\sum_1^K(t[i]-s[i]+1)$个，但是时间段$K$却&lt;=$200$，那么我们可以将一段时间的转移全部合并起来一起算，那么就快得多了。<br> 我们设$dp[k][i][j]$为在第$k$个时间段末尾，从$(x,y)$走到了$(i,j)$点,$len[k]$为第$k$个时间段的持续时间，可以算出是$t[k]-s[k]+1$。<br> 首先还是$n^2$的枚举，和$k$时间段的枚举，之后我们还有一个$l$的枚举，这个$l$枚举的是<strong>上一个状态加上在当前这个$k$的时间段内一共走的步数对应倾斜方向的横、竖坐标</strong>，如果我们继续以右倾为例，那么$j-len[j]&lt;=l&lt;=j$，就是从完全不动到走了最多的$len[k]$步，那么我们有了状态转移方程式：$\color{red}{dp[k][i][j]=max_{j-len[k]&lt;=l&lt;=j}(dp[k-1][i][l]+j-l)}$,由于其中的+$j$与l的枚举并无关联，所以提出来就变成了$\color{red}{dp[k][i][j]=max_{j-len[k]&lt;=l&lt;=j}(dp[k-1][i][l]-l)+j}$。其实也就是枚举这个时间段之前这个人的位置在哪，也就知道了当前的$dp[k][i][j]$是从哪里转移过来的。<br> 之后，我们回过头来看上一道题的最后的$DP$方程式：$\color{red}{dp[i][j]=max(dp[i][j-1],sum[j]+max(f[i-1][k]-sum[k]));}$<br> 是不是发现格式非常的相似呢？，我们固定住$i$之后的状态转移方程式基本是和上题一样的，所以一样可以使用单调队列优化到$O(nmK)$。<br> 下面针对一组样例，我们进行一遍手动模拟，以帮助更好的理解。<br> 就用洛谷的样例吧。（第一行分别为n,m,x1,y1,k）</p><blockquote><p> 4 5 4 1 3<br> . . xx.<br> . . . . .<br> . . . x.<br> . . . . .<br> 1 3 4<br> 4 5 1<br> 6 7 3</p></blockquote><p> 那么画完图之后就是这个样子：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxp42nsxdj307t05zq2q.jpg" alt="picture5"><br> 从$1$~$3$时刻的倾斜方向是右，那么纵坐标是你不变的，我们枚举纵坐标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> S = Read(), T = Read(), Dir = Read() ;        <span class="comment">//注意要反着DP，也就是倒退</span></span><br><span class="line"><span class="keyword">int</span> Len = T - S + <span class="number">1</span> ; <span class="keyword">switch</span>(Dir) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++) DP(i, N, j, Dir, Len) ;<span class="comment">//北面的话横坐标不变，那么我们枚举纵坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++) DP(i, <span class="number">1</span>, j, Die, Len) ;<span class="comment">//南面的话横坐标不变，那么我们枚举纵坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) DP(i, j, M, Dir, Len) ;<span class="comment">//西面的话纵坐标不变，那么我们枚举横坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) Dp(i, j, <span class="number">1</span>, Dir, Len) ;<span class="comment">//东面的话纵坐标不变，那么我们枚举横坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然后当我们的横坐标x枚举到1的时候，我们在DP函数里面定义一个now，然后是$while(x&gt;=1$&amp;&amp;$x&lt;=n$&amp;&amp;$y&gt;=1$&amp;&amp;$y&lt;=m)$,因为首先要保证不超过边界。然后如果我们发现右面是可以走的，那么我们就进行一个push操作。也就是关于dp[p-1][x][y]在单调队列里面的入队操作。在最前面我们已经介绍了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> Now, <span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (V == Inf) <span class="keyword">return</span> ;<span class="comment">// 如果根本到不了，返回</span></span><br><span class="line"><span class="keyword">while</span> (Heap &lt;= Tail &amp;&amp; V - Now &gt;= Q[Tail])</span><br><span class="line">Tail -- ;<span class="comment">//弹出队尾元素</span></span><br><span class="line">Q[++ Tail] = V - Now ; Pos[Tail] = Now ;</span><br><span class="line"><span class="comment">// Pos记录位置，用来判断是不是可以滑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 而至于为什么要在$while$里面减去一个$now$，是因为(x,y)这个位置不一定是在当前方向的起点上，因为之后某一步的步数减去当前的步数得到的值就是(x,y)到那一步在的点的距离，相当于一个化简~<br> 由于$dp[0][i][j]$=-$INF$,当前的$p$=$1$所以$p$-$1$的时候$value$就是-$INF$，所以在第0个时间段到不了这个地方，我们直接返回。然后下面其实就没什么事了，所有的push全部直接返回，最后退出DP函数。就这样进行到$x$(即$j$)=$3$的时候，我们发现$map[3][4]$是一个障碍点，那么也就是说我们之前进行的所有工作<strong>全部无效</strong>，然后我们将整个队列清空，即$head$=$1,tail$=$0$;<br> 然后接着进行到$x$=$4$,$y$=$1$($4$行$1$列)的时候，我们到了起始点，而起始点的dp[0][4][1]是0，所以$value$!=-$INF$，我们从终于将一个值$value$-$now$=-1入队了，那么我们当前的队列是这个样子的：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxqepa2l6j307v057t8i.jpg" alt="pictre6"><br> 加上步数之后我们发现$dp[p][x][y]=q[head]+now$依然是$0$，所以$ans$没有被更新（废话，你从起点走到起点需要更新$ans$嘛），所以我们继续向下进行，因为每次$now$都会++，所以下面的$dp[p][x][y]$加上$now$之后就可以更新$ans$的值了。然后进行到$x$=$4$,$y$=$5$的时候，我们发现$now-pos[head]=4$，大于可以$len$，也就是说超过了可以滑动的区间。（一共就三秒你怎么滑第四块啊~）那么我们将队首弹出，接下来我们就不能再更新ans的最大值了，$x$=$4$时完美结束。这个时候我们的行走路径大概如下：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxqof26myj307o05omwy.jpg" alt="picture7">（蓝色方块为当前方块，黄色方块为路径）<br> 也就是说从$1$~$3s$我们最多可以走3块。（真是麻烦啊~）<br> $i$继续走，我们进行到下一个时间段。$4$~$5s$的时候是向北倾斜的。那么我们进行$DP(i,n,j,dir,len)$，我们从$n$行$j$列开始$DP$，第一次将$tail$弹出后又入队我们不管，因为$j=1$、$2$的时候都不能更新$ans$，然后到了$j=3$的时候，我们将$dp[1][4][3]-now=1$入队了。<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxrbdg1zfj308905ywea.jpg" alt="picture8"><br> 然后当$now$进行到第三次的时候我们就可以更改ans值为4了。<br> 之后结束了第二个时间段。此时的路径大概是这样的：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxrgc5l1ej308105smwy.jpg" alt="picture9"><br> 最后在第三个时间段内，我们将路径更改为如下：<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxricdoxpj307w06ct8i.jpg" alt="picture0"><br> 那么以上就是整个样例的模拟，最终我们得到$ans$数为6.</p><h2 id="关于单调队列优化的一点总结"><a href="#关于单调队列优化的一点总结" class="headerlink" title="关于单调队列优化的一点总结"></a>关于单调队列优化的一点总结</h2><p> 鉴于两者之间的$DP$转移方程的相似性，我们成功的利用单调队列优化了问题，那么回过头来看看，什么样的问题可以利用单调队列进行优化呢？我们最上面讲的单调队列是具有单调性的一种数据结构，他可以保证数据的单调性，自然也就可以留下数据的最大值或者最小值，利用了单调性，<strong>就是减少了一位枚举，减去一维，直接获得单调队列里面的最优解</strong>。并且DP可以使用单调队列优化，当且仅当$DP$式的格式基本满足$\color{red}{dp[i]=a[i]+max_{l[i]&lt;=j&lt;=r[i]}b[j]}$的时候。即“$dp[i]$=$A(i)$+$B(j)$中的最小/大值 $(i-k&lt;=j&lt;i,k$为常数$)$”，当你发现要求$max$而且求可能拓展的状态有线性关系的时候，你就可以考虑单调队列优化了。</p><h2 id="2-斜率优化"><a href="#2-斜率优化" class="headerlink" title="2.斜率优化"></a>2.斜率优化</h2><p> 如果你有一个这样结构的$DP$式：</p><blockquote><p> $f[i]=max_{j=1}^{j&lt;=i}(a[i] \times b[j]+c[j]+d[i])$</p></blockquote><p> 我们发现取$max$里面的d[i]其实和j的枚举并没有关系，所以将d[i]提出来就变成了这样：</p><blockquote><p> $f[i]=d[i]+min_{j=1}^{j&lt;=i}(a[i] \times b[j]+c[j])$</p></blockquote><p> （只是这样的结构而已，比如也可以是$max$，$j$也不一定属于$[1,n]$此处只是一个单独情况）<br> 其中$a[now],b[now],c[now],d[now]$都是关于$now$的函数，并且$b[now]$是单调递增的，那么我们接下来利用数学归纳法证明其决策的单调性。<br> 首先我们假设有两个决策$j$,$k$满足$j&lt;k$并且$k$的决策优于$j$的决策。那么我们有$d[i]+a[i]<em>b[j]+c[j]&gt;=d[i]+a[i]</em>b[k]+c[k]$;消去左右两端的d[i]后可得$a[i]<em>b[j]+c[j]&gt;=a[i]</em>b[k]+c[k]$。<br> 我们知道在$i$后面有状态$i+1$，我们为了简单起见，设$a[now]$是单调递减的，那么我们就是要证明</p><blockquote><p> $d[i+1]+a[i+1]<em>b[j]+c[j]&gt;=d[i+1]+a[i+1]</em>b[k]+c[k]$</p></blockquote><p> 由于$a$是单调递减的，所以$a[i-1]$也可以写成$a[i]-v$的形式，其中$v&gt;0$，那么式子变成：</p><blockquote><p> $d[i+1]+a[i]<em>b[j]+v</em>b[j]+c[j]&gt;=d[i+1]+a[i]<em>b[k]+v</em>b[k]+c[k]$</p></blockquote><p> 然后因为$a[i]<em>b[j]+c[j]&gt;=a[i]</em>b[k]+c[k]$，并且$b[k]&gt;b[j]$,所以我们有$v<em>b[k]&gt;v</em>b[j]$，所以我们知道</p><blockquote><p> $d[i+1]+a[i+1]<em>b[j]+c[j]&gt;=d[i+1]+a[i+1]</em>b[k]+c[k]$</p></blockquote><p> 是正确的，<strong>决策单调性也存在</strong>。然后我们将式子展开就可以得到这样一个玩意：</p><blockquote><p>  $-a[i]&gt;=\frac{c[k]-c[j]}{b[k]-b[j]}$。</p></blockquote><p> 你会发现这个玩意像极了一个叫做斜率的东西(数学就是瞎$yy$出来的)</p><blockquote><p> $slope(i,j)$:$\frac{y[k]-y[j]}{x[k]-x[j]}$</p></blockquote><p> 没错，这个东西就是我们要讲的第二个内容：斜率优化！</p><blockquote><p> 记斜率为$slope(i,j)=\frac{c[k]-c[j]}{b[k]-b[j]}$</p></blockquote><p> 那么我们紧接着$yy$这个式子的属性，发现它和单调队列有很多相似之处,因此我们也可以根据这些特性对$DP$进行优化：</p><blockquote><ol><li>$-a[i]&gt;=slope(q[l],q[l+1])$。</li></ol></blockquote><p> 我们知道$q[l]$是在$q[l+1]$之前就已经输入完毕的了，那么这个式子就表示$q[l]$不如$q[l+1]$更优，所以弹出队首。</p><blockquote><p> 2.$slope(q[r-1],q[r]&gt;slope(q[r],i)$。</p></blockquote><p> 假设在之后会出现一个$a[t]$使得$-a[t]&gt;=slope(q[r-1],q[r])$,那么在弹出$q[r-1]$之后，$-a[t]也一定&gt;=slope(q[r],i)$;</p><p> 我们考虑将每一个$(b[j],c[j])$作为一个点对放到一个平面直角坐标系当中，画一条过点$(b[j],c[j])$的斜率为$a[i]$的直线，那么这个直线的方程式就是$f[i]=a[i]x+(y[j]-a[i]x[j])$，所以我们就成功的将一个决策转化到了平面直角坐标系上面。<br> 假如说我们将所有的决策转化为点映射到图上可以得到这样一个图：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxvi4jsa2j311f0kq0tf.jpg" alt="pciture"><br> 那么我们对于每一个点做一个斜率为$a[i]$的直线可以得到这样的一幅图<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxvk3anb2j31130l8wfz.jpg" alt="pictureb"><br> 由于我们要枚举的是一个是决策最优的方案，那么我们就要根据题意，来看看是$min$还是$max$，在这里我们的方程式是取的$min$，也就是要在所有的决策中找到一个位置最靠下的，也就是最右面那道直线。<br> 但是这样每一条边每一条边地建、找实在是太慢，于是我们考虑如何优化。<br> 我们知道最下面的一条边肯定会<strong>在一个下凸的凸壳上面</strong>（比如下图），那么我们就要想办法维护这个凸壳，将不可能有贡献的点删去。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxvoucj8uj310g0klt9g.jpg" alt="picturec"><br> 那么上图中被下面的这条折现包起来的所有的点就都没有作为最优决策的机会，因此我们就要抛弃这些决策，并且<strong>有可能被选为最优决策的只有在这个下凸壳上面的点</strong>。<br> 而对于整个下凸壳的求法，我们考虑先排一遍序，按照x[i]从小到大的顺序排序，然后由于x[i]递增，那么我们就只需要考虑在右面添加点就可以了。对于一个点v，如果它是由前面两个点组成的直线<strong>逆时针旋转</strong>过来的，那么很好，我们就将它加入目前的下凸壳，比如下图：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxw1nrw0mj30oy0dz74q.jpg" alt="pictured"><br> 但是如果当前点$v$是由前面两个点$h$,$g$所形成的直线经过<strong>顺时针旋转</strong>得到的，那么我们就要删除之前的最后一个点$g$，<strong>继续判断</strong>$v$是不是由$h$和$h$前面的点<strong>顺时针旋转</strong>得到的，直到碰到一个<strong>逆时针旋转</strong>的操作，那么停止，并将最后删除的点的前一个点连到$v$点上。比如下图：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxw8k74hqj30w30iqwff.jpg" alt="picturee"><br> 删除第一个节点之后继续判断<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxwapzyaij30v10hp0tk.jpg" alt="picturef"><br> 而对于上凸壳的寻找，就是讲寻找下凸壳中所有的顺逆时针反过来就可以了。而顺时针和逆时针的判断就是根据斜率。当然你也可以这么判断：若 $(x[C]?x[A])(y[B]?y[A])?(x[B]?x[A])(y[C]?y[A])&gt;0$，则是顺时针转的；否则是逆时针转的($=0$的情况是三点共线)。<br> 那么维护完了凸壳，加下来我们要做的就是在凸壳上找到一个斜率为$k$的切线了，而这个切线的寻找分为两种情况来考虑。（针对下凸壳）</p><blockquote><p> 1.当斜率是递增的时候，我们可以发现被取到的点也是越来越靠右的，所以我们只要从左到右依次删除不优的点就可以了。可以使用双向队列。<br> 2.当斜率不单调的时候，我们就采用二分的方法。我们一直取中间的$mid$点，如果$mid+1$存在并且与$mid$点构成的直线的斜率小于k，那么l=mid+1吗，接着二分；如果$mid-1$存在并且与$mid$构成的直线的斜率大于k，那么r=mid-1，接着二分。如果上面两个条件都不满足，<strong>那么$mid$就是切点，也就是我们要找的点啦！！</strong></p></blockquote><h2 id="【例题3】-HNOI2008-玩具装箱（Link）"><a href="#【例题3】-HNOI2008-玩具装箱（Link）" class="headerlink" title="【例题3】[HNOI2008]玩具装箱（Link）"></a>【例题3】[HNOI2008]玩具装箱（<a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener">Link</a>）</h2><p> 题目描述<br> $P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1…N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C[i]$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为$x=j-i+\sum_{k=j}^{k&lt;=j}C[k]$ 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$x$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.<br> 输入输出格式<br> 输入格式：<br> 第一行输入两个整数$N$，$L$.接下来$N$行输入$C[i]$.$1&lt;=N&lt;=50000$,$1&lt;=L,Ci&lt;=10^7$<br> 输出格式：<br> 输出最小费用</p><p><strong>解析</strong></p><p> 简单来说，我们有一个长度为$L$的序列$C[i]$,要求将序列分成若干段，每一段如果从$i$到$j$，整段的和为$S$，那么就会产生$(j-i+S-L)^2$的代价，要求得到最小的代价和。<br> 那么$S$就是$\sum_{k=i}^{k&lt;=j}C[k]$，那么我们就可以把式子简化成这样：$\sum_{k=i}^{k&lt;=j}(C[k]+1)-(L+1)$，所以你可以发现如果将输入的所有$C[i]$加上$i$并且将$L$全部加上$1$的话，费用就变成了$(S-L)^2$。<br> 设$sum[i]$为$i$点的前缀和，我们得到$DP$式子为$f[i]=min_{j=0}^{j&lt;=i}(f[j]+(sum[i]-sum[j]-L+i-j-1)^2)$<br> 嗯，按照上面的节奏，我们将$j$范围内的式子变一下：$f[i]=min_{j=0}^{j&lt;=i}(f[j]+((sum[i]+i)-(sum[j]+j)-L)^2)$<br> 然后我们令$s[i]=sum[i]+i$，式子就变成了这样：$f[i]=min_{j=0}^{j&lt;=i}(f[j]+(s[i]-s[j]-L)^2)$<br> 然后把里面的平方展开$f[i]=min_{j=0}^{j&lt;=i}(f[j]+s[i]^2+(s[j]+L)^2-2<em>s[i]</em>(s[j]+L))$<br> 然后稍微一个移项$f[i]+2<em>s[i]</em>min_{j=0}^{j&lt;=i}(s[j]+L)=f[j]+s[i]^2+(s[j]+L)^2$<br> 然后我们看这个式子的格式就很熟悉了</p><blockquote><p> b+kx=y</p></blockquote><p>  对！就是前面搞的直线的解析式！所以我们知道这么一个转化</p><blockquote><p> $x=s[j]+L$<br> $y=f[j]+s[i]^2+(s[j]+L)^2$</p></blockquote><p> 并且我们还知道$dp[i]$就是上面的$y=kx+b$的截距。那么我们将所有的$(x=s[j]+L，f[j]+s[i]^2+(s[j]+L)^2)$点全部加到平面直角坐标系上，然后维护下凸壳就可以啦！并且你可以发现斜率$k=2*s[i]$是一个单调递增的哦~<br> 并且这里还有一个很重要的地方：看上面的那个$y$的方程是$y=f[j]+s[i]^2+(s[j]+L)^2$而实际上这里并不是一个关于$i,j$的双变量，我们在对于同一个$f[i]$计算的时候，求斜率坐标相见就已经抵消掉了这个$i$的部分。<br> 至于凸壳的寻找方法和最优点的寻找方法上面已经有比较详细的介绍了，就不再多说，上代码讲解就好了吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">X</span><span class="params">(LL j)</span> </span>&#123;<span class="keyword">return</span> S[j] ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Y</span><span class="params">(LL i)</span> </span>&#123;<span class="keyword">return</span> F[i] + (S[i] + L - <span class="number">1</span>) * (S[i] + L - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Slope</span><span class="params">(LL i, LL j)</span> </span>&#123;<span class="keyword">return</span> (Y(j) - Y[i]) / (X(j) - X(i)) ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read(), L = Read() ;</span><br><span class="line">L ++ ; Head = Tail = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">LL X = Read() ;</span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + X + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope(Q[Head], Q[Head + <span class="number">1</span>]) &lt; <span class="number">2</span> * S[i])</span><br><span class="line">Head ++ ; LL j = Q[Head] ;</span><br><span class="line">F[i] = F[j] + (S[i] - S[j] - L) * (S[i] - S[j] - L) ;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope(Q[Tail - <span class="number">1</span>], Q[Tail]) &gt; Slope(Q[Tail], i))</span><br><span class="line">Tail -- ; Q[++ Tail] = i ;</span><br><span class="line">&#125;Print(F(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="【例题4】-土地征用-（Link）"><a href="#【例题4】-土地征用-（Link）" class="headerlink" title="【例题4】 土地征用 （Link）"></a>【例题4】 土地征用 （<a href="https://www.luogu.org/problemnew/show/P2900" target="_blank" rel="noopener">Link</a>）</h2><p> 约翰准备扩大他的农场，眼前他正在考虑购买N块长方形的土地。如果约翰单买一块土 地，价格就是土地的面积。但他可以选择并购一组土地，并购的价格为这些土地中最大的长 乘以最大的宽。比如约翰并购一块3 × 5和一块5 × 3的土地，他只需要支付5 × 5 = 25元， 比单买合算。 约翰希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。 给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。<br> 输入输出格式<br> 输入格式：</p><p> $Line$ $1:$ $A$ $single$ $integer:$ $N$<br> $Lines$ $2..N+1:$ $Line$ $i+1$ $describes$ $plot$ $i$ $with$ $two$ $space-separated$ $integers:$ $width$ _ $i$ $and$ $length$ _ $i$<br> 输出格式：<br> $Line$ $1:$ $The$ $minimum$ $amount$ $necessary$ $to$ $buy$ $all$ $the$ $plots.$</p><p><strong>解析</strong></p><p> 我们定义结构体$Edge$中含有$X,Y$分别表示一块土地的长和宽。<br> 考虑一块土地$A$，如果有一块土地$B$的$X$和$Y$都大于$A$，那么$A$的存在是没有意义的，因为$A$是可以不耗费任何代价被$B$所合并的，所以它不会对答案产生任何影响。于是我们考虑去掉这样所有的土地$A$。<br> 首先我们将所有土地按照长度从小到大排序，长度相同的按照宽度从小到大排序。定义一个$Stack$，然后连续将所有的土地入栈，在$A$入栈之前将之前栈中所有宽度小于等于$A$的土地全部弹出，然后入栈$A$。那么最后在栈中的元素就是我们所希望的元素。这里的元素是按照长度从小到大，宽度从大到小的顺序有序排列的。<br> 那么显然我们每次合并的都是一个连续的区间。考虑使用$DP$，易得状态转移方程：$dp[i]=min_{j=1}^{j&lt;=Top}(dp[i],dp[j]+Stack[j+1]<em>L[i])$,其中Stack里面存的是元素的宽度，L是栈中元素的长度。（因为有些土地被抛弃了所以我们不能继续使用$Edge$结构体），然而这样的时间复杂度会超时，考虑斜率优化。<br> 我们看到后面的$dp[j]+Stack[j+1]</em>L[i]$，设$k=Stack[j+1]，b=dp[j]$，然后$x=L[i]$，那么我们就得到了直线方程:$y=kx+b$。套上斜率优化的板子即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Put_in_Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Top &amp;&amp; S[Top] &lt;= E[i].Y) Top -- ;</span><br><span class="line">S[++ Top] = E[[i].Y] ;</span><br><span class="line">L[Top] = E[i].X ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Calc</span><span class="params">(LL i, LL j)</span> </span>&#123;<span class="keyword">return</span> Dp[j] + S[j + <span class="number">1</span>] * L[i] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Sloop</span><span class="params">(LL a, LL b, LL c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (B[c] - B[a]) * (A[b] - A[a] - (B[b] - B[a]) * (A[c] - A[a]) &gt;= <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) E[i].X = Read(), E[i].Y = Read() ;</span><br><span class="line">sort(E + <span class="number">1</span>, E + N + <span class="number">1</span>, CMP) ; Put_in_Stack() ; A[<span class="number">0</span>] = S[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Top ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Calc(i, Q[Head]) &gt;= Calc(i, Q[Head + <span class="number">1</span>]))</span><br><span class="line">Head ++ ;</span><br><span class="line">Dp[i] = Calc(i, Q[Head]) ; A[i] = S[i + <span class="number">1</span>] ; B[i] = Dp[i] ;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope (Q[Tail - <span class="number">1</span>], Q[tail], i)) Tail -- ;</span><br><span class="line">Q[++ Tail] = i ;</span><br><span class="line">&#125;Print(Dp[Top]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是关于动态规划的单调队列和斜率优化的相关内容，世界上动态规划的优化远不止如此，结合具体问题，动态规划还可以套上各种数据结构，比如四边形优化，线段树优化等等，笔者在这里介绍的只是比较常用的板子类的动态规划优化。具体的优化方式还要根据实际问题进行操作。</p>]]></content>
    
    <summary type="html">
    
      $$Dp[i]=a[i]+max_{l[i]&lt;=j&lt;=r[i]}~b[j]$$ $$d[i]+min_{j=1}^{j&lt;=i}(a[i]b[j]+c[j])$$很多动态规划的题目不仅仅要求正确性，还要求极快的速度，因此有时单纯的动态规划手段也可能超时，于是便需要一些适当的优化，本文主要浅略地谈一下使用单调队列或者斜率知识优化动态规划问题的手段。
    
    </summary>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="单调队列优化" scheme="http://Yeasion.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
      <category term="斜率优化" scheme="http://Yeasion.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
