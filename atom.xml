<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏·浅</title>
  
  <subtitle>Sue Shallow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Yeasion.github.io/"/>
  <updated>2019-03-09T13:09:22.344Z</updated>
  <id>http://Yeasion.github.io/</id>
  
  <author>
    <name>Sue Shallow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Noip2013]车站分级</title>
    <link href="http://Yeasion.github.io/2019/03/09/Noip2013-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/"/>
    <id>http://Yeasion.github.io/2019/03/09/Noip2013-车站分级/</id>
    <published>2019-03-09T12:42:52.000Z</published>
    <updated>2019-03-09T13:09:22.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1983" target="_blank" rel="noopener">Link</a><br>很脑缺的一道题，我也不知道自己为什么要整这个。<br>首先我们把题目转化一下，也就是在$i$车站之后没有停靠的火车站，其级别肯定都是低于$i$的级别。<br>于是我们有了一堆车站的大小关系，选择从小级别的车站像大级别的车站连边，然后跑一下拓扑排序就行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Train[MAXN][MAXN], S[MAXN], H[MAXN], Tot, Ans ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN], Link[MAXN][MAXN] ; <span class="keyword">int</span> Ind[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> F ; <span class="keyword">int</span> T ; <span class="keyword">int</span> Next ;&#125; E[MAXN &lt;&lt; <span class="number">10</span>] ;</span><br><span class="line"><span class="comment">//数组大小一定要开够，不然会爆炸.....</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span> <span class="keyword">int</span> Num ; <span class="keyword">int</span> Level ;&#125; G ;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node2&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Ind[i]) Q.push(&#123;i, <span class="number">1</span>&#125;) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;   </span><br><span class="line">        <span class="keyword">int</span> Now = Q.front().Num, L = Q.front().Level ;</span><br><span class="line">        Q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next) &#123;</span><br><span class="line">            Ind[E[i].T] -- ;</span><br><span class="line">            <span class="keyword">if</span> (! Ind[E[i].T]) Q.push(&#123;E[i].T, L + <span class="number">1</span>&#125;), </span><br><span class="line">                               Ans = max(Ans, L + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">        S[i] = Read() ;</span><br><span class="line">        <span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S[i] ; j ++)</span><br><span class="line">            Train[i][j] = Read(), V[Train[i][j]] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Train[i][<span class="number">1</span>] ; j &lt;= Train[i][S[i]] ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! V[j]) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= S[i] ; k ++)</span><br><span class="line">                <span class="keyword">if</span> (! Link[j][Train[i][k]]) &#123;</span><br><span class="line">                    Ind[Train[i][k]] ++ ;</span><br><span class="line">                    Add(j, Train[i][k]) ;</span><br><span class="line">                    Link[j][Train[i][k]] = <span class="number">1</span> ;</span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   Topo() ; <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给定$N$个车站，每个车站有每个车站的级别，规定一辆火车如果停靠在过了一个级别为$X$的车站，那么之后所有级别大于等于$X$的车站都要停靠。现在给出$M$个车次的停靠结果，问这$N$个火车站最少要分为多少个不同的级别才能使$M$个方案都合法。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Noip" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/Noip/"/>
    
    
      <category term="拓扑排序" scheme="http://Yeasion.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2014]数表</title>
    <link href="http://Yeasion.github.io/2019/03/08/SDOI2014-%E6%95%B0%E8%A1%A8/"/>
    <id>http://Yeasion.github.io/2019/03/08/SDOI2014-数表/</id>
    <published>2019-03-08T12:19:35.000Z</published>
    <updated>2019-03-09T13:36:00.905Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/solution/P3312" target="_blank" rel="noopener">Link</a><br>对于</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j))</script><p>这个式子来说，我们首先把它变换一下<br>改变枚举顺序</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ N \sum_{j = 1} ^ M [gcd(i,j) == d]</script><p>把$d$除过去</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} [gcd(i,j) == 1]</script><p>把最后的式子莫比乌斯反演一下</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} \sum _{x | i, x | j} \mu (x)</script><p>把$x$的枚举挪到前面去。</p><script type="math/tex; mode=display">\sum_{d = 1} ^{N} F(d) \sum _{x = 1} ^ {N / d}\mu (x) \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor</script><p>设$T = dx$，然后再变一下枚举顺序。</p><script type="math/tex; mode=display">\sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \sum_{d | T} F(d) \mu (\frac{T}{d})</script><p>然后发现出现了狄雷克利卷积，这就非常棒。然后我们记一个</p><script type="math/tex; mode=display">G(T) = \sum_{d | T} F(d) \mu (\frac{T}{d})</script><p>然后式子变成</p><script type="math/tex; mode=display">\sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor G(T)</script><p>这道题比较难的地方就在于其要求不大于$a$。于是我们将原来的$F(x)$函数加上一个$a$的限制。然后发现$F(d) \leq a$时对答案产生贡献。<br>对于随着$a$的变化而变化的$G(x)$，采取离线筛选然后升序排序的情况。<br>然后问题转化成了一个很熟悉的形式：</p><ol><li>每次加入$d$满足$F(d) \leq a$</li><li>查询前缀和。<br>然后我们就可以用树状数组来进行维护。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> Mod = (<span class="number">1L</span>L &lt;&lt; <span class="number">31</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> U[MAXN], F[MAXN], S[MAXN], P[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Sum[MAXN], Ans[MAXN], Tot, B[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N, M, A, Num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; Y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A &lt; Y.A ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   E[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node2 &amp; Y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> S[X] &lt; S[Y.X] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    S[<span class="number">1</span>] = U[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! B[i]) &#123;</span><br><span class="line">            P[Tot ++] = i ; U[i] = - <span class="number">1</span> ;</span><br><span class="line">            S[i] = i + <span class="number">1</span> ; F[i] = i + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0</span> ; j &lt; Tot ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * P[j] &gt; MAXN) <span class="keyword">break</span> ;</span><br><span class="line">            B[i * P[j]] = <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                U[i * P[j]] = <span class="number">0</span> ; </span><br><span class="line">                F[i * P[j]] = F[i] * P[j] + <span class="number">1</span> ;</span><br><span class="line">                S[i * P[j]] = S[i] / F[i] * F[i * P[j]] ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            U[i * P[j]] = - U[i] ; </span><br><span class="line">            F[i * P[j]] = P[j] + <span class="number">1</span> ;</span><br><span class="line">            S[i * P[j]] = S[i] * (P[j] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) G[i].X = i ;</span><br><span class="line">    sort(G + <span class="number">1</span>, G + MAXN + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123; <span class="keyword">return</span> Now &amp; (- Now) ; &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now, <span class="keyword">long</span> <span class="keyword">long</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Now &lt;= MAXN) &#123;</span><br><span class="line">        Sum[Now] = ((LL) Sum[Now] + K) % Mod ;</span><br><span class="line">        Now += Lowbit(Now) ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i * Now &lt;= MAXN ; i ++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; U[i] &lt;&lt; " " &lt;&lt; S[Now]&lt;&lt; " " &lt;&lt; (LL) U[i] * S[Now] % Mod &lt;&lt; endl ;</span></span><br><span class="line">        <span class="comment">// system("pause") ;</span></span><br><span class="line">        Add(Now * i, (LL) U[i] * S[Now] % Mod) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Query</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> Now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (Now &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Ans = ((LL) Ans + Sum[Now]) % Mod ;</span><br><span class="line">        Now &amp;= Now - <span class="number">1</span> ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Answer</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span>, ll = <span class="number">0</span>, rr ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r ; l &lt;= L ; l = r + <span class="number">1</span>, ll = rr) &#123;</span><br><span class="line">        r = min (L / (L / l), R / (R / l)) ;</span><br><span class="line">        rr = Query(r) ;</span><br><span class="line">        Ans = (Ans + ((LL) rr - ll) % Mod * (L / l) % Mod * (R / l) % Mod) % Mod;</span><br><span class="line">    &#125;   <span class="keyword">return</span> ((LL) Ans + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = Read() ; Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++) &#123;</span><br><span class="line">        E[i].N = Read(), E[i].M = Read(), E[i].A = Read() ;</span><br><span class="line">        <span class="keyword">if</span> (E[i].N &gt; E[i].M) swap(E[i].N, E[i].M) ;</span><br><span class="line">        E[i].Num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + T + <span class="number">1</span>) ; <span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= MAXN &amp;&amp; S[G[j].X] &lt;= E[i].A ; j ++)</span><br><span class="line">            Change(G[j].X) ;</span><br><span class="line">        Ans[E[i].Num] = Answer(E[i].N, E[i].M) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span> ; i &lt;= T ; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定$N$和$M$，$F(X)$表示$X$的约数和，求$$\sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j)) ~mod ~ 2 ^{31}$$
    
    </summary>
    
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="前缀和" scheme="http://Yeasion.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>[POI2011]MET-Meteors</title>
    <link href="http://Yeasion.github.io/2019/03/05/POI2011-MET-Meteors/"/>
    <id>http://Yeasion.github.io/2019/03/05/POI2011-MET-Meteors/</id>
    <published>2019-03-05T09:27:05.000Z</published>
    <updated>2019-03-05T09:37:31.309Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3527" target="_blank" rel="noopener">Link</a><br>考虑朴素算法，循环$K$次，每次循环$1$到$N$增加相应的$[L,R,A]$，然后$O(N)$判断某一个数是不是已经合法。这样的算法的时间复杂度是$O(N^3)$，那么我们考虑逐步优化。</p><ol><li>首先区间加我们肯定可以使用线段树或者树状数组，这里使用的是后者。</li><li>改换一下枚举顺序就可以变成先枚举每一个数，然后枚举$K$次，然后我们发现枚举$K$次的这个步骤是单调的，因为对于某一个数，如果在$X$次区间加之后没有合法，那么在之前肯定也是不合法的，如果在$X$次区间加之后是合法的，那么在这之后肯定也是合法的，所以这个枚举$K$的步骤是单调的，于是可以考虑二分答案。<br>那么总步骤就得出来了：<blockquote><ol><li>枚举每一个位置</li><li>二分区间加的次数</li><li>树状数组区间加</li></ol></blockquote></li></ol><p>总时间复杂度$O(Nlog^2N)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给定一个环，每个节点有一个所属国家，$K$次事件，每次对$[L,R]$区间上的每个点点权加上一个值$A$，求每个国家最早多少次操作之后所有点的点权和能达到一个特定值。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/POI/"/>
    
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="整体二分" scheme="http://Yeasion.github.io/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[NOI2010]超级钢琴</title>
    <link href="http://Yeasion.github.io/2019/03/03/NOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/"/>
    <id>http://Yeasion.github.io/2019/03/03/NOI2010-超级钢琴/</id>
    <published>2019-03-03T06:43:20.000Z</published>
    <updated>2019-03-04T09:39:52.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2048" target="_blank" rel="noopener">Link</a><br>我们先来考虑朴素算法：将所有的方案求出来，然后排序。但是这样当然是不可能过的。<br>对于某一个区间的综合我们肯定很自然地想到前缀和。<br>那首先定住一个左节点$X$，那么这个区间的右端点肯定处于$[X + L - 1, X + R - 1]$之间。<br>那么如果我们想要求这个区间里面的最大值，可以考虑使用询问时间复杂度为$O(1)$的$ST$表。<br>如果右端点为$Y$，那么区间的值就是$Sum[Y] - Sum[X]$，那么我们可以直接寻找右端点区间中的$Sum[i]$的最大值。<br>然后我们就得到了一堆区间的最大值，一共应该是$N - R + 1$，但是$K$是有可能大于这个数的，因此我们不能只求这个区间的最大值。<br>于是考虑将这个区间二分。<br>具体来说，就是首先将所有以$i$左端点，右端点在$[X + L - 1, X + R - 1]$的一个结构体存储到一个大根堆中，当然，本人使用的是单调队列，因为这样结构比较清晰。<br>然后循环$K$次，每次取出堆顶计入答案。<br>接下来的操作是以当前答案所处的右端点为中间，二分$[X + L - 1, X + R - 1]$这个区间，分别加入单调队列。因为如果想要寻找原来右端点区间中的第二大，第三大，我们选择去掉当前的最大值，然后将它的左边和右边分别入队，算法正确性就可以保证了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line">LL N, K, L, R, Muc[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  Sum[MAXN], Max[MAXN][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ST_BUILD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Max[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; (<span class="number">1</span> &lt;&lt; j) &lt;= N ; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Max[i][j - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">int</span> Y = Max[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[X] &gt; Sum[Y]) Max[i][j] = X ;</span><br><span class="line">        <span class="keyword">else</span> Max[i][j] = Y ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = log2(R - L + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> X = Max[L][T], Y = Max[R - (<span class="number">1</span> &lt;&lt; T) + <span class="number">1</span>][T] ;</span><br><span class="line">    <span class="keyword">return</span> Sum[X] &gt; Sum[Y] ? X : Y ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, L, R, P ;</span><br><span class="line">    Q() &#123;&#125; Q (<span class="keyword">int</span> X, <span class="keyword">int</span> L, <span class="keyword">int</span> R) : X(X), L(L), R(R), P(Query(L, R)) &#123;&#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Q &amp; A, <span class="keyword">const</span> Q &amp; B) &#123;</span><br><span class="line">            <span class="keyword">return</span> Sum[A.P] - Sum[A.X - <span class="number">1</span>] &lt; Sum[B.P] - Sum[B.X - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Q&gt; E ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), K = Read(), L = Read(), R = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        Muc[i] = Read() ;</span><br><span class="line">        Sum[i] = Sum[i - <span class="number">1</span>] + Muc[i] ;</span><br><span class="line">    &#125;   ST_BUILD() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (i + L - <span class="number">1</span> &lt;= N) </span><br><span class="line">            E.push(Q(i, i + L - <span class="number">1</span>, min(i + R - <span class="number">1</span>, N))) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = E.top().X, l = E.top().L, r = E.top().R, P = E.top().P ;</span><br><span class="line">        E.pop() ; Ans += Sum[P] - Sum[X - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (l != P) E.push(Q(X, l, P - <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (r != P) E.push(Q(X, P + <span class="number">1</span>, r)) ;</span><br><span class="line"></span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      定义超级和弦为区间内长度处于$[L,R]$之间的一段连续区间和。两个超级和弦相同当且仅当这两个超级和弦所包含的音符集合相同。要求在序列中选出K个不同的超级和弦，使得所有超级和弦的和最大。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="NOI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/NOI/"/>
    
    
      <category term="前缀和" scheme="http://Yeasion.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="堆" scheme="http://Yeasion.github.io/tags/%E5%A0%86/"/>
    
      <category term="ST表" scheme="http://Yeasion.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2009]粉刷匠</title>
    <link href="http://Yeasion.github.io/2019/03/03/SCOI2009-%E7%B2%89%E5%88%B7%E5%8C%A0/"/>
    <id>http://Yeasion.github.io/2019/03/03/SCOI2009-粉刷匠/</id>
    <published>2019-03-03T01:00:39.000Z</published>
    <updated>2019-03-03T06:39:22.631Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4158" target="_blank" rel="noopener">Link</a><br>2019的四川NOI题目，很经典的动态规划题目。<br>首先设$Dp[i][j][k][l]$表示当到达$(i,~j)$点的时候恰好用了$k$次粉刷的机会，其中$l$只有$0$和$1$两种取值，因为题目中说的一个格子如果没有被粉刷或者粉刷上了错误的颜色都算粉刷错误，因此我们可以将这两种情况分开来看，统一成$0$，如果粉刷对了就是$1$。<br>状态转移：<br>对于每一次换木板的时候要刷一次，那么最优情况下，也就是跟前一个木板完全一样的情况下，我们将上一块木板的$Dp$转移过来就可以了。记住要把$1$和$0$的状态都转移过来。</p><script type="math/tex; mode=display">Dp[i][j][k][0] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) ;</script><script type="math/tex; mode=display">Dp[i][j][k][1] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) + 1 ;</script><p>然后对于上一个格子和当前格子的颜色都一样的话，我们就像换行一样进行处理。将上一个格子的状态直接转移过来就可以了。</p><script type="math/tex; mode=display">Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1,</script><script type="math/tex; mode=display">Dp[i][j][k][0] = Dp[i][j - 1][k][0] ;</script><p>如果上一个格子的颜色与当前格子的颜色不一样，那么可以选择</p><ol><li>继续上一个格子的颜色，不减少机会，但是当前的格子就错误了。</li><li>减少一次机会，换一个k，当前的格子粉刷正确。<script type="math/tex; mode=display">Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ;</script><script type="math/tex; mode=display">Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ;</script>所以从思路上来说是非常简单的，只要你能想到是几维的Dp，接下来的转移方程基本是水到渠成的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">60</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">60</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">2510</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K, Color[MAXN][MAXM], Dp[MAXN][MAXM][MAXT][<span class="number">2</span>], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read(), K = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="built_in">string</span> A ; <span class="built_in">cin</span> &gt;&gt; A ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">            Color[i][j] = A[j - <span class="number">1</span>] - <span class="string">'0'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= K ; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) Dp[i][j][k][<span class="number">0</span>] = max(Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">0</span>], Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">1</span>]),</span><br><span class="line">                    Dp[i][j][k][<span class="number">1</span>] = max(Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">0</span>], Dp[i - <span class="number">1</span>][M][k - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (Color[i][j] == Color[i][j - <span class="number">1</span>])</span><br><span class="line">            Dp[i][j][k][<span class="number">1</span>] = Dp[i][j - <span class="number">1</span>][k][<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">            Dp[i][j][k][<span class="number">0</span>] = Dp[i][j - <span class="number">1</span>][k][<span class="number">0</span>] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Dp[i][j][k][<span class="number">1</span>] = max(Dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>, Dp[i][j - <span class="number">1</span>][k][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line">                Dp[i][j][k][<span class="number">0</span>] = max(Dp[i][j - <span class="number">1</span>][k][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        Ans = max(Ans, max(Dp[i][j][k][<span class="number">0</span>], Dp[i][j][k][<span class="number">1</span>])) ;</span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>没有写滚动数组，追求完美的当然可以滚动，但是不滚动数组也依然能过啦~。</p>]]></content>
    
    <summary type="html">
    
      粉刷$N$条木板，每条木板有$M$个格子，只能被涂成蓝色或者红色，每次粉刷只能选择一条木板上的一段连续的格子。每个格子最多只能被粉刷一次。最多能粉刷$T$次，求最多能粉刷多少个格子。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="http://Yeasion.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2009]虔诚的墓主人</title>
    <link href="http://Yeasion.github.io/2019/02/25/SDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA/"/>
    <id>http://Yeasion.github.io/2019/02/25/SDOI2009-虔诚的墓主人/</id>
    <published>2019-02-25T08:57:23.000Z</published>
    <updated>2019-03-03T06:39:46.889Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154" target="_blank" rel="noopener">Link</a></p><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><p>转化一下题目的要求，假设我们知道点$(i,j)$的上下左右的常青树的个数分别为$U[i][j]$，$D[i][j]$，$L[i][j]$和$R[i][j]$，那么依据一个很简单的组合数学我们知道：</p><script type="math/tex; mode=display">Ans = C_{K}^{U[i][j]} \times C_{K}^{D[i][j]} \times C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}</script><p>其中$C$为组合。基本的思路就是这样，但是我们要考虑优化。<br>从空间上来说，$1 \leq N, M \leq 1000000000$，肯定会直接爆炸（并且空间限制还是$128MB$）。题目并不要求十分确切的常青树位置，因此可以直接离散化。于是我们可以将坐标离散到一个$W \times W$的图中，因为$1 \leq W \leq 10000$，因此空间的问题就直接解决了。<br>然后是时间，对于每一个墓地，原始做法是$O(N^2)$的求出上下左右的四个数组，但是最终的时间复杂度是$O(N^4)$。于是对于优化来说这里用到一个<strong>扫描线</strong>的思想。<br>对于扫描线的具体讲解可以直接$Google$，这里只是针对题目讲方法罢了。<br>将所有的常青树按照$X$为第一关键字，$Y$为第二关键字的方法升序排序。<br>对于同一行的两个常青树，如果中间没有任何常青树，那么发现中间的所有的墓地的$L[i][j]$和$R[i][j]$都相等，因此只需要前缀和预处理出来</p><script type="math/tex; mode=display">\sum_{i}^{N} \sum_{j}^M C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}</script><p>即可，下面要求的就只剩下了$U[i][j]$和$D[i][j]$。</p><p>维护上下所有常青树的乘积，而左右乘积的改变次数就等于常青树的个数，而考虑其他行的时候上下乘积的改变次数也就是常青树的个数。</p><p>于是我们要维护上下组合数的乘积的区间和，这种维护显然就可以线段树或者树状数组。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>对于同一行的两个数$A$和$B$，$Ans += C_{k}^{L[A]} \times C_{k}^{R[B]}$，然后用树状数组维护$A$和$B$点的$C_{k}^{U[i]} \times  C_{k}^{D[i]}$的和。（省略掉了列，因为是同一行嘛）</p><p>答案实际上就是</p><script type="math/tex; mode=display">\sum C_{k}^{L[A]} \times C_{k}^{R[B]} \times \sum [C_{k}^{U[i]} \times  C_{k}^{D[i]}]</script><p>从左向右处理的时候，修改树状数组该点横坐标位置上的数值为</p><script type="math/tex; mode=display">C_{k}^{U[i]} \times C_{k}^{D[i]} - C_{k}^{U[i] + 1} \times C_{k}^{D[i] +1}</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7ffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">2147483647</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, W, K, S[MAXN], C[MAXN][<span class="number">11</span>] ;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN], Ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, L, R, U, D ;</span><br><span class="line">&#125;   E[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Sum[MAXN] ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Now &amp; ( - Now) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> Now, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Now &lt;= W) &#123;</span><br><span class="line">            Sum[Now] += K ;</span><br><span class="line">            Now += Lowbit(Now) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (Now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Ans += Sum[Now] ;</span><br><span class="line">            Now -= Lowbit(Now) ;</span><br><span class="line">        &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   Bit ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CMP</span><span class="params">(Node A, Node B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.Y != B.Y) <span class="keyword">return</span> A.Y &lt; B.Y ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.X &lt; B.X ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= min(K, i); j ++)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + W + <span class="number">1</span>, CMP) ;</span><br><span class="line">    <span class="keyword">int</span> Ken = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i - <span class="number">1</span>].Y) Ken ++ ;</span><br><span class="line">        <span class="keyword">else</span> Ken = <span class="number">1</span> ;  E[i].L = Ken ;</span><br><span class="line">        S[E[i].X] ++ ; E[i].U = S[E[i].X] ;</span><br><span class="line">    &#125;   Ken = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = W ; i &gt;= <span class="number">1</span> ; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i + <span class="number">1</span>].Y) Ken ++ ;</span><br><span class="line">        <span class="keyword">else</span> Ken = <span class="number">1</span> ; E[i].R = Ken ;</span><br><span class="line">        E[i].D = S[E[i].X] - E[i].U ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M = Read(), W = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        E[i].X = Read(), E[i].Y = Read() ;</span><br><span class="line">        X[i] = E[i].X ; Y[i] = E[i].Y ;</span><br><span class="line">    &#125;   K = Read() ;</span><br><span class="line">    sort(X + <span class="number">1</span>, X + W + <span class="number">1</span>) ;</span><br><span class="line">    sort(Y + <span class="number">1</span>, Y + W + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= W ; i ++) &#123;</span><br><span class="line">        E[i].X = lower_bound(X + <span class="number">1</span>, X + W + <span class="number">1</span>, E[i].X) - X ;</span><br><span class="line">        E[i].Y = lower_bound(Y + <span class="number">1</span>, Y + W + <span class="number">1</span>, E[i].Y) - Y ;</span><br><span class="line">    &#125;   Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= W ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> V = Bit.Query(E[i].X) - Bit.Query(E[i].X - <span class="number">1</span>) ;</span><br><span class="line">        Bit.Add(E[i].X, - V) ;</span><br><span class="line">        Bit.Add(E[i].X, C[E[i].U][K] * C[E[i].D][K]) ;</span><br><span class="line">        <span class="keyword">if</span> (E[i].Y == E[i - <span class="number">1</span>].Y)</span><br><span class="line">            Ans = Ans + C[E[i - <span class="number">1</span>].L][K] * C[E[i].R][K] * </span><br><span class="line">            (Bit.Query(E[i].X - <span class="number">1</span>) - Bit.Query(E[i - <span class="number">1</span>].X));</span><br><span class="line">    &#125;   <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans &amp; Mod) ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有人说可不可以搞一个二维线段树，思路上来说是可行的，但是空间上大概会爆炸吧~。<br>最后在冲浪的时候发现由于模数为$2147483647$所以可以自然溢出然后最后$ \&amp; 2147483646$就可以了。</p>]]></content>
    
    <summary type="html">
    
      在$N \times M$的墓地中，每一个墓碑的虔诚度为上下左右恰好有$K$棵常青树组成的十字架的个数，要求计算墓地中所有墓碑的虔诚度之和。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="树状数组" scheme="http://Yeasion.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="线段树" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="离散化" scheme="http://Yeasion.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="组合数学" scheme="http://Yeasion.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[POI2012]FES-Festival</title>
    <link href="http://Yeasion.github.io/2019/02/23/POI2012-FES-Festival/"/>
    <id>http://Yeasion.github.io/2019/02/23/POI2012-FES-Festival/</id>
    <published>2019-02-23T12:01:01.000Z</published>
    <updated>2019-03-09T13:38:18.034Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3530" target="_blank" rel="noopener">Link</a><br>看到题目首先肯定想到差分约束，当然这也是一个差分约束的题。<br>题目比较难想的地方在于建图，设$Dist[i][j]$表示$max\{A_i - A_j\}$，也就是$A_i$最多能比$A_j$大多少。那么根据题意我们知道对于第一种情况，应该是</p><script type="math/tex; mode=display">Dist[X][Y] = 1,~Dist[Y][X] = - 1</script><p>然后对于第二种情况，题目对数量上并没有限制，限制的只是大小关系，然而我们转化一下依然能知道$A_Y - A_X \geq 0$，对此我们选择从$Y$向$X$连一条边权为零的单项边，然后$Dist[Y][X] = 0$，对于这种情况我们连边的目的不是为了限制数值，而是为了限制关系，大小关系。<br>由于限制条件可以叠加，于是对于每一个建边都要取$min$。<br>然后首先要考虑的肯定是合法问题。稍加分析我们可以知道图如果存在<strong>非零环</strong>，肯定是不合法的，于是我们考虑判断非零环。<br>一般来说判负环就是简单地跑一遍$Spfa$然后记录每一个点入队的次数就可以解决。但是这个题有一点问题。就是这个图并不一定是联通的。所以不论以哪一个节点作为起点都是不能保证的。因此舍弃$Spfa$，观察数据发现$N \leq 600$非常的小，完全可以考虑$Floyed$，使用弗洛伊德的判断负环的方式就是看有没有$Dist[i][i] != 0$，然后弗洛伊德怎么解决问题了呢？<br>因为图并不是联通的，但是只要每一个强连通分量合法就可以了，于是我们考虑$Tarjan$缩点，然后对于每一个强联通分量分别求解。<br>在三重循环的过程中判断$i,j,k$是不是都属于一个强连通分量，然后就可以有一个小小的优化。<br>缩完点之后发现剩下的就是连接每一个联通块的零权边，对答案并没有影响，只会影响关系，并且我们设的$Dist[i][j]$表示的是$i,j$的最大差值，于是就可以寻找每一个强联通分量里面的最大值。并且每一个强联通分量在数值上没有关系，因此将答案直接累加即可，最后输出答案加上强连通分量的数量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RE register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">610</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">1000000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M1, M2, D[MAXN], H[MAXN], Tot ;</span><br><span class="line"><span class="keyword">int</span> Low[MAXN], Dfn[MAXN], B[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> S[MAXN], Top, Ken, Cnt, Ans ; </span><br><span class="line"><span class="keyword">bool</span> Insta[MAXN], Inq[MAXN], V[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Num[MAXN], Max, Dist[MAXN][MAXN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F, T, L, Next ;</span><br><span class="line">&#125;   E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F  = F, E[Tot].T = T ;</span><br><span class="line">    E[Tot].L = L ; E[Tot].Next = H[F] ; </span><br><span class="line">    H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Dfn[Now] = Low[Now] = ++ Ken ;</span><br><span class="line">    S[++ Top] = Now ; Insta[Now] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next) </span><br><span class="line">        <span class="keyword">if</span> (! Dfn[E[i].T]) &#123;</span><br><span class="line">            Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Insta[E[i].T]) Low[Now] = min(Dfn[E[i].T], Low[Now]) ;</span><br><span class="line">    <span class="keyword">if</span> (Dfn[Now] == Low[Now]) &#123;</span><br><span class="line">        Cnt ++ ; <span class="keyword">int</span> Pass ;</span><br><span class="line">        <span class="keyword">do</span> &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Insta[Pass] = <span class="literal">false</span> ;</span><br><span class="line">        &#125;   <span class="keyword">while</span> (Pass != Now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), M1 = Read(), M2 = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        Dist[i][j] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M1 ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Read(), Y = Read() ;</span><br><span class="line">        Add(X, Y, <span class="number">1</span>) ; Add(Y, X, - <span class="number">1</span>) ;</span><br><span class="line">        Dist[X][Y] = min(Dist[X][Y], <span class="number">1</span>) ;</span><br><span class="line">        Dist[Y][X] = min(Dist[Y][X],  - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Dist[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M2 ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Read(), Y = Read() ;</span><br><span class="line">        Add(Y, X, <span class="number">0</span>) ;</span><br><span class="line">        Dist[Y][X] = min(Dist[Y][X], <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[i]) Tarjan(i) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N ; k ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (B[k] == B[i])</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> (B[i] == B[j])</span><br><span class="line">        Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Dist[i][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"NIE"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> (B[i] == B[j])</span><br><span class="line">        D[B[i]] = max(D[B[i]], Dist[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (RE <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Ans += D[i] ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans + Cnt) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后发现弗洛伊德跑还是比较慢，最后加了很多$register$和$inline$才勉强卡过去。后来知道有一个非常神奇的深搜版$Spfa$，应该是可以更好地解决这个问题的。</p>]]></content>
    
    <summary type="html">
    
      给定多组限制，分为两类，分别为$$Ax +1 = Ay$$ $$Ax \leq Ay$$在使得等式成立的情况下，求这些数的取值的方案数为多少。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POI" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/POI/"/>
    
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Tarjan" scheme="http://Yeasion.github.io/tags/Tarjan/"/>
    
      <category term="Floyed" scheme="http://Yeasion.github.io/tags/Floyed/"/>
    
      <category term="差分约束系统" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>[国家集训队]墨墨的等式</title>
    <link href="http://Yeasion.github.io/2019/02/17/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%A2%A8%E5%A2%A8%E7%9A%84%E7%AD%89%E5%BC%8F/"/>
    <id>http://Yeasion.github.io/2019/02/17/国家集训队-墨墨的等式/</id>
    <published>2019-02-17T01:06:24.000Z</published>
    <updated>2019-03-09T13:53:15.480Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2371" target="_blank" rel="noopener">Link</a><br>题意大概就是求$B_l,B_r$范围内$B$的个数使等式</p><script type="math/tex; mode=display">\sum_{i = 1}^N a_Nx_N = B</script><p>存在非负整数解。其实转化一下题意也就是</p><blockquote><p>在N种物品中任意选择，物品有一个价值，使得最后的总价值处于给定区间内。</p></blockquote><p>这很显然是一个完全背包，而且是类似于一种模板题，但是这道题的数据范围是$B \leq 10^{12}$，因此这么做显然是不行的，但是我们可以从完全背包的视角出发思考题目。<br>我们取出最小的$a$为$a_{min}$,并且假设我们现在知道了一种方案，物体的总重为$D[i]$，并且满足<script type="math/tex">K ~mod~ a_{min} = i</script>，在这两种条件下$D[i]$为最小值。<br>那么显然，对于任意一个同样满足上述两个条件的总重X，$X \leq D[i]$，并且因为$X ~mod~ a_{min} = D[i] ~mod~ a_{min}$，所以可以知道$X$方案可以由$D[i]$方案加上若干个$a_{min}$得到。<br>现在我们考虑加入一个物体$Now$，那么有</p><script type="math/tex; mode=display">D[(i + Now) ~mod~ a_{min}]</script><p>可以从$d[i] + Now$而来。于是可以考虑从i向$(i + Now) ~mod~ a_{min}$连一条比边权为$Now$的边，而求$D[i]$的最小值也就被转化成了最短路问题。<br>那么算法就得出来了：</p><blockquote><ol><li>首先求一下$a_{min}$的最小值保存下来。</li><li>跑最短路，预处理出D数组。</li><li>枚举所有的D，计算mod T = i的数在区间$B_l,B_r$中有多少个。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500010</span> ;</span><br><span class="line">LL Inf = (LL)<span class="number">1</span> &lt;&lt; <span class="number">60</span> ;</span><br><span class="line"></span><br><span class="line">LL N, L, R, a[MAXN], H[MAXN], Tot, D[MAXM] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> F, T, L, Next ;&#125; E[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q ; <span class="keyword">bool</span> F[MAXM] ; LL K, Ans ;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ;</span><br><span class="line">    E[Tot].Next = H[F] ; H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; K ; i ++) D[i] = Inf ;</span><br><span class="line">    D[S] = <span class="number">0</span> ; F[S] = <span class="number">1</span> ; Q.push(S) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; F[Now] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> T = (Now + a[i]) % K ;</span><br><span class="line">            <span class="keyword">if</span> (D[T] &gt; D[Now] + a[i]) &#123;</span><br><span class="line">                D[T] = D[Now] + a[i] ;</span><br><span class="line">                <span class="keyword">if</span> (! F[T]) Q.push(T), F[T] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read(), L = Read(), R = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) a[i] = Read() ;</span><br><span class="line">    sort (a + <span class="number">1</span>, a + N + <span class="number">1</span>) ; K = a[<span class="number">1</span>] ; <span class="comment">//储存最小的a。</span></span><br><span class="line">    Spfa(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; K ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (D[i] != Inf) D[i] = (D[i] - i) / K ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; K ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (D[i] != Inf) &#123;</span><br><span class="line">            <span class="keyword">int</span> K1 = (L - i - <span class="number">1</span>) / K - D[i] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> K2 = (R - i) / K - D[i] + <span class="number">1</span> ;</span><br><span class="line">            Ans = Ans - max(K1, <span class="number">0</span>) + max(K2, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在求解用$\{a_i\}$能组成多少个在$B_l, B_r$范围内的数的问题其实是很经典的图论问题，像这种建图困难，但是最短路很好跑的题目便可以称为是建图题了。</p>]]></content>
    
    <summary type="html">
    
      给定$N$，${a_i}$一个正整数$B$的范围$B_l,B_r$，求$$\sum_{i = 1}^N a_Nx_N = B$$在$B_l,B_r$范围中有多少$B$使等式存在非负整数解。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="国家集训队" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[国家集训队]Crash的数字表格</title>
    <link href="http://Yeasion.github.io/2019/02/16/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
    <id>http://Yeasion.github.io/2019/02/16/国家集训队-Crash的数字表格/</id>
    <published>2019-02-16T03:35:36.000Z</published>
    <updated>2019-03-09T13:52:26.531Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1829" target="_blank" rel="noopener">Link</a><br>如题，给定$N$和$M$，求</p><script type="math/tex; mode=display">\sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)</script><p>有人说这道题是BZOJ上面的JZPTAB，但其实不是，JZBTAB虽然具体问题和改题是一样的，但是那道题是多组询问，比这道题还要难一些。<br>首先我们知道$lcm(i,j) = \frac{i \times j}{gcd(i,j)}$，那么题目转化为</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j=1}^M \frac{i \times j}{gcd(i,j)}</script><p>然后我们枚举最大公约数，式子转化为</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} \sum_{i = 1} ^ N \sum_{j = 1}^ M \frac{i \times j}{d} [gcd(i,j) == d]</script><p>提出d,式子变成</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d}[gcd(i, j) == 1] \times ij</script><p>并且我们知道</p><script type="math/tex; mode=display">\sum_{d|N}\mu (d) = [N == 1]</script><p>直接带入上面的式子可以得到</p><script type="math/tex; mode=display">\sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d} \sum_{x|gcd(i,j)} \mu (x) \times ij</script><p>保留前缀和$S[i]$，优先枚举$x$。</p><script type="math/tex; mode=display">\sum _{d = 1} ^ N d \sum_{x = 1}^{n / d} x ^ 2 μ (x) S(\frac {N}{dx}) S(\frac {M}{dx})</script><p>优先枚举$S$</p><script type="math/tex; mode=display">\sum_{dx = 1}^{N} S(\frac{N}{dx} S(\frac{M}{dx})dx \sum_{e|dx}e \mu(dx))</script><p>对于其中的$f(dx) = dx \sum_{e|dx}e \mu(dx)$可以线性筛，有式子</p><script type="math/tex; mode=display">f(dxp) = f(dx)f(p)</script><p>之后的式子可以整除分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">20101009</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, F[MAXN], P[MAXN], Tot ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN] ;<span class="keyword">int</span> Sum[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MOD</span> <span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Now &gt;= Mod) <span class="keyword">return</span> Now - Mod ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Now ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= min(N, M) ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) &#123;</span><br><span class="line">P[++ Tot] = i, F[i] = MOD (Mod + <span class="number">1</span> - i) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt;= min(N, M) ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) F[i * P[j]] = <span class="number">1L</span>L * F[i] * F[P[j]] % Mod ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">F[i * P[j]] = F[i] ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= min(N, M) ; i ++)</span><br><span class="line">F[i] = MOD(F[i - <span class="number">1</span>] + <span class="number">1l</span>l * F[i] * i % Mod) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= max(N, M) ; i ++)</span><br><span class="line">Sum[i] = MOD(Sum[i - <span class="number">1</span>] + i) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ; Init() ; Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= min(N, M) ; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(N / (N / l), M / (M / l)) ;</span><br><span class="line"><span class="keyword">int</span> Ans2 = MOD(F[r] - F[l - <span class="number">1</span>] + Mod) ;</span><br><span class="line">Ans = MOD(Ans + <span class="number">1L</span>L * Ans2 * Sum[N / l] % Mod * Sum[M / l] % Mod) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans % Mod) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的式子确实难推，但是时间复杂度化简到$O(N)$左右也就可以了，据说BZOJ上面的题目是真正的JZPTAB是多组数据，时间复杂度要推倒$O(\sqrt N)$才行。至于那种级别的题目，即使没有眼见为实，笔者也是有做不了的自知之明的…如果有想要了解的朋友还请另寻高就吧。</p>]]></content>
    
    <summary type="html">
    
      给定$N$和$M$，求$$\sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)$$
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="国家集训队" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得与扩展中国剩余定理ExCrt</title>
    <link href="http://Yeasion.github.io/2019/02/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt/"/>
    <id>http://Yeasion.github.io/2019/02/15/欧几里得与扩展中国剩余定理ExCrt/</id>
    <published>2019-02-15T07:27:39.000Z</published>
    <updated>2019-03-09T13:43:54.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>为什么要放欧几里得算法，因为这个玩意是扩展欧几里得的铺垫，为什么要将扩展欧几里得，因为这个玩意是中国剩余定理的铺垫。<br>很简单，就是要我们求$gcd(i,j)$。由于证明过程十分繁琐并且没有什么很大的意义，所以便不多管闲事地证明了，结论也很简单：$gcd(i,j) = gcd(j, i \% j)$。于是可以不断递归，直到j变成0，然后返回i就可以了，很常见的方法，直接放代码了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X ;</span><br><span class="line"><span class="keyword">return</span> Gcd(Y, X % Y) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>裴蜀定理是扩展欧几里得算法的第二个铺垫，也是一个关于最大公约数的定理。<br>假设有一个线性方程$ax + by = c$，问这个方程有没有整数解，那么根据裴蜀定理我们就知道当$gcd(a,b) | c$的时候线性方程才可能有整数解。简单的证明就是$gcd(a,b)$显然$|(ax+by)$。对于$gcd(a,b)|c$的情况有没有整数解我们便需要用到扩展欧几里得。</p><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>对于</p><script type="math/tex; mode=display">ax + by = gcd(a,b)</script><p>当$a &lt; 0$的时候，式子就可以变成</p><script type="math/tex; mode=display">|a| (-x) + by = gcd(|a|, b)</script><p>可以知道这个式子必然是有整数解的。我们可以对于$(a,b)$进行欧几里得算法，得到最大公约数，然后保存辗转相除法中的式子倒推便可以得到$ax + by = gcd(a,b)$的整数解。那么也就是证明了裴蜀定理，同时也给出了计算线性方程的整数解的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp; X, <span class="keyword">int</span> &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;X = <span class="number">1</span>, Y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line"><span class="keyword">int</span> R = Exgcd(b, a % b, X, Y) ;</span><br><span class="line"><span class="keyword">int</span> E = X ; X = Y ; Y = E - a / b * Y ;</span><br><span class="line"><span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>此算法称为扩展中国剩余定理，而中国剩余定理满足$m_i$之间两两互质，我们先从中国剩余定理说起。<br>还是使用上面的式子，假设方程组有解。那么我们设$M = \prod_{i = 1}^nm_i$，（当然也可以设$M = Lct({m_i})$，效果是一样的）且有n个$M_i = M / m_i$，也就是除了第i个以外其他n-1个$m_i$的乘积。以及$t_i = M_i^{-1}$，则我们知道</p><script type="math/tex; mode=display">t_iM_i \equiv 1 (mod ~ m_i)</script><p>于是有结论：方程组的通解形式为</p><script type="math/tex; mode=display">\sum _{i = 1}^n a_it_iM_i + kM</script><p>以上是通解形式，而通解有无数个，对于每一个解加上$kM$依然是方程组的解，其中$k \in Z$。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>关于证明，因为我们知道<script type="math/tex">t_iM_i \equiv 1 (mod ~ 1)</script><br>所以有</p><script type="math/tex; mode=display">a_it_iM_i \equiv a_i (mod ~ m_i)</script><p>而因为所有的$m_i$之间两两互质，因此对于除了$m_i$之外的所有的$m_j$都有</p><script type="math/tex; mode=display">a_it_iM_i \equiv 0 (mod ~ m_j)</script><p>因此</p><script type="math/tex; mode=display">x = \sum _{i = 1}^ n a_it_iM_i</script><p>满足</p><script type="math/tex; mode=display">x = a_i t_i M_i + \sum _{j ≠ i}a_j t_j+M j \equiv a_i + \sum_{j ≠ i} 0 \equiv a_i (mod ~ m_i)</script><p>因此，$x \equiv a_i (mod ~ m_i)$，所以$x$就是方程的一个特殊解。而至于为什么加上若干个$M$都是解我想就不用我再证明了吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN], m[MAXN], n ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) M *= m[i] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x, y ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> M_i = M / m[i] ;</span><br><span class="line">Exgcd(M_i, m[i], x, y) ;</span><br><span class="line">X = (X + M_i * x * a[i]) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (X + M) % M ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p>然后关于扩展中国剩余定理，相较之就是取消掉了$m_i$两两互质这个条件。<br>我们依然假设$M = \sum_{i = 1}^{k - 1} m_i$，那么假设我们已经知道了前$k-1$个式子的方程通解为$x + i <em> M$，那么在加入第i个方程后的通解，只消求出一个满足$x + t </em> M \equiv a_k (mod~m_k)$的$t$就可以。</p><script type="math/tex; mode=display">t \times M \equiv a_k - x~(mod ~ m_k)</script><p>直接欧几里得求解$t$即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[MAXN], B[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Exgcd</span><span class="params">(LL a, LL b, LL &amp; X, LL &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">X = <span class="number">1</span> ; Y = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line">LL R = Exgcd(b, a % b, X, Y), E = X ; </span><br><span class="line">X = Y ; Y = E - a / b * Y ;<span class="keyword">return</span> R ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Quick_Mul</span><span class="params">(LL X, LL Y, LL Mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;<span class="keyword">while</span> (Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = (Ans + X) % Mod ;</span><br><span class="line">X = (X + X) % Mod ; Y &gt;&gt;= <span class="number">1</span>  ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X, Y, M = B[<span class="number">1</span>], Ans = A[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">LL a = M, b = B[i], C = (A[i] - Ans % b + b) % b ;</span><br><span class="line">LL R = Exgcd(a, b, X, Y), E = b / R ;</span><br><span class="line"><span class="keyword">if</span> (C % R != <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span> ;</span><br><span class="line">X = Quick_Mul(X, C / R, E) ; Ans += X * M ;</span><br><span class="line">M = M * E ; Ans = (Ans % M + M) % M ;</span><br><span class="line">&#125;<span class="keyword">return</span> (Ans % M + M) % M ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line"> B[i] = Read(), A[i] = Read() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, Excrt()) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      欧几里得及其扩展算法用于计算最大公约数的有关问题。而扩展中国剩余定理用于计算给定$N$组非负整数$a_i$和$m_i$，求解关于$x$的方程组的最小非负整数解。两者在数论中军事很重要的算法。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="http://Yeasion.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="扩展欧几里得" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="扩展中国剩余定理" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>线性积分与傅里叶变换</title>
    <link href="http://Yeasion.github.io/2019/02/13/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://Yeasion.github.io/2019/02/13/线性积分与傅里叶变换/</id>
    <published>2019-02-13T07:17:33.000Z</published>
    <updated>2019-03-10T00:29:06.592Z</updated>
    
    <content type="html"><![CDATA[<p>文章被题目大致分为了两个部分：<strong>线性积分</strong>和 <strong>傅里叶变换</strong>。其实这么分实际上是不甚妥当的，因为傅里叶变换就是<strong>线性积分变换</strong>中的一种。如果要结合题目细讲，写起来怕是一个浩大的工程了，因此讲解的内容大多就仅止步于在信息学奥赛中的应用。当然，博主也会尽力深挖，争取让文章不只是初步。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很多人学快速傅里叶变换，学它的微分关系，学它的卷积特性，但是始终都没有思考过这个玩意是干嘛用的。毕竟本篇文章实际上想要讲的就是傅里叶变换，我们也首先要了解到傅里叶变换的作用是什么。</p><p>从数学上来说，傅里叶变换是用于解决两个多项式的 <strong>卷积</strong>，简单来说就是两个多项式相乘的次数，如果直接暴力计算，那么时间复杂度应该是$O(N^2)$，而快速傅里叶变换可以将时间复杂度降为$O(NlogN)$。这在时间维度上就体现了它宝贵的价值，因为多项式相乘的普遍性，复杂的快速傅里叶变换也渐渐走进人们的视野。</p><p>而从物理学或者工程学中，傅里叶变换的常见用途是 <strong>信号处理</strong>，而所属的<strong>信息与系统</strong>又是大学中大部分工科的基础，足以见其重要性。具体的讲就是 <strong>将给定信号把时间映射到振幅</strong>。而关于时间和频率的有关内容还请参考Heinrich关于傅里叶变换的教程：<a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程</a> ，例如其在讯号处理的经典应用就是将讯号分解为振幅分量和频率分量。</p><h2 id="线性积分变换"><a href="#线性积分变换" class="headerlink" title="线性积分变换"></a>线性积分变换</h2><blockquote><p><strong>积分变换</strong>是数学中作用于函数的<strong>算子</strong>，用以处理<strong>微分方程</strong>等问题。</p></blockquote><p>一个十分生涩的定义，我们假设当前有一个函数$f(x)$，将操作$T$表示为一个积分转换，而$f$经过此积分变换后的函数表示为$Tf(y)$：<script type="math/tex">Tf(y) = \int_{x_1}^{x_2}K(x, y)f(x) dx</script>。</p><p>其中$K()$是一个确定的含有两个参数的函数，称为此次<strong>积分变换</strong>的<strong>核函数</strong>（简称<strong>核</strong>）。而核使我们自己选择的，当我们选择不同的核函数$K()$或者积分域$(x_1,x_2)$就得到了不同的积分变换，这应该是很显然的。而相对应的，积分变换也有相对的<strong>反积分变换</strong>，也就是：<script type="math/tex">f(x) = \int_{y_1}^{y_2}K^{-1}(y, x)Tf(y)dy</script></p><p>其中$K^{-1}(y, x)$被称为<strong>反核</strong>。</p><p>而积分变换与反积分变换构成了<strong>傅里叶变换</strong>的框架，在傅里叶变换中，核函数为$\frac{e^{ixy}}{\sqrt{2 \pi}}$，其积分域为$-\infty, \infty$。</p><p>下面我们会从基础开始一步步地将傅里叶变换拆成我们好理解的东西。</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>我想来到这里的人肯定不需要我再讲这东西了，如果果真有人不会，还请自行维基。为了讲解需要，在此强调几个多项式的概念性内容：</p><blockquote><p>多项式的框架式形式：<script type="math/tex">\sum_{i = 0}^{N - 1}a_ix_i</script></p><p>若其最高次的非零系数为$a_k$，则该多项式的次数为k。</p><p>任何一个严格大于其次数的整数都是这个多项式的次数界。</p></blockquote><p>对于多项式的计算，加法显然很简单。<script type="math/tex">C(x) = A(x) + B(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i = \sum_{i = 1}^{N - 1}c_ix^i</script></p><p>只需要将对应次数的系数相加即可，我们可以在$O(N)$的时间复杂度内得到答案。</p><p>而对于多项式乘法，方法是将$A(x)$中的每一项与$B(x)$中的每一项相乘，之后合并同类项即可。<script type="math/tex">C(x) = \sum_{i = 0}^{2N - 2}c_ix_i</script>其中$c_i = \sum_{j = 0}^ia_jb_i-j$称为两个多项式的<strong>卷积</strong>，表示为$a \otimes b$</p><p>对于一个多项式来说我们有两种表示方法：<strong>系数表示法</strong>和<strong>点值表示法</strong>，其实两种表示方法应该是等价的，但是在计算上来说，对于点值表示的多项式，求解的时间复杂度是$O(N)$，这已经非常优秀，但是系数表示的多项式的暴力求解却是$O(N^2)$，而快速傅里叶变换就可以做到将系数表示的多项式在$O(NlogN)$的时间内求解。</p><p>对于点值表示的多项式求值运算的逆运算（已知点值表示的多项式求系数表示）称为<strong>插值</strong>，关于插值内容还请参照博主的另一篇博客：<a href="https://yeasion.github.io/2019/02/01/%E5%AF%B9%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E8%BF%90%E7%94%A8/">对插值法及拉格朗日插值多项式的初步理解运用</a>。</p><h3 id="单位复数根"><a href="#单位复数根" class="headerlink" title="单位复数根"></a>单位复数根</h3><blockquote><p>N次单位复数根$\omega$满足$\omega ^N = 1$</p></blockquote><p>定义很好理解，但是这一部分作为前置知识的内容实际上算是难点了。下图表示了$n$个单位复数根均匀的分布在以复平面的原点为圆心的单位半径的圆上。</p><p><img src="https://pic.superbed.cn/item/5c63f23f5f3e509ed958a959" alt="pic_Danweifushugen"></p><p>而这究竟是怎么理解呢？Heinrich的教程很形象的做了解释：</p><p>我们假设有一条长度为1的线段在一条数轴上，那么乘以-1之后的线段就与其相反，而$i = \sqrt{-1}$，那么我们将其乘以i的线段就在一个垂直的虚数轴上，于是我们就得到了一个由一个实数轴做x轴，一个虚数轴做y轴的<strong>复平面</strong>。</p><p>然后这里就可以引入另一个重要的公式：<strong>欧拉公式</strong>：$e^{ix} = cosx + i sinx$。运用这个式子我们就得到了上图的8次单位复数根，并且也知道<strong>n次单位复数根一共有n个</strong>。而这些单位根就是$e^{\frac{2 \pi i k}{n}}$我们把n次单位根的第m个写作$\omega_n^m$。</p><p>下面是单位复数根的几个性质或推论：</p><blockquote><ol><li>$\omega _{d \times n}^{d \times m} = \omega _n^m$，其中$d &gt; 0$</li><li>对于任何偶数$n&gt;0$有$\omega _n^{n/2} = \omega_2 = -1$ </li><li>对于偶数$n&gt;0$，n个n次单位复数根的平方的集合就是$\frac n2$个$\frac n2$次单位复数根的集合。</li><li>对于任意$n \geq1$ 和不能被n整除的非负整数k，有$\sum_{i = 0}^{N - 1}(\omega_n^m)^i = 0$</li></ol></blockquote><p>至于具体的证明就不再说了，都是很简单的推论，博友们大可自行脑补，权当是练习了。</p><h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>好了铺垫完所有的前置知识之后我们终于开始了傅里叶变换的内容。对于一个次数界为n的多项式$F(x) = \sum_{i = 1} ^{n - 1}a_ix^i$，我们在插值方面的知识可以知道n个点就可以确定这个多项式，那么我们同样也可以代入n次的n个单位复数根，来确定这个多项式，可以    求出其结果<script type="math/tex">k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}</script>。</p><p>而$y​$就被称为是系数向量a的<strong>离散傅里叶变换</strong>。</p><p>这个东西计算的时间复杂度依然是$O(N^2)$，那它到底有什么用处呢？这在算法上或许无法体现，但是它是傅里叶变换在时域和频域上都呈现离散的形式，具体依然可以参考Heinrich的讲解，使其在频谱分析和数据压缩等领域发挥了巨大优势。</p><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>也就是常说的<strong>FFT</strong>，可以说是对于DFT（离散傅里叶变换）在时间复杂度上的一大改进。</p><p>设多项式$F(x)$的系数向量$a(a_0, a_1, a_2…a_{n - 1})$，对于多项式$F(x) = \sum_{i = 0} ^ {n - 1}a_ix_i$来说，可以按照下标的奇偶性分为两个部分：</p><script type="math/tex; mode=display">F(x) = (a_0 + a_2x^2 +...+ a_{n - 2}x^{n - 2}) + (a_1 + a_3x^3...a_{n - 1}x^{n - 1})</script><p>我们设</p><script type="math/tex; mode=display">F_1(x) = a_0 + a_2x + a_4x^+...+ a_{n - 2}x^{\frac n2 - 1}</script><script type="math/tex; mode=display">F_2(x) = a_1 + a_3x + a_5x^+...+ a_{n - 1}x^{\frac n2 - 1}</script><p>则</p><script type="math/tex; mode=display">F(x) = F_1(x^2) + xF_2(x^2)</script><p>和离散傅里叶变换一样，我们把$\omega _n^k$代入得到</p><script type="math/tex; mode=display">F(\omega _n^k) = F_1(\omega _n^{2k}) + \omega _n^kF_2(\omega _n^{2k})</script><p>然后同理，将$\omega _n^{k + \frac n2}$代入可以得到：</p><script type="math/tex; mode=display">F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k + n}) - F(\omega _n^kF_2(F(\omega _n^{2k} \times \omega_n^n)</script><p>最后得到</p><script type="math/tex; mode=display">F(F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k}) - \omega _n^kF_2(\omega _n^{2k})</script><p>如此我们发现，两个式子化简后，只有一个常数项相反，其他都相同，于是再计算出第一个式子的时候我们可以$O(1)$求出第二个式子，并且发现两个式子将最初的范围缩小了一半，于是原问题缩小了一般，然后我们发现子问题也满足原问题性质，$k$与$k +\frac n2$同时取遍了(0, n - 1)，于是时间复杂度缩小到$O(NlogN)$。</p><p>这个算法在FFT的计算中最为常见，是在1965年由<strong>J.W.Cooley</strong>和<strong>J.W.Tuky</strong>提出的，因此也被称为<strong>Cooley-Tukey算法</strong>，实际上是基于分治的思想实现的，</p><h3 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h3><p>也称为傅里叶反变换，上文我们在线性积分变换中提到过反积分变换，而<strong>傅里叶反变换</strong>就是傅里叶变换的<strong>反积分变换</strong>，在数学中的意义是点值表示的多项式转化为系数表示，也就是说我们要从点值向量$(a_0, a_1, a_2…a_{n - 1})$得到系数向量$(y_0, y_1, y_2…y_{n - 1})$。则我们可以设$(y_0, y_1, y_2…y_{n - 1})$是$(a_0, a_1, a_2…a_{n - 1})$进行傅里叶逆变换后的结果，并<br>设有多项式$F(x) = \sum_{i = 0} ^{n - 1}y_0x^i$，<br>假设有向量$(c_0, c_1, c_2…c_{n - 1})$表示多项式在$\omega_n^0, \omega_n^{-1}…\omega_n^{1 - n}$上的点值表示，则向量c满足</p><script type="math/tex; mode=display">c_k = \sum_{i = 0} ^{n - 1}y_i(\omega_n^{-k})^i</script><p>然后我们考虑将式子展开。</p><script type="math/tex; mode=display">c_k = \sum_{i = 0} ^ {n - 1}y_i(\omega _n^{-k}) ^ i</script><script type="math/tex; mode=display">= \sum_{i = 0} ^ {n - 1}(\sum_{j = 0} ^ {n - 1}a_j(\omega _n^{j} k) ^ j)(\omega_n^{-k})^i</script><script type="math/tex; mode=display">= \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i ~=~ \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)</script><script type="math/tex; mode=display">= \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1}a_j(\omega_n^{j - k})^i ~=~ \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)</script><p>设一个式子</p><script type="math/tex; mode=display">S(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^i</script><p>在两边同时乘一个$\omega_n^k$得：</p><script type="math/tex; mode=display">\omega_n^kS(\omega_n^k)  = \sum_{i = 0} ^{n - 1}(\omega_n^k)^{(i+1)}</script><p>将前后两个式子相减，得到</p><script type="math/tex; mode=display">\omega _n^kS(\omega_n^k) - S(\omega _n^k) = (\omega_n^k)^n - 1</script><script type="math/tex; mode=display">S(\omega _n^k) = \frac {(\omega_n^k)^n - 1}{\omega_n^k - 1}= 0</script><p>则当$k = 0$的时候，其值为0</p><p>而原来的式子</p><script type="math/tex; mode=display">c_k = \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0} ^ {j - k})^i = \sum_{j = 0} ^ {n-1}a_jS(\omega_n^{j - k})</script><p>当$j = k$的时候$S = n$，否则$S = 0$，所以<script type="math/tex">a_i = \frac 1n c_i</script></p><p>这样我们得到了点值和系数的关系式，所以，从结论来说，将单位根幂上-1，然后做一次快速傅里叶变换，将结果的数除以n就是傅里叶逆变换的结果。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>一般的分治都会采用递归操作实现，但是在FFT中递归实现的效率比较低，所以大多数情况下采用迭代操作实现。我们观察二进制下的序列规律<br><img src="https://pic.superbed.cn/item/5c6522ae5f3e509ed96baca2" alt="pic"><br>发现分治到边界条件的时候每个数的下标等于原下标的二进制翻转，于是我们省去了分奇偶的操作，直接枚举每一个二进制位，然后向上合并就可以了。下面是迭代操作实现的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span> ; <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; l) &lt; N) l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"> <span class="keyword">int</span> T = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; l ; j ++)</span><br><span class="line"> <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) T /= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>)) ;</span><br><span class="line"> <span class="keyword">if</span> (i &lt; t) swap(a[i], a[T]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>我们把$\omega_n^k$称为<strong>旋转因子</strong>并保留下来，进入两个向量$a_k^0$和$a_k^1$时，旋转因子$\omega_n^k$乘以$a_k^1$，输出与$a_k^0$的和与差，这一个操作被称为<strong>蝴蝶操作</strong>。那这个东西究竟有什么作用呢？</p><p>重新考虑我们向上合并两个子问题时，假设有$A_1(\omega_{n/2}^k)$储存在$a(k)$中，$A_2(\omega _{n/2}^k)$储存在$a(k +\frac n2)$中，并且这两个值将要被储存在$b(k)$和$b(k + \frac n2)$中，则合并的操作可以如下表示：</p><script type="math/tex; mode=display">b(k) ← a(k) + a(k +\frac n2) \times\omega_n^k</script><script type="math/tex; mode=display">b(k +\frac n2) ← a(k) - a(k +\frac n2) \times\omega_n^k</script><p>于是我们考虑将两个值存放在原来的a中，取消b数组的存在，但是需要覆盖原来的值，所以就需要一个临时变量T。</p><script type="math/tex; mode=display">T ←a(k +\frac n2) \times\omega_n^k</script><script type="math/tex; mode=display">a(k +\frac n2) ← a(k) - T</script><script type="math/tex; mode=display">a(k) ← a(k) - T</script><p>名字很好听，其实操作很简单，仅仅有一行而已。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, l, r[MAXN], L = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    <span class="keyword">complex</span> (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;x = xx, y = yy ;&#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x + b.x , a.y + b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x - b.x , a.y - b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a, <span class="keyword">complex</span> b) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.x * b.x - a.y * b.y , a.x * b.y + a.y * b.x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> *A, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++) <span class="keyword">if</span> (i &lt; r[i]) swap(A[i], A[r[i]]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span> ; Mid &lt; L ; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">W</span><span class="params">(<span class="built_in">cos</span>(Pi / Mid), type * <span class="built_in">sin</span>(Pi / Mid))</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = Mid &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; L ; j += R) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; Mid ;k ++, w = w * W) &#123;</span><br><span class="line">    <span class="keyword">complex</span> x = A[j + k], y = w * A[j + Mid + k] ;</span><br><span class="line">    A[j + k] = x + y ; A[j + Mid + k] = x - y ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = Read(), M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; i ++) a[i].x = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i ++) b[i].x = Read() ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= N + M) L &lt;&lt;= <span class="number">1</span>, l ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++)</span><br><span class="line">r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">FFT (a, <span class="number">1</span>) ; FFT (b, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; i ++) a[i] = a[i] * b[i] ; </span><br><span class="line">    FFT(a, - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N + M ; i ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(a[i].x/ L + <span class="number">0.5</span>)) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h5 id="同济高等数学，"><a href="#同济高等数学，" class="headerlink" title="同济高等数学，"></a>同济高等数学，</h5><h5 id="Thomas-H-Cormen算法导论，"><a href="#Thomas-H-Cormen算法导论，" class="headerlink" title="Thomas H.Cormen算法导论，"></a>Thomas H.Cormen算法导论，</h5><h5 id="Miskcoo-从多项式乘法到快速傅里叶变换，"><a href="#Miskcoo-从多项式乘法到快速傅里叶变换，" class="headerlink" title="Miskcoo 从多项式乘法到快速傅里叶变换，"></a><a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-10" target="_blank" rel="noopener">Miskcoo 从多项式乘法到快速傅里叶变换</a>，</h5><h5 id="郭晓旭-FFT讲义，"><a href="#郭晓旭-FFT讲义，" class="headerlink" title="郭晓旭 FFT讲义，"></a><a href="https://pan.baidu.com/wap/album/file?uk=3325080974&amp;album_id=2474841267539644259&amp;fsid=845742707277510&amp;adapt=pc&amp;fr=ftw" target="_blank" rel="noopener">郭晓旭 FFT讲义</a>，</h5><h5 id="维基百科-傅里叶变换，"><a href="#维基百科-傅里叶变换，" class="headerlink" title="维基百科 傅里叶变换，"></a><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">维基百科 傅里叶变换</a>，</h5><h5 id="白霂凡-Fast-Fourier-Transform，"><a href="#白霂凡-Fast-Fourier-Transform，" class="headerlink" title="白霂凡 Fast Fourier Transform，"></a><a href="https://zhuanlan.zhihu.com/p/31584464" target="_blank" rel="noopener">白霂凡 Fast Fourier Transform</a>，</h5><h5 id="Menci-FFT学习笔记，"><a href="#Menci-FFT学习笔记，" class="headerlink" title="Menci FFT学习笔记，"></a><a href="https://oi.men.ci/fft-notes/" target="_blank" rel="noopener">Menci FFT学习笔记</a>，</h5><h5 id="Heinrich-傅里叶分析之掐死教程，"><a href="#Heinrich-傅里叶分析之掐死教程，" class="headerlink" title="Heinrich 傅里叶分析之掐死教程，"></a><a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">Heinrich 傅里叶分析之掐死教程</a>，</h5><h5 id="attack-快速傅里叶变换-FFT-详解"><a href="#attack-快速傅里叶变换-FFT-详解" class="headerlink" title="attack 快速傅里叶变换(FFT)详解"></a><a href="http://www.cnblogs.com/zwfymqz/p/8244902.html" target="_blank" rel="noopener">attack 快速傅里叶变换(FFT)详解</a></h5>]]></content>
    
    <summary type="html">
    
      $$k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}$$ $$C(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i$$ 如何快速求两个多项式的卷积以及线性积分变换的基本内容。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="傅里叶变换" scheme="http://Yeasion.github.io/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="线性积分变换" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2015]约数个数和</title>
    <link href="http://Yeasion.github.io/2019/02/13/SDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
    <id>http://Yeasion.github.io/2019/02/13/SDOI2015-约数个数和/</id>
    <published>2019-02-13T02:55:53.000Z</published>
    <updated>2019-03-09T13:39:26.839Z</updated>
    
    <content type="html"><![CDATA[<p>如题，设$d(x)$表示$x$的约数个数，求<script type="math/tex">\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)</script><br>首先要知道约数个数的一种表示方法：<script type="math/tex">d(i,j) = \sum_{x|i} \sum_{y_j}[gcd(x,y) == 1]</script><br>然后题目所求就变成了</p><script type="math/tex; mode=display">\sum_{i = 1}^N \sum_{j = 1}^M \sum_{k | i} \sum_{l | j}[gcd(k,l) == 1]</script><p>化简，改变量之后式子变为</p><script type="math/tex; mode=display">\sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == 1)(\frac Mi)(\frac Mj)</script><p>考虑莫比乌斯反演,设</p><script type="math/tex; mode=display">f(X) = \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == x)(\frac Ni)(\frac Mj)</script><script type="math/tex; mode=display">F(x) = \sum_{x|n}f(n)</script><script type="math/tex; mode=display">→ F(x) = \sum_{i = }^N \sum_{j = 1}^{N / x}(x|gcd())(\frac Ni)(\frac Mj)</script><script type="math/tex; mode=display">→ F(x) = \sum_{i = }^N \sum_{j = 1}^{M / x}(\frac {N}{ix})(\frac {M}{jx})</script><p>考虑优化算法时间复杂度，可以预处理出$\sum_{i = 1}^N(\frac Ni)$和$\sum_{j = 1}^M (\frac Mj)$，连带着莫比乌斯函数可以直接O(N)预处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题答案化简为$f(1)$。反演后得到<script type="math/tex">f(1) = \sum{x = 1}^N \mu (x) F(x)</script></p><script type="math/tex; mode=display">= \sum_{x = 1}^N \mu(x) \sum_{i = 1}^{N/x} \sum _{j = 1}^{M / x} (\frac Ni) (\frac Mj)</script><p>进行数论分块就可以了，总体时间复杂度$O(T\sqrt N)$，其中T为数据组数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, U[MAXN], P[MAXN], Tot ;</span><br><span class="line"><span class="keyword">int</span> S[MAXN], Sum[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line"><span class="keyword">bool</span> V[MAXN] ;<span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">U[<span class="number">1</span>] = F[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) V[i] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[i]) U[i] = - <span class="number">1</span>, P[++ Tot] = i, F[i] = <span class="number">2</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="literal">false</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j] == <span class="number">0</span>) &#123;</span><br><span class="line">U[i * P[j]] = <span class="number">0</span> ;</span><br><span class="line">F[i * P[j]] = F[i] / (G[i] + <span class="number">1</span>) * (G[i] + <span class="number">2</span>) ;</span><br><span class="line">G[i * P[j]] = G[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; <span class="number">1</span>), G[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MAXN ; i ++) </span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + U[i], Sum[i] = Sum[i - <span class="number">1</span>] + F[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T = Read() ; Init () ;</span><br><span class="line"><span class="keyword">while</span> (T --) &#123;Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= min(N, M) ; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(N / (N / l), M / (M / l)) ;</span><br><span class="line">Ans += <span class="number">1l</span>l * (S[r] - S[l - <span class="number">1</span>]) * Sum[N / l] * Sum[M / l] ;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设$d(x)$为$x$的约数个数，给定$N$，$M$，求$$\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)$$
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="数论 莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演初步与实际应用</title>
    <link href="http://Yeasion.github.io/2019/02/02/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%88%9D%E6%AD%A5%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/02/02/莫比乌斯反演初步和实际应用/</id>
    <published>2019-02-02T01:48:43.000Z</published>
    <updated>2019-03-10T00:20:57.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫比乌斯反演初步和实际应用"><a href="#莫比乌斯反演初步和实际应用" class="headerlink" title="莫比乌斯反演初步和实际应用"></a>莫比乌斯反演初步和实际应用</h1><h3 id="定义和一般形式及其证明"><a href="#定义和一般形式及其证明" class="headerlink" title="定义和一般形式及其证明"></a>定义和一般形式及其证明</h3><blockquote><p>假设有数论函数关系式$F(N) = \sum_{x|N}f(x)$，则有$f(N) = \sum_{x|N}\mu(x)F(\frac Nx) = \sum_{x|N}\mu(\frac xN)F(x)$</p></blockquote><p>此为基本定义，但是看到这个函数也有限制就是必须是数论函数。，也就是定义域为正整数，对应集合为复数的函数。下面是函数的一般形式。</p><blockquote><p>假设d定义在$[1,∞)$上的复值函数$G(N) = \sum_{x = 1}^NF(\frac Nx)$，则有$F(N) = \sum_{x = 1}^N\mu(x)G(\frac Nx)$</p></blockquote><p>而这个$\mu(x)$函数就是莫比乌斯函数，其定义如下：</p><blockquote><p>$x= 1$时，$\mu(x) = 1$。</p><p>$x = P_1P_2…P_M$，（$P$为互异素数），则$\mu(x) = (-1)^M$</p><p>其他情况下$\mu(x) = 0$</p></blockquote><p>由定义可以得到莫比乌斯函数的两个重要性质：</p><blockquote><p><img src="https://img-blog.csdn.net/20140416161656796" alt="pic"></p><p>对任意<strong>正整数</strong>$N$有$\sum_{x|N}\frac{\mu(x)}{x} = \frac{\varphi(N)}{N}$</p></blockquote><p><strong>证明 :</strong></p><p>设有</p><script type="math/tex; mode=display">\sum_{x|N}\mu(x) = [N = 1], f(N) = \sum_{x|N}[\frac Nx = 1]f(x)</script><p>代入得</p><script type="math/tex; mode=display">f(N) = \sum_{x|N}\sum_{y|\frac Nx}\mu(y)f(x)</script><p>由于$\sum_{x|N}\sum_{y|\frac Nx}$的限制条件为$xy|N$，所以等式写成:</p><script type="math/tex; mode=display">f(N) = \sum_{y|N}\mu(y)\sum_{x|\frac Ny}f(x) = \sum_{y|N}\mu(y)F(\frac Ny)</script><p>证明完毕。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用线性筛法求莫比乌斯函数，时间复杂度$O(N)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[++ Tot] = i, Mu[i] = - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= Tot &amp;&amp; P[j] &lt; N ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i] ;</span><br><span class="line"><span class="keyword">else</span> &#123;Mu[i * P[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：YY的GCD"><a href="#例题：YY的GCD" class="headerlink" title="例题：YY的GCD"></a>例题：YY的GCD</h3><blockquote><p>给定$N, M$，求所有的$X \leq N,~Y \leq M$中$gcd(X, Y)$是质数的点对有多少对。</p></blockquote><p>类似于一个模板题，因为其思维难度不是很大。考虑公式化题目描述，即求：<script type="math/tex">\sum_{X = 1}^N \sum_{Y = 1}^M [gcd(i,j) == P]</script></p><p>设$f(x)​$为满足$gcd(X, Y) = X​$的$(X, Y)​$的对数，$F(X)​$为满足$X|gcd(X, Y)​$二点$(X, Y)​$的对数。得到</p><script type="math/tex; mode=display">F(N) = \sum_{x|N}f(x)​</script><p>所以根据莫比乌斯反演定理，得​</p><script type="math/tex; mode=display">f(N) = \sum_{x|N}\mu(\frac xN)F(x) =\sum_{x|N}\mu(\frac xN)\frac{N \times M}{X^2}​</script><p>而题目要求其$gcd(X,Y)$是一个质数也就是说</p><script type="math/tex; mode=display">Ans = \sum_P^{min(N, M} \sum_i^N\sum_j^M[gcd(i,j) = P] = \sum_P^{Minn(N,M)}f(P)</script><p>设$T = PX$，则式子变为</p><script type="math/tex; mode=display">\sum_{T = 1}^{Min(N,M)}\frac{N \times M}{T^2}(\sum_{G|T}\mu(\frac TG))</script><p>于是为了提高速度，可以预处理$\sum_{G|T}\mu(\frac TG)$。于是此题就以较快得速度解决了。</p><p>但是如果是多组数据还是有可能会$TLE$，所以如果想要更快，还可以使用整除分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T, N, M, V[MAXN], P[MAXN], Mu[MAXN], Tot ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S[MAXN], Ans, G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(V, <span class="number">0</span>, <span class="keyword">sizeof</span>(V)) ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span> ; Tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXN ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! V[i]) P[Tot ++] = i, Mu[i] = - <span class="number">1</span>, G[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123;</span><br><span class="line">V[i * P[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % P[j]) Mu[i * P[j]] = - Mu[i],</span><br><span class="line">G[i * P[j]] = Mu[i] - G[i] ; <span class="keyword">else</span> &#123;</span><br><span class="line">Mu[i * P[j]] = <span class="number">0</span> ; G[i * P[j]] = Mu[i] ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i ++) S[i] = S[i - <span class="number">1</span>] + G[i] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MU() ;</span><br><span class="line">T = Read() ; <span class="keyword">while</span> (T --) &#123; </span><br><span class="line">Ans = <span class="number">0</span> ;</span><br><span class="line">N = Read(), M = Read() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= min(N, M) ; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">j = min(N / (N / i), M / (M / i)) ;</span><br><span class="line">Ans += (N / i) * (M / i) * (S[j] - S[i - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      $$F(N) = \sum_{x|N}f(x)$$ $$f(N) = \sum_{x|N}\mu(x)F(\frac Nx)$$ 在数论中占有重要地位的莫比乌斯反演，可以大大简化运算。本文初步探析莫比乌斯函数的定义，证明和代码实现。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="http://Yeasion.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>插值法及拉格朗日插值多项式</title>
    <link href="http://Yeasion.github.io/2019/02/01/%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    <id>http://Yeasion.github.io/2019/02/01/插值法及拉格朗日插值多项式/</id>
    <published>2019-02-01T12:26:21.000Z</published>
    <updated>2019-03-09T13:45:33.607Z</updated>
    
    <content type="html"><![CDATA[<p>$Interpolation$：<br>“插值”，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。</p><h2 id="一：什么是插值"><a href="#一：什么是插值" class="headerlink" title="一：什么是插值"></a>一：什么是插值</h2><p>插值是属于数学数值分析领域的内容，常被称作<strong>内插</strong>或者<strong>插值</strong>。接下来给出定义：</p><blockquote><p>给定N个数据离散点$(x_k,y_k)$，其中$k = 1,2,3…N$。对于$x$求$x$对应的$y$值叫做内插。</p><script type="math/tex; mode=display">L_n(x) = \sum_{k = 0}^ny_kl_k(x)</script><p>定义域在区间$[A,B]$上有意函数$F$，已知函数$G$在$[A,B]$范围内满足$G(x_i) = F(x_i) = 1,2…N$</p><p>则称$G(x)$为$F(x)$关于节点${x_i}_{i = 0}^N$上的插值函数。</p></blockquote><p>假设我们已经求得$x_i$集合中的最大值$MAX$和最小值$MIN$</p><blockquote><p>用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in (MIN, MAX)$处的近似值的方法称为内插法。</p><p>用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in [A, B]$但$x \notin [MIN, MAX]$处的近似值的方法称为外插法。</p></blockquote><p>那么你现在已经基本了解了什么是插值，下面我们来看一些关于插值方法的东西。</p><h2 id="二：插值方法简介"><a href="#二：插值方法简介" class="headerlink" title="二：插值方法简介"></a>二：插值方法简介</h2><h3 id="1-片段插值"><a href="#1-片段插值" class="headerlink" title="1.片段插值"></a>1.片段插值</h3><p>这种插值方法几乎不能算是插值了，所实话如果没有维基百科编者根本就不知道有这种插值方法以及这样也能算是插值。</p><p>简单来说就是找到离$x$最近的采样点$x_i$，然后将$y$值分配为$y_i$。因此它的别称就是<strong>最近邻插值</strong>。但是就和wiki说的一样，这种插值方法是几乎碰不到的，因为出不了什么很高深的符合当前阶段学习的题目，但同时如果可以使用这种方法，无疑将使时间和复杂性都大大降低。</p><h3 id="2-线性插值"><a href="#2-线性插值" class="headerlink" title="2.线性插值"></a>2.线性插值</h3><p>这种插值从某种意义上说是利用了斜率，但实际上就是很简单的取平均值而已。</p><p>假设我们已知了所有自然数采样点${x_i}$，而我们要求的插值点是$x_{i+0.5}$,那么发现当前插值点是处于$x_i和x_{i+1}$之间，那么我们取的分配值就是$\frac{y_i+y_{i + 1}}{2}$。以数学公式的方法表达就是：</p><blockquote><p>$y = y_a + (y_b - y_a) \frac{x - x_a}{x_b - x_a}$</p><p>$G(x) = y_a \frac{x - x_b}{x_a - x_b} + y_b \frac{x - x_a}{x_b - x_a}$</p></blockquote><p>发现$G(x)$实际上是两个一次多项式的组合。也就是说，我们过这两个点分别作一次多项式$l_a = \frac{x - x_b}{x_a - x_b},~l_2 =  \frac{x - x_a}{x_b - x_a}$，那么$G(x) = y_al_a + y_bl_b$。</p><p>而实际上上述两种插值方法都存在误差，撇开片段插值不谈，线性插值的误差来源只要是因为插值点$x_k$是不可微分的，而计算得出的误差是$|F(x) - G(x)| \leq C(x_b - x_a)^2~where~C= \frac18max_{r \in[x_a, x_b]}|g^{‘’}(r)|$</p><p>其与数据点的距离平方成正比。</p><p>我们发现前两者的不同在于第一个找到了一个采样点进行插值，而线性插值则找到了两个点，因为两点确定一个一次函数。相同的，我们也有三点确定的二次函数的抛物线插值法，这里不再进行分析。</p><h3 id="3-多项式插值"><a href="#3-多项式插值" class="headerlink" title="3.多项式插值"></a>3.多项式插值</h3><blockquote><p>已知函数$F(x)$在$[A, B]$上$N + 1$个点处的函数值$\{y_i\}_{i = 0}^N$，求次数不超过$N$的多项式$G(x) = c_0 +c_1x+…+c_Nx^N$使得$G(x) = F(x)$称为多项式插值。</p></blockquote><p><strong>定理</strong>：多项式插值函数存在且唯一：我们都知道过$N + 1$个点做一个$N$次函数最多只能做一个，而做一个$≥N$次的函数却可以有无数个。</p><h2 id="三：拉格朗日插值法"><a href="#三：拉格朗日插值法" class="headerlink" title="三：拉格朗日插值法"></a>三：拉格朗日插值法</h2><p>建立插值多项式的方法（简称为插值法）最基本的是需要求解线性方程组，而这是最为冗杂，最为复杂的算法，一般没有特殊情况是不会用这种方法构造插值多项式的。因此经过前人的努力，引入了一种更为简单，实现更为便捷的插值法：拉格朗日插值法。与之相通的有牛顿插值法，而我们又知道多项式插值函数的唯一性，因此恒有$L_n(x) = N_n(x)$。（L：拉格朗日，N：牛顿）。</p><p>在准备好了解拉格朗日插值法之前，我们先引入一个基函数的概念。</p><p>记$H_n(x)$为次数不超过$N$的多项式全集，也就是有$H_0(x),H_1(x)…H_n(x)$，设其构成$H_n(x)$的一组基，则插值多项式可表示为$G(x) = a_0H_0(x) + … + a_nH_n(x)$。</p><p>那么我们只要寻找到合适的基函数和插值多项式在这组基下的线性表示系数，就可以通过基函数构造插值多项式，也就是<strong>基函数插值法</strong>。</p><p>回到拉格朗日插值上来，我们首先寻找基函数。</p><blockquote><p>设$l_k(x)$是$n$次多项式，在节点$x_0，x_1…x_n$上满足$l_k(x_i) = 1 ~(i  = k)$或$l_k(x_i) = 0~(i ≠ k)$，则称$l_k(x)$为节点$\{x_i\}_{i = 0}^N$上的$n$次拉格朗日插值基函数。</p></blockquote><p>构造法可以知道$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$</p><p>知道基函数之后我们用基函数求$G(x) = a_0l_0(x) + … + a_nl_n(x)$，带入$G(x_i) = y_i$可得</p><p>$L_n(x) = \sum_{k = 0}^ny_kl_k(x)$</p><p>上方的$L_n(x)$就是我们的拉格朗日插值多项式，具有结构清晰紧凑的特点，是用于理论分析的一般手法。根据插值误差估计定理可以估计出误差为：$\frac{y_{n + 1}(ζ)}{(n + 1) !} \omega_{n+1}(x)$，其小于$\frac{M_{n+1}}{(n+1)!}|\omega_{n+1}|(x)$。</p><h2 id="重心拉格朗日插值法"><a href="#重心拉格朗日插值法" class="headerlink" title="重心拉格朗日插值法"></a>重心拉格朗日插值法</h2><p>按照维基百科说的，这是对拉格朗日插值法的一种改进。当然，指的是速度上的，误差方面并没有什么差别。</p><p>按照均摊来说，如果用朴素拉格朗日插值法求插值函数，时间复杂度是$O(N^2)$，而中心拉格朗日插值法可以将时间复杂度压缩到$O(N)$。讲了整整一个量级，不可谓不改进。但从大多数方面来说，朴素拉格朗日也足足够用了。</p><p>实质上一致的前提下，中心拉格朗日插值法改写了拉格朗日基本多项式$l_j(x)$。</p><p>$l(x) = \prod_{i = 0}^K(X - X_K)$，使$l_j(x) = \frac{l(x)}{x - x_j} \times \frac{1}{\prod _{i = 0}^K(x_j - x_i)}$</p><p>然后定义一个重心权$w_j = \prod_{i = 0}^K\frac{1}{x_j - x_i}$，则$L(x) = l(x)\sum_{j = 0}^K \frac{w_j \times y_j}{x - x_j}$。</p><p>然后这个玩意怎么改进拉格朗日了呢？</p><blockquote><p>当插值点的个数增加一个的时候，将每一个$w_j$都除以)$(x_j - x_{K + 1})$，得到$w_{k + 1}$，直接省掉了一个循环，因此复杂度变为了$O(N)$。</p></blockquote><p>（维基百科原话，还是能看懂的。）</p><p>据说这个重心拉格朗日插值法不仅仅速度更优，并且省掉了多项式$l(x)$的计算，还有说什么不同于第一型的拉格朗日插值函数的向后稳定，这个改进后的第二型拉格朗日插值函数是向前稳定的，勒贝格常数非常小，因为什么切比雪夫节点插值的极佳稳定性之类的。</p><p>当然，这种切比雪夫节点、勒贝格常数之类的就不是我们此次要学习的范围了，读者只要重心拉格朗日插值法把朴素拉格朗日插值法速度上甩了一大截就可以了。追求完美的读者可以试着一学。</p><h2 id="拉格朗日插值基函数的性质及其应用"><a href="#拉格朗日插值基函数的性质及其应用" class="headerlink" title="拉格朗日插值基函数的性质及其应用"></a>拉格朗日插值基函数的性质及其应用</h2><blockquote><ol><li>当$F(x)$为一个多项式且次数$\leq n$时，有$F^{(n+1)}(x) \equiv 0$，所以$R_n(x) = F(x) - L_n(X) \equiv 0$，（R为误差）<strong>因此$n$次插值多项式对于次数$\leq n$的多项式是精确的</strong>。</li><li>若$F(x) = x^k$其中$k \leq n$，那么$R_n(x) = x^k - \sum_{j = 0}^nX^kl_j(x) = 0$。特别的，当$k = 0$的时候有$\sum_{j = 0}^nl_j(x) = 1$。</li></ol></blockquote><p>结合上面的性质及其公式，我们尝试解决一些实际问题。从最经典的应用开始，熟练地运用拉格朗日公式解决插值类问题。</p><h3 id="连续自然数幂和（差分表）"><a href="#连续自然数幂和（差分表）" class="headerlink" title="连续自然数幂和（差分表）"></a>连续自然数幂和（差分表）</h3><blockquote><p>已知$K$，求$\sum _{i = 1}^Ni^K$</p></blockquote><p>首先介绍一个叫做“差分表”的小知识点。这个名字我们很自然想到差分的思想，而我们平常用的差分（$a[i + 1] - a[i]$）只是叫做<strong>一阶差分</strong>，根据这个最基本的，我们定义出”<strong>差分表</strong>“的东西。</p><blockquote><p>对于函数$F(x)$，把$F’(X) = F(X + 1) - F(X)$叫做一阶差分，称$F’(X)$叫做差分算子。引申出对于$K &gt; 1$，有$F’^K(X) = F’^{K - 1}(X + 1) - F’^{K - 1}(X)$为$K$阶差分。</p><p>算出所有的$F’^K(X)$，将$X = 1,2,3…H$，代入每一个$F’^K(X)$，得到一个二维的表。即是差分表。</p></blockquote><p><img src="https://pic.superbed.cn/item/5c5427615f3e509ed9a278be" alt="Pic20000"></p><p>可以观察到列数递减，我们把所有的数插空排列，便形成了差分表的基本形状。</p><p>接着是引入的两个定理，可以直接使用：</p><blockquote><p>如果多项式的次数为$N$，则对于所有大于$N$的$K$，多项式的$K$阶差分都恒等于$0$。</p><p>假设多项式$F(X)$的差分表的左斜列中各个元素依次是$D_0,D_1…D_M$，那么对于这个多项式的和恒有：</p><p>$Sum(X) = \sum_{X = 0}^NF(X) = D_0C_{N + 1}^1 + D_1C_{N + 2}^1 + H + D_MC_{N + 1}^{M + 1}$</p></blockquote><p>以这个差分表作为工具，我们尝试从简单开始逐步解决这个问题。</p><p>首先假设$F(X) = X$，那么    我们构造出差分表的样子大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0   1   2   3   4   5   6 ……</span><br><span class="line">  1   1   1   1   1   1 ……</span><br><span class="line">    0   0   0   0   0 ……</span><br></pre></td></tr></table></figure><p>所以$Ans = 1 + 2 + H + N = 0 \times C_{N + 1}^1 + 1 \times C_{N + 2}^2$</p><p>所以$Ans = \frac{N(N + 1)}{2}$</p><p>接着引申到$F(X) = X^2$，建立出差分表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0^2   1^2   2^2   3^2   4^2   5^2   6^2 ……</span><br><span class="line">    1     3     5     7     9     11 ……</span><br><span class="line">       2     2     2     2     2 ……</span><br><span class="line">          0     0     0     0 ……</span><br></pre></td></tr></table></figure><p>答案就是$1^2 + 2^2 + H + N^2 = 0C_{N + 1}^1 + 1C_{N + 2}^1 + H + 2C_{N + 1}^{M + 1}$</p><p>所以答案为$\frac{N(N + 1)(2N + 1)}{6}$</p><p>因此我们引出了$Ans(K)$就是一个关于$N$的$K + 1$次多项式。</p><p>知道如此结论，我们就可以选择$K + 1$个点然后利用拉格朗日插值公式进行计算了。夫再度$O(K)$。</p><h3 id="例题：Study"><a href="#例题：Study" class="headerlink" title="例题：Study"></a>例题：Study</h3><blockquote><p>给定了$K, A, N, D$，求$\sum_{i = 0}^N \sum_{j = 1}^{A + iD} \sum_{l = 1}^jl^K$</p></blockquote><p>实际上和上面那个题没有什么很大的区别，式子虽然很长，我们从里到外分开考虑即可</p><p>最里面的$\sum_{l=1}^jl^k$是一个关于$j$的$k+1$次的多项式。把其差分表的第一条对角线求出来。</p><p>然后$\sum_{j=1}^{A+iD}\sum_{l=1}^jl^k$是关于$i$的$k+2$次的多项式。$O(k^2)$求出$i=0,1,…k+2$的值。</p><p>所以答案就是一个关于$N$的$k+3$次的多项式。求其第一条对角线即可。</p><hr><h2 id="拉格朗日插值法的代码实现"><a href="#拉格朗日插值法的代码实现" class="headerlink" title="拉格朗日插值法的代码实现"></a>拉格朗日插值法的代码实现</h2><p>经过上述的学习之后，代码实现可能反而是小事了。给出模板题的连接：<a href="https://www.luogu.org/problemnew/show/P4781" target="_blank" rel="noopener">拉格朗日插值法</a></p><blockquote><p>给出$N$个点$(X_i,Y_i)$，确定一个唯一的$N - 1$次多项式，代入$k$求值。</p></blockquote><p>代入所有的点，按照上述的讲解，爆搞就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">QuickPow</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">1</span> ; <span class="keyword">while</span> (Y) &#123;</span><br><span class="line"><span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod ;</span><br><span class="line">Y &gt;&gt;= <span class="number">1</span> ; X = X * X % Mod ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; K = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) X[i] = Read(), Y[i] = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> Ken = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">Ken = Ken * (X[i] - X[j] + Mod) % Mod ;</span><br><span class="line">&#125;Ken = QuickPow(Ken, Mod - <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">Ken = Ken * (K - X[j] + Mod) % Mod ;</span><br><span class="line">&#125;Ken = Ken * Y[i] % Mod ;</span><br><span class="line">Ans = Ans + Ken % Mod ;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans % Mod) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>都是说拉格朗日插值法好用，之后才知道它的优点在哪：</p><blockquote><p>代替线性，抛物线之类的插值方法繁琐的公式结构和计算方法，其公式结构整齐紧凑，好看得多。</p></blockquote><p>可能有人感觉很好笑，但是这确实是很重要的一点。考场上推出来超级复杂繁琐的方程式会让你心态爆炸的，因此简单整齐的公式结构也是十分重要的，好写好看，这可能也是他广为人用的原因之一吧。</p><p>但当然，数学仍然是不完整的，对于采样点较多的情况时出现的龙格现象，也表明拉格朗日插值法具有数值不稳定的特点，因此大多数情况，拉格朗日插值法仍用于解决次数较低的插值多项式问题。</p><p>牛顿插值法不再将了，因为其本质是一样的，充其量走了不同的路子而已，想学的朋友可以去了解一下。</p>]]></content>
    
    <summary type="html">
    
      $$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$$ $$L_n(x) = \sum_{k = 0}^ny_kl_k(x)$$ 插值，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。本文主要介绍拉格朗日插值法，具体包括其工作原理，改进法，性质应用和代码实现。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="拉格朗日插值法" scheme="http://Yeasion.github.io/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    
      <category term="差分法" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于动态规划问题的优化方案</title>
    <link href="http://Yeasion.github.io/2019/02/01/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://Yeasion.github.io/2019/02/01/关于动态规划问题的优化方案/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-03-09T13:50:31.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈关于动态规划问题的优化方案"><a href="#浅谈关于动态规划问题的优化方案" class="headerlink" title="浅谈关于动态规划问题的优化方案"></a>浅谈关于动态规划问题的优化方案</h1><h2 id="1-单调队列优化"><a href="#1-单调队列优化" class="headerlink" title="1.单调队列优化"></a>1.单调队列优化</h2><p> 单调队列是一种具有单调性的队列，其中的元素全部按照递增或者递减的顺序排列，就比如下面这个递减队列。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxgb732mtj30dr054jr7.jpg" alt="picture"><br> 假如说我们要在队尾加入一个$5$，那么我们入队的步骤就是这样的：</p><blockquote><p> 发现队尾$1$，(q[tail])，$1<5$，则将1退出(tail--) 发现队尾$2$，(q[tail])，$2<5$，则将2退出(tail--)="" 发现队尾$3$，(q[tail])，$3<5$，则将3退出(tail--)="" 发现队尾$8$，(q[tail])，$8="">5$，停止退出队尾，将$5$入队。</5$，则将1退出(tail--)></p></blockquote><p><strong>经过上述步骤之后队列变为了{8,5}，依然满足递减的单调性，而实际上这也就是单调队列的基本操作。而维护递增的方式也是一样的。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">int</span> N, A[MAXN], Q[MAXN], Head = <span class="number">1</span>, Tail = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) A[j] = Read() ;</span><br><span class="line">Q[<span class="number">1</span>] = A[<span class="number">1</span>] ; <span class="comment">//将第一个元素入队。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt;= Tail &amp;&amp; Q[Tail] &lt; A[j])</span><br><span class="line"><span class="comment">//如果队列不为并且队尾元素小于A[i]</span></span><br><span class="line">Tail -- ; <span class="comment">// 弹出队尾元素</span></span><br><span class="line">Q[++ Tail] = A[j] ; <span class="comment">// 入队。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 【例题1】<br> 我们现在有一个整数序列$A(a[MAXN])$，长度为$n$，又知两个参数$k$和$m$，要求：从$A$序列中找出$k$个不相交的区间，每段区间长度$len$&lt;=$m$，要求所有k个区间的区间和最大。</p><p> 考虑最基本的$DP$,设$dp[i][j]$表示从前$j$个数里面选出来$i$个长度不超过m的不相交区间的区间和最大值，然后我们再枚举一个$k$，指选择$[k+1,j]$这个子区间。然后我们创造一个前缀和数组$sum[MAXN]$，那么$[k+1,j]$这个区间的区间和就是$sum[j]-sum[k]$。子问题分为两块：$j$选入子区间，或者$j$不选入子区间，从$j-m$到$j$范围内枚举一个$k$使得$dp[i-][k]+sum[j]-sum[k]$最大，然后与$dp[i][j-1]$取一个$max$可得答案。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Sum[i] = S[i - <span class="number">1</span>] + A[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">int</span> Ans = - Inf ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j - M ; k &lt;= j ; k ++)</span><br><span class="line">Ans = max(Ans, Dp[i - <span class="number">1</span>][k] + Sum[j] - Sum[i]) ;</span><br><span class="line">Dp[i][j] = max(Ans, Dp[i][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 这样的$DP$时间复杂度为$O(nmk)$，显然太大，于是我们考虑优化。<br> 我们可以看到$DP$的原式子是</p><script type="math/tex; mode=display"> \color{red}{dp[i][j]=max(dp[i][j-1],max(f[i-1][k]+sum[j]-sum[k]));}</script><p> 我们发现在里面的$k$的最优化枚举当中，sum[j]是不随k的枚举变化的，所以我们可以将sum[j]提出来变成：</p><script type="math/tex; mode=display"> \color{red}{dp[i][j]=max(dp[i][j-1],sum[j]+max(f[i-1][k]-sum[k]));}</script><p> 可以知道在整个式子里面最耗时间的就是最后关于$dp[i-1][k]-sum[k]$最大值的枚举，所以只要快速计算出来了$dp[i-1][k]-sum[k]$就可以快速计算整个式子。我们来看$dp[i-1][k]-sum[k]$的范围是在$[0][0],[0][1],….[0][m-1],[1][m],[2][m+1],…,[n-m][n-1]$这些区间上的最大值，也就是所有的$[j][i+j-1]$的区间。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxhphwrmij30mr042q2t.jpg" alt="picture2"><br> 我们发现这些区间的左右端点都是单调递增的，所以我们可以利用单调队列在$O(1)$的时间内解决这些区间。然后我们就将时间优化到了$O(nk)$。</p><h2 id="【例题2】-NOI2005-瑰丽华尔兹-link"><a href="#【例题2】-NOI2005-瑰丽华尔兹-link" class="headerlink" title="【例题2】$[NOI2005]$瑰丽华尔兹(link)"></a>【例题2】$[NOI2005]$瑰丽华尔兹(<a href="https://www.luogu.org/problemnew/show/P2254" target="_blank" rel="noopener">link</a>)</h2><p> 一个$n×m$的矩形网格。你初始站在$(x,y)$这。有些格子有障碍而有些没有。有$K$个时间段。第$i$个时间段从$s[i]$持续到$t[i]$（包括两端）这段时间内网格会向某个方向（上下左右之一）倾斜。所以每个时间段内的每个时间单位，你可以选择在原地不动，或者向倾斜的方向走一格（当然你不能走到障碍上或是走出网格）。<br> 求你最多能走多少格。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxigg49rfj30rh0etjrn.jpg" alt="picture3"><br> 如上图所示，黑色方块为障碍，$S$为起始点。<br> 按照最常的$DP$思路来看，我们设$dp[k][i][j]$为在k时间点，从$(x,y)$节点走到了$(i,j)$节点的时候最长走了多长。初始化$dp[0][i][j]$全部为$?∞$，而$dp[0][x1][y1]0$=$0$($x1,y1$为初始位置)，考虑子问题就是：从那边来？$k$时刻是从那个方向来还是不动？我们以第$k$时刻向右倾斜为例。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxiqemby7j30t10f2ta3.jpg" alt="picture4"><br> 如果是向右倾斜，那么上一层状态就是在$(i,j-1)$地点，那么结合两个子问题我们可以得出$DP$方程式：</p><script type="math/tex; mode=display"> dp[k][i][j]=max(dp[k-1][i][j],dp[k-1][i][j-1]+1);</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= Len ; k ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">Dp[k][i][j] = max(Dp[k - <span class="number">1</span>][i][j], Dp[k - <span class="number">1</span>][i][j - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p> 那么这样的时间复杂度就是$O(nm\sum_{i=1}^{K}(t[i]-s[i]+1))$，是无法通过这个题的全部数据的。然后我们紧接着考虑怎么优化。关于位置的$n^2$枚举我们没有什么办法，但是关于$K$我们可以进行优化，时间点很多有$\sum_1^K(t[i]-s[i]+1)$个，但是时间段$K$却&lt;=$200$，那么我们可以将一段时间的转移全部合并起来一起算，那么就快得多了。<br> 我们设$dp[k][i][j]$为在第$k$个时间段末尾，从$(x,y)$走到了$(i,j)$点,$len[k]$为第$k$个时间段的持续时间，可以算出是$t[k]-s[k]+1$。<br> 首先还是$n^2$的枚举，和$k$时间段的枚举，之后我们还有一个$l$的枚举，这个$l$枚举的是<strong>上一个状态加上在当前这个$k$的时间段内一共走的步数对应倾斜方向的横、竖坐标</strong>，如果我们继续以右倾为例，那么$j-len[j]&lt;=l&lt;=j$，就是从完全不动到走了最多的$len[k]$步，那么我们有了状态转移方程式：</p><script type="math/tex; mode=display"> \color{red}{dp[k][i][j]=max_{j-len[k]<=l<=j}(dp[k-1][i][l]+j-l)}</script><p> 由于其中的+$j$与l的枚举并无关联，所以提出来就变成了</p><script type="math/tex; mode=display"> \color{red}{dp[k][i][j]=max_{j-len[k]<=l<=j}(dp[k-1][i][l]-l)+j}</script><p> 其实也就是枚举这个时间段之前这个人的位置在哪，也就知道了当前的$dp[k][i][j]$是从哪里转移过来的。<br> 之后，我们回过头来看上一道题的最后的$DP$方程式：</p><script type="math/tex; mode=display"> \color{red}{dp[i][j]=max(dp[i][j-1],sum[j]+max(f[i-1][k]-sum[k]));}</script><p> 是不是发现格式非常的相似呢？，我们固定住$i$之后的状态转移方程式基本是和上题一样的，所以一样可以使用单调队列优化到$O(nmK)$。<br> 下面针对一组样例，我们进行一遍手动模拟，以帮助更好的理解。<br> 就用洛谷的样例吧。（第一行分别为n,m,x1,y1,k）</p><blockquote><p> 4 5 4 1 3<br> . . xx.<br> . . . . .<br> . . . x.<br> . . . . .<br> 1 3 4<br> 4 5 1<br> 6 7 3</p></blockquote><p> 那么画完图之后就是这个样子：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxp42nsxdj307t05zq2q.jpg" alt="picture5"><br> 从$1$~$3$时刻的倾斜方向是右，那么纵坐标是你不变的，我们枚举纵坐标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> S = Read(), T = Read(), Dir = Read() ;        <span class="comment">//注意要反着DP，也就是倒退</span></span><br><span class="line"><span class="keyword">int</span> Len = T - S + <span class="number">1</span> ; <span class="keyword">switch</span>(Dir) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++) DP(i, N, j, Dir, Len) ;<span class="comment">//北面的话横坐标不变，那么我们枚举纵坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++) DP(i, <span class="number">1</span>, j, Die, Len) ;<span class="comment">//南面的话横坐标不变，那么我们枚举纵坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) DP(i, j, M, Dir, Len) ;<span class="comment">//西面的话纵坐标不变，那么我们枚举横坐标</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> : <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) Dp(i, j, <span class="number">1</span>, Dir, Len) ;<span class="comment">//东面的话纵坐标不变，那么我们枚举横坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然后当我们的横坐标x枚举到1的时候，我们在DP函数里面定义一个now，然后是$while(x&gt;=1$&amp;&amp;$x&lt;=n$&amp;&amp;$y&gt;=1$&amp;&amp;$y&lt;=m)$,因为首先要保证不超过边界。然后如果我们发现右面是可以走的，那么我们就进行一个push操作。也就是关于dp[p-1][x][y]在单调队列里面的入队操作。在最前面我们已经介绍了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> Now, <span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (V == Inf) <span class="keyword">return</span> ;<span class="comment">// 如果根本到不了，返回</span></span><br><span class="line"><span class="keyword">while</span> (Heap &lt;= Tail &amp;&amp; V - Now &gt;= Q[Tail])</span><br><span class="line">Tail -- ;<span class="comment">//弹出队尾元素</span></span><br><span class="line">Q[++ Tail] = V - Now ; Pos[Tail] = Now ;</span><br><span class="line"><span class="comment">// Pos记录位置，用来判断是不是可以滑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 而至于为什么要在$while$里面减去一个$now$，是因为(x,y)这个位置不一定是在当前方向的起点上，因为之后某一步的步数减去当前的步数得到的值就是(x,y)到那一步在的点的距离，相当于一个化简~<br> 由于$dp[0][i][j]$=-$INF$,当前的$p$=$1$所以$p$-$1$的时候$value$就是-$INF$，所以在第0个时间段到不了这个地方，我们直接返回。然后下面其实就没什么事了，所有的push全部直接返回，最后退出DP函数。就这样进行到$x$(即$j$)=$3$的时候，我们发现$map[3][4]$是一个障碍点，那么也就是说我们之前进行的所有工作<strong>全部无效</strong>，然后我们将整个队列清空，即$head$=$1,tail$=$0$;<br> 然后接着进行到$x$=$4$,$y$=$1$($4$行$1$列)的时候，我们到了起始点，而起始点的dp[0][4][1]是0，所以$value$!=-$INF$，我们从终于将一个值$value$-$now$=-1入队了，那么我们当前的队列是这个样子的：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxqepa2l6j307v057t8i.jpg" alt="pictre6"><br> 加上步数之后我们发现$dp[p][x][y]=q[head]+now$依然是$0$，所以$ans$没有被更新（废话，你从起点走到起点需要更新$ans$嘛），所以我们继续向下进行，因为每次$now$都会++，所以下面的$dp[p][x][y]$加上$now$之后就可以更新$ans$的值了。然后进行到$x$=$4$,$y$=$5$的时候，我们发现$now-pos[head]=4$，大于可以$len$，也就是说超过了可以滑动的区间。（一共就三秒你怎么滑第四块啊~）那么我们将队首弹出，接下来我们就不能再更新ans的最大值了，$x$=$4$时完美结束。这个时候我们的行走路径大概如下：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxqof26myj307o05omwy.jpg" alt="picture7">（蓝色方块为当前方块，黄色方块为路径）<br> 也就是说从$1$~$3s$我们最多可以走3块。（真是麻烦啊~）<br> $i$继续走，我们进行到下一个时间段。$4$~$5s$的时候是向北倾斜的。那么我们进行$DP(i,n,j,dir,len)$，我们从$n$行$j$列开始$DP$，第一次将$tail$弹出后又入队我们不管，因为$j=1$、$2$的时候都不能更新$ans$，然后到了$j=3$的时候，我们将$dp[1][4][3]-now=1$入队了。<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxrbdg1zfj308905ywea.jpg" alt="picture8"><br> 然后当$now$进行到第三次的时候我们就可以更改ans值为4了。<br> 之后结束了第二个时间段。此时的路径大概是这样的：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxrgc5l1ej308105smwy.jpg" alt="picture9"><br> 最后在第三个时间段内，我们将路径更改为如下：<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxricdoxpj307w06ct8i.jpg" alt="picture0"><br> 那么以上就是整个样例的模拟，最终我们得到$ans$数为6.</p><h2 id="关于单调队列优化的一点总结"><a href="#关于单调队列优化的一点总结" class="headerlink" title="关于单调队列优化的一点总结"></a>关于单调队列优化的一点总结</h2><p> 鉴于两者之间的$DP$转移方程的相似性，我们成功的利用单调队列优化了问题，那么回过头来看看，什么样的问题可以利用单调队列进行优化呢？我们最上面讲的单调队列是具有单调性的一种数据结构，他可以保证数据的单调性，自然也就可以留下数据的最大值或者最小值，利用了单调性，<strong>就是减少了一位枚举，减去一维，直接获得单调队列里面的最优解</strong>。并且DP可以使用单调队列优化，当且仅当$DP$式的格式基本满足</p><script type="math/tex; mode=display"> \color{red}{dp[i]=a[i]+max_{l[i]<=j<=r[i]}b[j]}</script><p> 的时候。即“$dp[i]$=$A(i)$+$B(j)$中的最小/大值 $(i-k&lt;=j&lt;i,k$为常数$)$”，当你发现要求$max$而且求可能拓展的状态有线性关系的时候，你就可以考虑单调队列优化了。</p><h2 id="2-斜率优化"><a href="#2-斜率优化" class="headerlink" title="2.斜率优化"></a>2.斜率优化</h2><p> 如果你有一个这样结构的$DP$式：</p><blockquote><p> $f[i]=max_{j=1}^{j&lt;=i}(a[i] \times b[j]+c[j]+d[i])$</p></blockquote><p> 我们发现取$max$里面的d[i]其实和j的枚举并没有关系，所以将d[i]提出来就变成了这样：</p><blockquote><p> $f[i]=d[i]+min_{j=1}^{j&lt;=i}(a[i] \times b[j]+c[j])$</p></blockquote><p> （只是这样的结构而已，比如也可以是$max$，$j$也不一定属于$[1,n]$此处只是一个单独情况）<br> 其中$a[now],b[now],c[now],d[now]$都是关于$now$的函数，并且$b[now]$是单调递增的，那么我们接下来利用数学归纳法证明其决策的单调性。<br> 首先我们假设有两个决策$j$,$k$满足$j&lt;k$并且$k$的决策优于$j$的决策。那么我们有</p><script type="math/tex; mode=display"> d[i]+a[i]*b[j]+c[j]>=d[i]+a[i]*b[k]+c[k]</script><p> 消去左右两端的d[i]后可得</p><script type="math/tex; mode=display"> a[i] \times b[j]+c[j]>=a[i] \times b[k]+c[k]</script><p> 我们知道在$i$后面有状态$i+1$，我们为了简单起见，设$a[now]$是单调递减的，那么我们就是要证明</p><blockquote><p> $d[i+1]+a[i+1] \times b[j]+c[j]&gt;=d[i+1]+a[i+1] \times b[k]+c[k]$</p></blockquote><p> 由于$a$是单调递减的，所以$a[i-1]$也可以写成$a[i]-v$的形式，其中$v&gt;0$，那么式子变成：</p><blockquote><p> $d[i+1]+a[i] ]\times b[j]+v \times b[j]+c[j]&gt;=d[i+1]+a[i] \times b[k]+v \times b[k]+c[k]$</p></blockquote><p> 然后因为</p><script type="math/tex; mode=display"> a[i]*b[j]+c[j]>=a[i]*b[k]+c[k]</script><p> 并且$b[k]&gt;b[j]$,所以我们有$v<em>b[k]&gt;v</em>b[j]$，所以我们知道</p><blockquote><p> $d[i+1]+a[i+1] \times b[j]+c[j]&gt;=d[i+1]+a[i+1] \times b[k]+c[k]$</p></blockquote><p> 是正确的，<strong>决策单调性也存在</strong>。然后我们将式子展开就可以得到这样一个玩意：</p><blockquote><p>  $-a[i]&gt;=\frac{c[k]-c[j]}{b[k]-b[j]}$。</p></blockquote><p> 你会发现这个玩意像极了一个叫做斜率的东西(数学就是瞎$yy$出来的)</p><blockquote><p> $slope(i,j)$:$\frac{y[k]-y[j]}{x[k]-x[j]}$</p></blockquote><p> 没错，这个东西就是我们要讲的第二个内容：斜率优化！</p><blockquote><p> 记斜率为$slope(i,j)=\frac{c[k]-c[j]}{b[k]-b[j]}$</p></blockquote><p> 那么我们紧接着$yy$这个式子的属性，发现它和单调队列有很多相似之处,因此我们也可以根据这些特性对$DP$进行优化：</p><blockquote><ol><li>$-a[i]&gt;=slope(q[l],q[l+1])$。</li></ol></blockquote><p> 我们知道$q[l]$是在$q[l+1]$之前就已经输入完毕的了，那么这个式子就表示$q[l]$不如$q[l+1]$更优，所以弹出队首。</p><blockquote><p> 2.$slope(q[r-1],q[r]&gt;slope(q[r],i)$。</p></blockquote><p> 假设在之后会出现一个$a[t]$使得$-a[t]&gt;=slope(q[r-1],q[r])$,那么在弹出$q[r-1]$之后，$-a[t]也一定&gt;=slope(q[r],i)$;</p><p> 我们考虑将每一个$(b[j],c[j])$作为一个点对放到一个平面直角坐标系当中，画一条过点$(b[j],c[j])$的斜率为$a[i]$的直线，那么这个直线的方程式就是$f[i]=a[i]x+(y[j]-a[i]x[j])$，所以我们就成功的将一个决策转化到了平面直角坐标系上面。<br> 假如说我们将所有的决策转化为点映射到图上可以得到这样一个图：<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxvi4jsa2j311f0kq0tf.jpg" alt="pciture"><br> 那么我们对于每一个点做一个斜率为$a[i]$的直线可以得到这样的一幅图<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxvk3anb2j31130l8wfz.jpg" alt="pictureb"><br> 由于我们要枚举的是一个是决策最优的方案，那么我们就要根据题意，来看看是$min$还是$max$，在这里我们的方程式是取的$min$，也就是要在所有的决策中找到一个位置最靠下的，也就是最右面那道直线。<br> 但是这样每一条边每一条边地建、找实在是太慢，于是我们考虑如何优化。<br> 我们知道最下面的一条边肯定会<strong>在一个下凸的凸壳上面</strong>（比如下图），那么我们就要想办法维护这个凸壳，将不可能有贡献的点删去。<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftxvoucj8uj310g0klt9g.jpg" alt="picturec"><br> 那么上图中被下面的这条折现包起来的所有的点就都没有作为最优决策的机会，因此我们就要抛弃这些决策，并且<strong>有可能被选为最优决策的只有在这个下凸壳上面的点</strong>。<br> 而对于整个下凸壳的求法，我们考虑先排一遍序，按照x[i]从小到大的顺序排序，然后由于x[i]递增，那么我们就只需要考虑在右面添加点就可以了。对于一个点v，如果它是由前面两个点组成的直线<strong>逆时针旋转</strong>过来的，那么很好，我们就将它加入目前的下凸壳，比如下图：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxw1nrw0mj30oy0dz74q.jpg" alt="pictured"><br> 但是如果当前点$v$是由前面两个点$h$,$g$所形成的直线经过<strong>顺时针旋转</strong>得到的，那么我们就要删除之前的最后一个点$g$，<strong>继续判断</strong>$v$是不是由$h$和$h$前面的点<strong>顺时针旋转</strong>得到的，直到碰到一个<strong>逆时针旋转</strong>的操作，那么停止，并将最后删除的点的前一个点连到$v$点上。比如下图：<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftxw8k74hqj30w30iqwff.jpg" alt="picturee"><br> 删除第一个节点之后继续判断<br><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftxwapzyaij30v10hp0tk.jpg" alt="picturef"><br> 而对于上凸壳的寻找，就是讲寻找下凸壳中所有的顺逆时针反过来就可以了。而顺时针和逆时针的判断就是根据斜率。当然你也可以这么判断：若 $(x[C]?x[A])(y[B]?y[A])?(x[B]?x[A])(y[C]?y[A])&gt;0$，则是顺时针转的；否则是逆时针转的($=0$的情况是三点共线)。<br> 那么维护完了凸壳，加下来我们要做的就是在凸壳上找到一个斜率为$k$的切线了，而这个切线的寻找分为两种情况来考虑。（针对下凸壳）</p><blockquote><p> 1.当斜率是递增的时候，我们可以发现被取到的点也是越来越靠右的，所以我们只要从左到右依次删除不优的点就可以了。可以使用双向队列。<br> 2.当斜率不单调的时候，我们就采用二分的方法。我们一直取中间的$mid$点，如果$mid+1$存在并且与$mid$点构成的直线的斜率小于k，那么l=mid+1吗，接着二分；如果$mid-1$存在并且与$mid$构成的直线的斜率大于k，那么r=mid-1，接着二分。如果上面两个条件都不满足，<strong>那么$mid$就是切点，也就是我们要找的点啦！！</strong></p></blockquote><h2 id="【例题3】-HNOI2008-玩具装箱（Link）"><a href="#【例题3】-HNOI2008-玩具装箱（Link）" class="headerlink" title="【例题3】[HNOI2008]玩具装箱（Link）"></a>【例题3】[HNOI2008]玩具装箱（<a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener">Link</a>）</h2><p> 题目描述<br> $P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1…N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C[i]$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为$x=j-i+\sum_{k=j}^{k&lt;=j}C[k]$ 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$x$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.<br> 输入输出格式<br> 输入格式：<br> 第一行输入两个整数$N$，$L$.接下来$N$行输入$C[i]$.$1&lt;=N&lt;=50000$,$1&lt;=L,Ci&lt;=10^7$<br> 输出格式：<br> 输出最小费用</p><p><strong>解析</strong></p><p> 简单来说，我们有一个长度为$L$的序列$C[i]$,要求将序列分成若干段，每一段如果从$i$到$j$，整段的和为$S$，那么就会产生$(j-i+S-L)^2$的代价，要求得到最小的代价和。<br> 那么$S$就是$\sum_{k=i}^{k&lt;=j}C[k]$，那么我们就可以把式子简化成这样：</p><script type="math/tex; mode=display"> \sum_{k=i}^{k<=j}(C[k]+1)-(L+1)</script><p> 所以你可以发现如果将输入的所有$C[i]$加上$i$并且将$L$全部加上$1$的话，费用就变成了$(S-L)^2$。<br> 设$sum[i]$为$i$点的前缀和，我们得到$DP$式子为</p><script type="math/tex; mode=display"> f[i]=min_{j=0}^{j<=i}(f[j]+(sum[i]-sum[j]-L+i-j-1)^2)</script><p> 嗯，按照上面的节奏，我们将$j$范围内的式子变一下：</p><script type="math/tex; mode=display"> f[i]=min_{j=0}^{j<=i}(f[j]+((sum[i]+i)-(sum[j]+j)-L)^2)</script><p> 然后我们令$s[i]=sum[i]+i$，式子就变成了这样：</p><script type="math/tex; mode=display"> f[i]=min_{j=0}^{j<=i}(f[j]+(s[i]-s[j]-L)^2)</script><p> 然后把里面的平方展开</p><script type="math/tex; mode=display"> f[i]=min_{j=0}^{j<=i}(f[j]+s[i]^2+(s[j]+L)^2-2*s[i]*(s[j]+L))</script><p> 然后稍微一个移项</p><script type="math/tex; mode=display"> f[i]+2*s[i]*min_{j=0}^{j<=i}(s[j]+L)=f[j]+s[i]^2+(s[j]+L)^2</script><p> 然后我们看这个式子的格式就很熟悉了</p><blockquote><p> b+kx=y</p></blockquote><p> 就是前面搞的直线的解析式！所以我们知道这么一个转化</p><blockquote><p> $x=s[j]+L$<br> $y=f[j]+s[i]^2+(s[j]+L)^2$</p></blockquote><p> 并且我们还知道$dp[i]$就是上面的$y=kx+b$的截距。那么我们将所有的</p><script type="math/tex; mode=display"> (x=s[j]+L，f[j]+s[i]^2+(s[j]+L)^2)</script><p> 点全部加到平面直角坐标系上，然后维护下凸壳就可以啦！并且你可以发现斜率$k=2*s[i]$是一个单调递增的哦~<br> 并且这里还有一个很重要的地方：看上面的那个$y$的方程是$y=f[j]+s[i]^2+(s[j]+L)^2$而实际上这里并不是一个关于$i,j$的双变量，我们在对于同一个$f[i]$计算的时候，求斜率坐标相见就已经抵消掉了这个$i$的部分。<br> 至于凸壳的寻找方法和最优点的寻找方法上面已经有比较详细的介绍了，就不再多说，上代码讲解就好了吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">X</span><span class="params">(LL j)</span> </span>&#123;<span class="keyword">return</span> S[j] ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Y</span><span class="params">(LL i)</span> </span>&#123;<span class="keyword">return</span> F[i] + (S[i] + L - <span class="number">1</span>) * (S[i] + L - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Slope</span><span class="params">(LL i, LL j)</span> </span>&#123;<span class="keyword">return</span> (Y(j) - Y[i]) / (X(j) - X(i)) ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read(), L = Read() ;</span><br><span class="line">L ++ ; Head = Tail = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">LL X = Read() ;</span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + X + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope(Q[Head], Q[Head + <span class="number">1</span>]) &lt; <span class="number">2</span> * S[i])</span><br><span class="line">Head ++ ; LL j = Q[Head] ;</span><br><span class="line">F[i] = F[j] + (S[i] - S[j] - L) * (S[i] - S[j] - L) ;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope(Q[Tail - <span class="number">1</span>], Q[Tail]) &gt; Slope(Q[Tail], i))</span><br><span class="line">Tail -- ; Q[++ Tail] = i ;</span><br><span class="line">&#125;Print(F(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="【例题4】-土地征用-（Link）"><a href="#【例题4】-土地征用-（Link）" class="headerlink" title="【例题4】 土地征用 （Link）"></a>【例题4】 土地征用 （<a href="https://www.luogu.org/problemnew/show/P2900" target="_blank" rel="noopener">Link</a>）</h2><p> 约翰准备扩大他的农场，眼前他正在考虑购买N块长方形的土地。如果约翰单买一块土 地，价格就是土地的面积。但他可以选择并购一组土地，并购的价格为这些土地中最大的长 乘以最大的宽。比如约翰并购一块3 × 5和一块5 × 3的土地，他只需要支付5 × 5 = 25元， 比单买合算。 约翰希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。 给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。<br> 输入输出格式<br> 输入格式：</p><p> $Line$ $1:$ $A$ $single$ $integer:$ $N$<br> $Lines$ $2..N+1:$ $Line$ $i+1$ $describes$ $plot$ $i$ $with$ $two$ $space-separated$ $integers:$ $width$ _ $i$ $and$ $length$ _ $i$<br> 输出格式：<br> $Line$ $1:$ $The$ $minimum$ $amount$ $necessary$ $to$ $buy$ $all$ $the$ $plots.$</p><p><strong>解析</strong></p><p> 我们定义结构体$Edge$中含有$X,Y$分别表示一块土地的长和宽。<br> 考虑一块土地$A$，如果有一块土地$B$的$X$和$Y$都大于$A$，那么$A$的存在是没有意义的，因为$A$是可以不耗费任何代价被$B$所合并的，所以它不会对答案产生任何影响。于是我们考虑去掉这样所有的土地$A$。<br> 首先我们将所有土地按照长度从小到大排序，长度相同的按照宽度从小到大排序。定义一个$Stack$，然后连续将所有的土地入栈，在$A$入栈之前将之前栈中所有宽度小于等于$A$的土地全部弹出，然后入栈$A$。那么最后在栈中的元素就是我们所希望的元素。这里的元素是按照长度从小到大，宽度从大到小的顺序有序排列的。<br> 那么显然我们每次合并的都是一个连续的区间。考虑使用$DP$，易得状态转移方程：</p><script type="math/tex; mode=display"> dp[i]=min_{j=1}^{j<=Top}(dp[i],dp[j]+Stack[j+1]*L[i])</script><p> 其中Stack里面存的是元素的宽度，L是栈中元素的长度。（因为有些土地被抛弃了所以我们不能继续使用$Edge$结构体），然而这样的时间复杂度会超时，考虑斜率优化。<br> 我们看到后面的</p><script type="math/tex; mode=display"> dp[j]+Stack[j+1]*L[i]$，设$k=Stack[j+1]，b=dp[j]</script><p> 然后$x=L[i]$，那么我们就得到了直线方程:$y=kx+b$。套上斜率优化的板子即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Put_in_Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Top &amp;&amp; S[Top] &lt;= E[i].Y) Top -- ;</span><br><span class="line">S[++ Top] = E[[i].Y] ;</span><br><span class="line">L[Top] = E[i].X ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Calc</span><span class="params">(LL i, LL j)</span> </span>&#123;<span class="keyword">return</span> Dp[j] + S[j + <span class="number">1</span>] * L[i] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Sloop</span><span class="params">(LL a, LL b, LL c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (B[c] - B[a]) * (A[b] - A[a] - (B[b] - B[a]) * (A[c] - A[a]) &gt;= <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) E[i].X = Read(), E[i].Y = Read() ;</span><br><span class="line">sort(E + <span class="number">1</span>, E + N + <span class="number">1</span>, CMP) ; Put_in_Stack() ; A[<span class="number">0</span>] = S[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Top ; i ++) &#123;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Calc(i, Q[Head]) &gt;= Calc(i, Q[Head + <span class="number">1</span>]))</span><br><span class="line">Head ++ ;</span><br><span class="line">Dp[i] = Calc(i, Q[Head]) ; A[i] = S[i + <span class="number">1</span>] ; B[i] = Dp[i] ;</span><br><span class="line"><span class="keyword">while</span> (Head &lt; Tail &amp;&amp; Slope (Q[Tail - <span class="number">1</span>], Q[tail], i)) Tail -- ;</span><br><span class="line">Q[++ Tail] = i ;</span><br><span class="line">&#125;Print(Dp[Top]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是关于动态规划的单调队列和斜率优化的相关内容，世界上动态规划的优化远不止如此，结合具体问题，动态规划还可以套上各种数据结构，比如四边形优化，线段树优化等等，笔者在这里介绍的只是比较常用的板子类的动态规划优化。具体的优化方式还要根据实际问题进行操作。</p>]]></content>
    
    <summary type="html">
    
      $$Dp[i]=a[i]+max_{l[i]&lt;=j&lt;=r[i]}~b[j]$$ $$d[i]+min_{j=1}^{j&lt;=i}(a[i]b[j]+c[j])$$很多动态规划的题目不仅仅要求正确性，还要求极快的速度，因此有时单纯的动态规划手段也可能超时，于是便需要一些适当的优化，本文主要浅略地谈一下使用单调队列或者斜率知识优化动态规划问题的手段。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="单调队列优化" scheme="http://Yeasion.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
      <category term="斜率优化" scheme="http://Yeasion.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
