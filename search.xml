<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[矩阵树定理及其应用]]></title>
    <url>%2F2019%2F04%2F04%2F%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这个东西首次出现在周冬的国家集训队论文里面，解决的问题叫做生成树计数问题。顾名思义，就是让你求一张无向图中生成树的个数。首先我们要知道三个概念。 邻接矩阵A这个东西不用我说了吧，就是对于每一条边$Edge_{ij}$，矩阵的$i$行$j$列和$j$行$i$列设为1，其他设为0。 度数矩阵D啥意思呢，就是将每一个点的度数，其中对于每一个不相等的$i,j$有$D[i][j] = 0$ 基尔霍夫矩阵C$C = D - A$ 而Matrix-Tree定理就是说这个无向图的生成树个数就等于基尔霍夫矩阵的任意一个$N - 1$阶主子式的行列式的绝对值。]]></content>
      <tags>
        <tag>矩阵树定理</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卢卡斯定理与扩展卢卡斯定理]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念卢卡斯定理要解决的问题很简单： C_n^m ~mod~ p如果$p$规定为质数，那么就用卢卡斯定理解决，否则就是扩展卢卡斯定理。洛谷上两个模板题都有 Lucas ExLucas 前置知识如果你不知道前置的知识的话，最好还是去系统学习一下。 1. 乘法逆元 若$Ax \equiv 1 (mod~p)$且$A$与$p$互质，则称$A$的$mod~p$意义下的乘法逆元为$X$ 关于求逆元：因为$(a,p) = 1$所以$a^{p-1} \equiv 1 (mod~p)$所以$a \times a ^{p - 2} \equiv 1 (mod~p)$所以$m!(n - m)!$的逆元为$(m!(n - m)!) ^{p - 2}$直接快速幂就可以了。 2.扩展欧几里得 扩展欧几里得用来在求得$gcd(a,b)$的同时，找出整数$x,y$使其满足$ax + by = gcd(a,b)$ 3.费马小定理 $a^(p-1) \equiv 1 (mod~p)$。 4.中国剩余定理还请移步博客欧几里得与扩展中国剩余定理Excrt 卢卡斯定理证明过程：首先根据组合数的只是我们可以很显然推出 C_p^i \equiv \frac pi C_{p-1}^{i-1} \equiv 0 (mod~p)然后根据二项式定理得出： (1 + x)^p \equiv \sum_{i=0}^p C_p^0 X^i \equiv C_p^o1^pX^0 + C^p_p1^0X^p \equiv 1 + x^p (mod~p)然后我们继续从二项式定理推出： C^b_a \equiv \prod_{i = 0}^p0 C_{a_ip^i}^{b_ip^i} (mod~p)上式也就是所谓的卢卡斯定理，这玩意的用处就在于下面这个递推式： Lucas(n,m,p) = CC_{m \% p}^{n \% p} \times Lucas(\frac np, \frac mp, p其中$Lucas(x,0,p) = 1$且$CC_m^n = (C_m^n)^(p-2) ~mod ~p$实际上就是一个费马小定理和乘法逆元。根据这个东西就可以很快地求出来上面的问题了。如果你看不大懂，那就只需要记结论。。。。 C_m^n ~mod~ p = (C_{m / p}^{n / p} ~mod~p) \times (C^{n ~mod~ p}_{m ~mod~ p} ~mod~p)~mod~p然后直接递归调用$C_{m~mod~p}^{n~mod~p} ~mod~p$就可以了。对于$C_m^n$的除法取模就需要用到逆元了。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;LL N, M, P, X[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline LL QuickPow(LL A, LL B) &#123; LL Ans = 1 ; if (! B) return 1 % P ; while (B) &#123; if (B &amp; 1) Ans = Ans * A % P ; A = A * A % P, B &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL C(LL A, LL B) &#123; if (B &gt; A) return 0 ; return (X[A] * QuickPow(X[B], P - 2)) % P * QuickPow(X[A - B], P - 2) % P ;&#125;inline LL Lucas(LL A, LL B) &#123; if (! B) return 1 ; else return (C(A % P, B % P) * Lucas(A / P, B / P)) % P ;&#125;int main() &#123; int T = Read() ; while (T --) &#123; N = Read(), M = Read(), P = Read() ; X[0] = 1 ; for (LL i = 1 ; i &lt;= P ; i ++) X[i] = (X[i - 1] * i) % P ; LL Ans = Lucas(N + M, N) ; printf("%lld\n", Ans) ; &#125; return 0 ;&#125; 扩展卢卡斯定理令$P = \prod p_i^{c_i}$假设我们知道$C_n^m ~mod~p_i^{c_i}$就可以直接上$Crt$，但是我们并不知道。（泪目怎么求呢？对于$C^n_m = \frac{n!}{(n-m)!m!}$我们可以阶乘的变换。假设我们现在要求$19! % 3$我们将$1 \times…\times 19$中所有$3$的倍数拿出来合并。那么我们就得到$\lfloor \frac{19}{3} \rfloor$个满足项，然后除以$3$之后，就得到$\lfloor \frac{19}{3} \rfloor !$,这一部分不好算，我们直接递归下去。然后对于其他的项，可以看出来他们具有小于$3^k$的循环节这种东西，就可以暴力。然后时间复杂度就很可观了。]]></content>
      <tags>
        <tag>数论</tag>
        <tag>扩展欧几里得</tag>
        <tag>Lucas</tag>
        <tag>ExLucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP-旅行商问题]]></title>
    <url>%2F2019%2F03%2F19%2FTSP-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$TSP$是一个“组合优化问题”，同时也是数学领域中一个较为著名的$NPC$问题。 现在的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。 可以发现这个问题并不是真正意义上的$NPC$，而是属于一个$NP-Hard$，因此可以求出较优解。这个问题的实质就是求一个带权无向图中，找一个权值最小的哈密尔顿回路，在给出的节点数目非常小的情况下，我们可以考虑状压$DP$。当然，我们知道没有什么算法是暴力搜索解决不了的，在没有十分优的解决方案的时候没我们自然想到枚举全排列。但是这显然白搭，因为$O(N!)$的时间复杂度即使点数很小也是很难接受的。于是考虑压缩状态。对于一种方案，我们用一个$N$位的二进制数表示，其中$1$表示第$i$个点被经过，若是$0$则是没有经过。我们设$Dp[i][j]$表示路径状态为$i$，当前处于$j$节点的最短路径。假设我们现在有一个$Dp[i][j]$，那么我们可以枚举一个点$k$，因为当前的$j$是刚刚经过，因此上一个状态一定没有经过$j$这个点。因此在上一个时刻的点的状态的第$j$位就一定是$0$，状态就是$i \times (1 &lt;&lt; k)$。并且从$k$走到$j$需要$L[i][j]$（也就是两点之间的最短路），于是我们取遍所有的$k$取最小值即可。得出递推关系式： Dp[i][j] = min(Dp[i][j], Dp[i * (1 < j)][k] + L[k][j])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>NPC问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2010]生成字符串]]></title>
    <url>%2F2019%2F03%2F17%2FSCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[这题首先就得有一个画坐标系的想法，这很智障，我一开始也没有想出来。我们设$X = Num[1] + Num[0]$, $Y = Num[1] - Num[0]$也就是将1的个数加上0的个数设为X横坐标，把其和设为纵坐标。稍微画一下图，如果我们从原点开始向右上方走(y = x)，那么就是$X + 1, Y + 1$，表示我们选择了1,，如果朝右下角走$y = - x$那么就是$X + 1, Y - 1$，表示我们选择了0。很显然最后的方案数就是从原点走到$(N + M),(N - M)$节点。因为无论如何$X$都是加一，所以步数一定是$N + M$步，而我们要选出$M$次向下走，方案数就是$C^{N +M} _M$。当然，这是没有考虑限制情况。题目要求$1$的个数不能超过$0$的个数。发现也就是不能超过$y = - 1$这条直线。而经过直线的方案数就是$C^{N +M} _{M - 1}$然后最后的答案就是 C^{N +M} _M - C^{N +M} _{M - 1}这种东西直接预处理前缀积然后逆元一下就好了…12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const LL MAXN = 1000010 &lt;&lt; 1 ;const LL MAXM = 1000010 &lt;&lt; 1 ;const LL Inf = 0x7fffffff ;const LL Mod = 20100403 ;LL N, M, Fac[MAXN], Inv[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline LL QUCIK_POW(LL X, LL Y) &#123; LL Ans = 1 ; while (Y) &#123; if (Y &amp; 1) Ans = Ans * X % Mod ; X = X * X % Mod ; Y &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL C(LL X, LL Y) &#123; LL U = Fac[X] * Inv[Y] % Mod ; return U * Inv[X - Y] % Mod ;&#125;int main() &#123; N = Read() ; M = Read() ; Fac[0] = 1 ; for (LL i = 1 ; i &lt;= N + M ; i ++) Fac[i] = Fac[i - 1] * i % Mod ; Inv[N + M] = QUCIK_POW(Fac[N + M], Mod - 2) ; for (LL i = N + M - 1 ; i &gt;= 0 ; i --) Inv[i] = Inv[i + 1] * (i + 1) % Mod ; printf("%lld", (C(N + M, M) - C(N + M, M - 1) + Mod) % Mod) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>组合数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO15JAN]草鉴定]]></title>
    <url>%2F2019%2F03%2F12%2FUSACO15JAN-%E8%8D%89%E9%89%B4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Link一道及其智障的题目，关键在于博主调这个智障题调了基本一天…其实不是很难想，我们先缩一下点，把新图建出来，当然是因为要保证图无环，要不然下面就没法做了。这里实际上要建两个新图，一个正着的，还有一个反图。干什么用的呢？主要就是因为题目要求回到原点，这个玩意怎么实现的问题。首先这个路经肯定是一个圈，然后我们就可以找一下这个圈的一个“转折节点”，实际上就是枚举一个中间节点$X$，然后吧路经分为$1 -&gt; X$和$X -&gt; 1$两个链，这就需要我们建一个反图来进行实现。因为题目要求经过的点最多，因此我们就跑两个最长路。第一个最长路记录正图的$1 - &gt; Point_i$节点为$D[i]$。第二个最长路记录反图的$Point_i - &gt; 1$节点为$D2[i]$。（实际上也是从1节点出发）然后对于这个逆行的边我们如下处理：首先在$Tarjan$的时候进行一个记录$C[i]$表示$SCCi$号节点里面包含的原图的点数。那么$C[B[i]]$就是表示原图$i$号节点所属的$SCC$节点包含的原图的点数。对于逆行的边我们直接枚举答案就是$min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]])$（V为反图） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010000 ;const int MAXM = 200010 ;const int Inf = 0x7fffffff ;int N, M, B[MAXN], Low[MAXN], Dfn[MAXN &lt;&lt; 1] ;struct EDGE &#123; int F, T, Next ;&#125; E[MAXM &lt;&lt; 1] ;struct GDGE &#123; int F, T, Next ;&#125; G[MAXM &lt;&lt; 1] ;struct VDGE &#123; int F, T, Next ;&#125; V[MAXM &lt;&lt; 1] ;int Ken, Top, S[MAXN], Cnt, C[MAXN],Ans ;bool Insta[MAXN] ;vector &lt;int&gt; Point[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int H[MAXN], Tot ;inline void Add(int F, int T) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].Next = H[F], H[F] = Tot ;&#125;int H2[MAXN], Tot2 ;inline void Add2(int F, int T) &#123; G[++ Tot2].F = F ; G[Tot2].T = T ; G[Tot2].Next = H2[F], H2[F] = Tot2 ;&#125;int H3[MAXN], Tot3 ;inline void Add3(int F, int T) &#123; V[++ Tot3].F = F ; V[Tot3].T = T ; V[Tot3].Next = H3[F], H3[F] = Tot3 ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = ++ Ken ; Low[Now] = Ken ; S[++ Top] = Now ; Insta[Now] = 1 ; for (int i = H[Now] ; i ; i = E[i].Next) if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[Now], Low[E[i].T]) ; &#125; else if (Insta[E[i].T]) Low[Now] = min(Low[Now], Dfn[E[i].T]) ; if (Dfn[Now] == Low[Now]) &#123; int Pass ; Cnt ++ ; do &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Point[Cnt].push_back(Pass) ; C[Cnt] ++ ; Insta[Pass] = false ; &#125; while (Pass != Now) ; &#125;&#125;int D[MAXN], Vis[MAXN] ;queue&lt;int&gt; Q ;inline void Spfa() &#123; memset(Vis, 0, sizeof(Vis)) ; memset(D, 0, sizeof(D)) ; D[B[1]] = - C[B[1]] ; Vis[B[1]] = 1 ; Q.push(B[1]) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; Vis[Now] = false ; for (int i = H2[Now] ; i ; i = G[i].Next) if (D[G[i].T] &gt; D[Now] - C[G[i].T]) &#123; D[G[i].T] = D[Now] - C[G[i].T] ; if (! Vis[G[i].T]) Vis[G[i].T] = 1, Q.push(G[i].T) ; &#125; &#125;&#125;int D2[MAXN] ;inline void Spfa2() &#123; memset(D2, 0, sizeof(D2)) ; memset(Vis, 0, sizeof(Vis)) ; while (! Q.empty()) Q.pop() ; D2[B[1]] = - C[B[1]] ; Vis[B[1]] = 1 ; Q.push(B[1]) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; Vis[Now] = false ; for (int i = H3[Now] ; i ; i = V[i].Next) if (D2[V[i].T] &gt; D2[Now] - C[V[i].T]) &#123; D2[V[i].T] = D2[Now] - C[V[i].T] ; if (! Vis[V[i].T]) Vis[V[i].T] = 1, Q.push(V[i].T) ; &#125; &#125; &#125;int main() &#123; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; int A = Read(), B = Read() ; Add(A, B) ; &#125; for (int i = 1 ; i &lt;= N ; i ++) if (! Dfn[i]) Tarjan(i) ; for (int i = 1 ; i &lt;= Cnt ; i ++) for (int j = 0 ; j &lt; Point[i].size() ; j ++) for (int k = H[Point[i][j]] ; k ; k = E[k].Next) if (B[Point[i][j]] != B[E[k].T]) &#123; Add2(B[Point[i][j]], B[E[k].T]) ; Add3(B[E[k].T], B[Point[i][j]]) ; &#125; Spfa() ; Spfa2() ; for (int i = 1 ; i &lt;= Cnt ; i ++) for (int j = H3[i] ; j ; j = V[j].Next) &#123; if (D[V[j].F] &lt; 0 &amp;&amp; D2[V[j].T] &lt; 0) Ans = min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]]) ; &#125; printf("%d", - Ans) ; return 0 ;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2009]Elaxia的路线]]></title>
    <url>%2F2019%2F03%2F10%2FSDOI2009-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Link很经典的图论题目，分析下来不是特别有难度，算是比较简单的一类拓扑题吧。首先对于题目给定的$S1,S2,T1,T2$肯定要分别求一遍最短路，而我们选择的是从这四个节点出发分别求对所有点的最短路，得到$Dist[1 -&gt; 4][i]$分别表示$S1,T1,S2,T2$出发到第$i$个节点的最短路。因为题目是无向图，所以考虑重新建图变成$DAG$。在这之前我们要知道一个结论，就是这个最长公共路经一定是一条链，具体很好推，瞎证一证就可以了。所以如果我们在这里有了一张关于$S1 -&gt; T2$的所有最短路组成的$DAG$，那么其最长公共路经一定在这个图上，反过来$S2-&gt;T2$也是成立的。所有我们取一个交集，就知道怎么建图了：1.首先大循环是建一个$S1-&gt;T1$的图，对于某一条边$(Now-&gt;To)$，我们只需要判断$S1-&gt;Now-&gt;To-&gt;T1$这条路经是不是$S1-&gt;T1$的最短路就可以了。于是 1if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) 2.之后循环的是$S2-&gt;T2$，和上面一样，但是为了保证$S2-&gt;Now-&gt;T-&gt;T2$和$S2-&gt;T-&gt;Now-&gt;T2$这两种情况都可以考虑到，我们需要分别考虑。12345678for (int i = 1 ; i &lt;= Tot ; i ++) if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) &#123; if (Dist[3][E[i].F] + E[i].L + Dist[4][E[i].T] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else if (Dist[3][E[i].T] + E[i].L + Dist[4][E[i].F] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else Add2(E[i].F, E[i].T, E[i].L, 0) ;&#125; 看到这个建新图的函数$Add2()$中最后有一个关于$1$和$0$的参数，这个是为了表达在拓扑排序中是否需要计入答案的,也就是说这条边是不是在两条最短路的交集上（好绕~。然后就是一个拓扑排序了，直接从$S1$跑到$T1$，然后在其中对答案取$max$就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 800010 ;const int MAXM = 800010 ;const int Inf = 0x7fffffff ;int N, M, D[MAXN], H[MAXN], Tot, Ans[MAXN] ;int S1, S2, T1, T2, Dist[6][MAXN], Ind[MAXN] ;struct EDGE&#123; int F ; int T ; int Next ; int L ;&#125; E[MAXM &lt;&lt; 1] ;int H2[MAXN], Tot2 ;struct EDGE2 &#123; int F ; int T ; int Next ; int L ; bool P ;&#125; Ed[MAXM &lt;&lt; 1] ;struct NODE &#123; int Num ; long long Len ; bool operator &lt; (const NODE &amp; B) const &#123; return Len &gt; B.Len ; &#125;&#125; Node ;bool Vis[MAXN] ;priority_queue&lt;NODE&gt; Q ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F, E[Tot].T = T, E[Tot].L = L ; E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Add2(int F, int T, int L, int P) &#123; Ed[++ Tot2].F = F, Ed[Tot2].T = T, Ed[Tot2].L = L ; Ed[Tot2].Next = H2[F], H2[F] = Tot2, Ed[Tot2].P = P ;&#125;inline void Dijkstra(int S, int Num) &#123; memset(D, 127, sizeof(D)) ; memset(Vis, 0, sizeof(Vis)) ; while (! Q.empty()) Q.pop() ; D[S] = 0 ; Vis[S] = 0 ; Node.Num = S ; Node.Len = 0 ; Q.push(Node) ; while (! Q.empty()) &#123; NODE Now = Q.top() ; Q.pop() ; if (Vis[Now.Num]) continue ; for (int i = H[Now.Num] ; i ; i = E[i].Next) if (! Vis[E[i].T]) if (D[E[i].T] &gt; D[Now.Num] + E[i].L) &#123; D[E[i].T] = D[Now.Num] + E[i].L ; Q.push(Node = &#123;E[i].T, D[E[i].T]&#125;) ; &#125; &#125; for (int i = 1 ; i &lt;= N ; i ++) Dist[Num][i] = D[i] ;&#125;queue&lt;int&gt; Que ;inline void Topo() &#123; Que.push(S1) ; while (! Que.empty()) &#123; int Now = Que.front() ; Que.pop() ; for (int i = H2[Now] ; i ; i = Ed[i].Next) &#123; Ind[Ed[i].T] -- ; if (! Ind[Ed[i].T]) Que.push(Ed[i].T) ; Ans[Ed[i].T] = max(Ans[Ed[i].T], Ans[Now] + Ed[i].L * Ed[i].P) ; &#125; &#125;&#125;int main() &#123; N = Read(), M = Read() ; S1 = Read(), T1 = Read(), S2 = Read(), T2 = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; int F = Read(), T = Read(), L = Read() ; Add(F, T, L) ; Add(T, F, L) ; &#125; Dijkstra(S1, 1) ; Dijkstra(S2, 3) ; Dijkstra(T1, 2) ; Dijkstra(T2, 4) ; for (int i = 1 ; i &lt;= Tot ; i ++) if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) &#123; if (Dist[3][E[i].F] + E[i].L + Dist[4][E[i].T] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else if (Dist[3][E[i].T] + E[i].L + Dist[4][E[i].F] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else Add2(E[i].F, E[i].T, E[i].L, 0) ; Ind[E[i].T] ++ ; &#125; Topo() ; printf("%d\n", Ans[T1]) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2004]嗅探器]]></title>
    <url>%2F2019%2F03%2F10%2FZJOI2004-%E5%97%85%E6%8E%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link2004年的水题，10分钟就过了…我也不知道为什么难度是省选/NOI-，可能是恶意评分吧。很简单，这个节点一定在两个中心节点中间的割点上。然后我们还有两个需要判断的东西： $Dfn[T] &gt;= Dfn[E[i].T]$啥意思呢，就是说$T$，也就是我们在这两个中心节点中选的一个当做终点，要在$E[i].T$之后被搜到，这样可以保证使得$Now$是必经之路。 $Low[T] &gt;= Dfn[Now]$也就是保证要经过$Now$点。以上两个都是为了确保$Now$是两个中心节点的必经之路。然后还要记得判断一下$Now != S &amp;&amp; Now != T$，不在两个中心节点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 5010 ;const int MAXM = 5010 ;const int Inf = 100000000 ;int N, M, Dfn[MAXN], Low[MAXN], Tot, H[MAXN], Ken ;bool Cut[MAXN] ; int S, T, Ans = Inf ;struct Node &#123; int F, T, Next ;&#125; E[MAXN &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add (int F, int T) &#123; E[++ Tot].F = F, E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = Low[Now] = ++ Ken ; for (int i = H[Now] ; i ; i = E[i].Next) &#123; if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ; if (Now != S &amp;&amp; Now != T) if (Dfn[Now] &lt;= Low[E[i].T]) if (Dfn[E[i].T] &lt;= Dfn[T]) if (Dfn[S] &lt;= Low[T]) Ans = min(Ans, Now) ; &#125; Low[Now] = min(Low[Now], Dfn[E[i].T]) ; &#125;&#125;int main() &#123; cin &gt;&gt; N ; int A, B ; do &#123; cin &gt;&gt; A &gt;&gt; B ; Add(A, B) ; Add(B, A) ; &#125; while (A + B) ; cin &gt;&gt; S &gt;&gt; T ; Tarjan(S) ; if (Ans == Inf) puts("No solution") ; else &#123;printf("%d", Ans) ;&#125; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Noip2013]车站分级]]></title>
    <url>%2F2019%2F03%2F09%2FNoip2013-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Link很脑缺的一道题，我也不知道自己为什么要整这个。首先我们把题目转化一下，也就是在$i$车站之后没有停靠的火车站，其级别肯定都是低于$i$的级别。于是我们有了一堆车站的大小关系，选择从小级别的车站像大级别的车站连边，然后跑一下拓扑排序就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010 ;const int MAXM = 1010 ;const int Inf = 0x7fffffff ;int N, M, Train[MAXN][MAXN], S[MAXN], H[MAXN], Tot, Ans ;bool V[MAXN], Link[MAXN][MAXN] ; int Ind[MAXN] ;struct Node &#123; int F ; int T ; int Next ;&#125; E[MAXN &lt;&lt; 10] ;//数组大小一定要开够，不然会爆炸.....struct Node2 &#123; int Num ; int Level ;&#125; G ;queue&lt;Node2&gt; Q ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add (int F, int T) &#123; E[++ Tot].F = F ; E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Topo() &#123; Ans = 1 ; for (int i = 1 ; i &lt;= N ; i ++) if (! Ind[i]) Q.push(&#123;i, 1&#125;) ; while (! Q.empty()) &#123; int Now = Q.front().Num, L = Q.front().Level ; Q.pop() ; for (int i = H[Now] ; i ; i = E[i].Next) &#123; Ind[E[i].T] -- ; if (! Ind[E[i].T]) Q.push(&#123;E[i].T, L + 1&#125;), Ans = max(Ans, L + 1) ; &#125; &#125;&#125;int main() &#123; N = Read(), M = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; S[i] = Read() ; memset(V, 0, sizeof(V)) ; for (int j = 1 ; j &lt;= S[i] ; j ++) Train[i][j] = Read(), V[Train[i][j]] = 1 ; for (int j = Train[i][1] ; j &lt;= Train[i][S[i]] ; j ++) &#123; if (! V[j]) for (int k = 1 ; k &lt;= S[i] ; k ++) if (! Link[j][Train[i][k]]) &#123; Ind[Train[i][k]] ++ ; Add(j, Train[i][k]) ; Link[j][Train[i][k]] = 1 ; &#125; &#125; &#125; Topo() ; printf("%d", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Noip</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2014]数表]]></title>
    <url>%2F2019%2F03%2F08%2FSDOI2014-%E6%95%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Link对于 \sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j))这个式子来说，我们首先把它变换一下改变枚举顺序 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ N \sum_{j = 1} ^ M [gcd(i,j) == d]把$d$除过去 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} [gcd(i,j) == 1]把最后的式子莫比乌斯反演一下 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} \sum _{x | i, x | j} \mu (x)把$x$的枚举挪到前面去。 \sum_{d = 1} ^{N} F(d) \sum _{x = 1} ^ {N / d}\mu (x) \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor设$T = dx$，然后再变一下枚举顺序。 \sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \sum_{d | T} F(d) \mu (\frac{T}{d})然后发现出现了狄雷克利卷积，这就非常棒。然后我们记一个 G(T) = \sum_{d | T} F(d) \mu (\frac{T}{d})然后式子变成 \sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor G(T)这道题比较难的地方就在于其要求不大于$a$。于是我们将原来的$F(x)$函数加上一个$a$的限制。然后发现$F(d) \leq a$时对答案产生贡献。对于随着$a$的变化而变化的$G(x)$，采取离线筛选然后升序排序的情况。然后问题转化成了一个很熟悉的形式： 每次加入$d$满足$F(d) \leq a$ 查询前缀和。然后我们就可以用树状数组来进行维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const long long MAXN = 100010 ;const long long MAXM = 100010 ;const long long Inf = 0x7fffffff ;const long long Mod = (1LL &lt;&lt; 31) ;long long T ;long long U[MAXN], F[MAXN], S[MAXN], P[MAXN] ;long long Sum[MAXN], Ans[MAXN], Tot, B[MAXN] ;struct Node &#123; long long N, M, A, Num ; bool operator &lt; (const Node &amp; Y) const &#123; return A &lt; Y.A ; &#125;&#125; E[MAXN] ;struct Node2 &#123; long long X ; bool operator &lt; (const Node2 &amp; Y) const &#123; return S[X] &lt; S[Y.X] ; &#125;&#125; G[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Init () &#123; S[1] = U[1] = 1 ; for (long long i = 2 ; i &lt;= MAXN ; i ++) &#123; if (! B[i]) &#123; P[Tot ++] = i ; U[i] = - 1 ; S[i] = i + 1 ; F[i] = i + 1 ; &#125; for (long long j = 0 ; j &lt; Tot ; j ++) &#123; if (i * P[j] &gt; MAXN) break ; B[i * P[j]] = 1 ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] * P[j] + 1 ; S[i * P[j]] = S[i] / F[i] * F[i * P[j]] ; break ; &#125; U[i * P[j]] = - U[i] ; F[i * P[j]] = P[j] + 1 ; S[i * P[j]] = S[i] * (P[j] + 1) ; &#125; &#125; for (long long i = 1 ; i &lt;= MAXN ; i ++) G[i].X = i ; sort(G + 1, G + MAXN + 1) ;&#125;inline long long Lowbit(long long Now) &#123; return Now &amp; (- Now) ; &#125; ;inline void Add(long long Now, long long K) &#123; while (Now &lt;= MAXN) &#123; Sum[Now] = ((LL) Sum[Now] + K) % Mod ; Now += Lowbit(Now) ; &#125; return ;&#125;inline void Change(long long Now) &#123; for (long long i = 1 ; i * Now &lt;= MAXN ; i ++) &#123; // cout &lt;&lt; U[i] &lt;&lt; " " &lt;&lt; S[Now]&lt;&lt; " " &lt;&lt; (LL) U[i] * S[Now] % Mod &lt;&lt; endl ; // system("pause") ; Add(Now * i, (LL) U[i] * S[Now] % Mod) ; &#125;&#125;inline long long Query (long long Now) &#123; long long Ans = 0 ; while (Now &gt;= 1) &#123; Ans = ((LL) Ans + Sum[Now]) % Mod ; Now &amp;= Now - 1 ; &#125; return Ans ;&#125;inline long long Answer(long long L, long long R) &#123; long long Ans = 0, ll = 0, rr ; for (long long l = 1, r ; l &lt;= L ; l = r + 1, ll = rr) &#123; r = min (L / (L / l), R / (R / l)) ; rr = Query(r) ; Ans = (Ans + ((LL) rr - ll) % Mod * (L / l) % Mod * (R / l) % Mod) % Mod; &#125; return ((LL) Ans + Mod) % Mod ;&#125;int main() &#123; T = Read() ; Init() ; for (long long i = 1 ; i &lt;= T ; i ++) &#123; E[i].N = Read(), E[i].M = Read(), E[i].A = Read() ; if (E[i].N &gt; E[i].M) swap(E[i].N, E[i].M) ; E[i].Num = i ; &#125; sort(E + 1, E + T + 1) ; long long j = 1 ; for (long long i = 1 ; i &lt;= T ; i ++) &#123; for (; j &lt;= MAXN &amp;&amp; S[G[j].X] &lt;= E[i].A ; j ++) Change(G[j].X) ; Ans[E[i].Num] = Answer(E[i].N, E[i].M) ; &#125; for (long long i = 1 ; i &lt;= T ; i ++) printf("%lld\n", Ans[i]) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>树状数组</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2011]MET-Meteors]]></title>
    <url>%2F2019%2F03%2F05%2FPOI2011-MET-Meteors%2F</url>
    <content type="text"><![CDATA[Link考虑朴素算法，循环$K$次，每次循环$1$到$N$增加相应的$[L,R,A]$，然后$O(N)$判断某一个数是不是已经合法。这样的算法的时间复杂度是$O(N^3)$，那么我们考虑逐步优化。 首先区间加我们肯定可以使用线段树或者树状数组，这里使用的是后者。 改换一下枚举顺序就可以变成先枚举每一个数，然后枚举$K$次，然后我们发现枚举$K$次的这个步骤是单调的，因为对于某一个数，如果在$X$次区间加之后没有合法，那么在之前肯定也是不合法的，如果在$X$次区间加之后是合法的，那么在这之后肯定也是合法的，所以这个枚举$K$的步骤是单调的，于是可以考虑二分答案。那么总步骤就得出来了： 枚举每一个位置 二分区间加的次数 树状数组区间加 总时间复杂度$O(Nlog^2N)$12]]></content>
      <categories>
        <category>题解</category>
        <category>POI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]超级钢琴]]></title>
    <url>%2F2019%2F03%2F03%2FNOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%2F</url>
    <content type="text"><![CDATA[Link我们先来考虑朴素算法：将所有的方案求出来，然后排序。但是这样当然是不可能过的。对于某一个区间的综合我们肯定很自然地想到前缀和。那首先定住一个左节点$X$，那么这个区间的右端点肯定处于$[X + L - 1, X + R - 1]$之间。那么如果我们想要求这个区间里面的最大值，可以考虑使用询问时间复杂度为$O(1)$的$ST$表。如果右端点为$Y$，那么区间的值就是$Sum[Y] - Sum[X]$，那么我们可以直接寻找右端点区间中的$Sum[i]$的最大值。然后我们就得到了一堆区间的最大值，一共应该是$N - R + 1$，但是$K$是有可能大于这个数的，因此我们不能只求这个区间的最大值。于是考虑将这个区间二分。具体来说，就是首先将所有以$i$左端点，右端点在$[X + L - 1, X + R - 1]$的一个结构体存储到一个大根堆中，当然，本人使用的是单调队列，因为这样结构比较清晰。然后循环$K$次，每次取出堆顶计入答案。接下来的操作是以当前答案所处的右端点为中间，二分$[X + L - 1, X + R - 1]$这个区间，分别加入单调队列。因为如果想要寻找原来右端点区间中的第二大，第三大，我们选择去掉当前的最大值，然后将它的左边和右边分别入队，算法正确性就可以保证了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 500010 ;const int MAXM = 500010 ;const int Inf = 0x7fffffff ;LL N, K, L, R, Muc[MAXN] ;long long Sum[MAXN], Max[MAXN][20] ;long long Ans ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void ST_BUILD() &#123; for (int i = 1 ; i &lt;= N ; i ++) Max[i][0] = i ; for (int j = 1 ; (1 &lt;&lt; j) &lt;= N ; j ++) for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= N ; i ++) &#123; int X = Max[i][j - 1] ; int Y = Max[i + (1 &lt;&lt; (j - 1))][j - 1] ; if (Sum[X] &gt; Sum[Y]) Max[i][j] = X ; else Max[i][j] = Y ; &#125;&#125;inline int Query(int L, int R) &#123; int T = log2(R - L + 1) ; int X = Max[L][T], Y = Max[R - (1 &lt;&lt; T) + 1][T] ; return Sum[X] &gt; Sum[Y] ? X : Y ;&#125;struct Q &#123; int X, L, R, P ; Q() &#123;&#125; Q (int X, int L, int R) : X(X), L(L), R(R), P(Query(L, R)) &#123;&#125; friend bool operator &lt; (const Q &amp; A, const Q &amp; B) &#123; return Sum[A.P] - Sum[A.X - 1] &lt; Sum[B.P] - Sum[B.X - 1] ; &#125;&#125; ;priority_queue&lt;Q&gt; E ;int main() &#123; N = Read(), K = Read(), L = Read(), R = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; Muc[i] = Read() ; Sum[i] = Sum[i - 1] + Muc[i] ; &#125; ST_BUILD() ; for (int i = 1 ; i &lt;= N ; i ++) if (i + L - 1 &lt;= N) E.push(Q(i, i + L - 1, min(i + R - 1, N))) ; for (int i = 1 ; i &lt;= K ; i ++) &#123; int X = E.top().X, l = E.top().L, r = E.top().R, P = E.top().P ; E.pop() ; Ans += Sum[P] - Sum[X - 1] ; if (l != P) E.push(Q(X, l, P - 1)) ; if (r != P) E.push(Q(X, P + 1, r)) ; &#125; printf("%lld\n", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>前缀和</tag>
        <tag>堆</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2009]粉刷匠]]></title>
    <url>%2F2019%2F03%2F03%2FSCOI2009-%E7%B2%89%E5%88%B7%E5%8C%A0%2F</url>
    <content type="text"><![CDATA[Link2019的四川NOI题目，很经典的动态规划题目。首先设$Dp[i][j][k][l]$表示当到达$(i,~j)$点的时候恰好用了$k$次粉刷的机会，其中$l$只有$0$和$1$两种取值，因为题目中说的一个格子如果没有被粉刷或者粉刷上了错误的颜色都算粉刷错误，因此我们可以将这两种情况分开来看，统一成$0$，如果粉刷对了就是$1$。状态转移：对于每一次换木板的时候要刷一次，那么最优情况下，也就是跟前一个木板完全一样的情况下，我们将上一块木板的$Dp$转移过来就可以了。记住要把$1$和$0$的状态都转移过来。 Dp[i][j][k][0] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) ; Dp[i][j][k][1] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) + 1 ;然后对于上一个格子和当前格子的颜色都一样的话，我们就像换行一样进行处理。将上一个格子的状态直接转移过来就可以了。 Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1, Dp[i][j][k][0] = Dp[i][j - 1][k][0] ;如果上一个格子的颜色与当前格子的颜色不一样，那么可以选择 继续上一个格子的颜色，不减少机会，但是当前的格子就错误了。 减少一次机会，换一个k，当前的格子粉刷正确。 Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ; Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ;所以从思路上来说是非常简单的，只要你能想到是几维的Dp，接下来的转移方程基本是水到渠成的。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 60 ;const int MAXM = 60 ;const int MAXT = 2510 ;int N, M, K, Color[MAXN][MAXM], Dp[MAXN][MAXM][MAXT][2], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read(), M = Read(), K = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; string A ; cin &gt;&gt; A ; for (int j = 1 ; j &lt;= M ; j ++) Color[i][j] = A[j - 1] - '0' ; &#125; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 1 ; j &lt;= M ; j ++) for (int k = 1 ; k &lt;= K ; k ++) &#123; if (j == 1) Dp[i][j][k][0] = max(Dp[i - 1][M][k - 1][0], Dp[i - 1][M][k - 1][1]), Dp[i][j][k][1] = max(Dp[i - 1][M][k - 1][0], Dp[i - 1][M][k - 1][1]) + 1 ; else if (Color[i][j] == Color[i][j - 1]) Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1, Dp[i][j][k][0] = Dp[i][j - 1][k][0] ; else &#123; Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ; Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ; &#125; Ans = max(Ans, max(Dp[i][j][k][0], Dp[i][j][k][1])) ; &#125; printf("%d", Ans) ; return 0;&#125; 后记没有写滚动数组，追求完美的当然可以滚动，但是不滚动数组也依然能过啦~。]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2009]虔诚的墓主人]]></title>
    <url>%2F2019%2F02%2F25%2FSDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[Link 讲解转化一下题目的要求，假设我们知道点$(i,j)$的上下左右的常青树的个数分别为$U[i][j]$，$D[i][j]$，$L[i][j]$和$R[i][j]$，那么依据一个很简单的组合数学我们知道： Ans = C_{K}^{U[i][j]} \times C_{K}^{D[i][j]} \times C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}其中$C$为组合。基本的思路就是这样，但是我们要考虑优化。从空间上来说，$1 \leq N, M \leq 1000000000$，肯定会直接爆炸（并且空间限制还是$128MB$）。题目并不要求十分确切的常青树位置，因此可以直接离散化。于是我们可以将坐标离散到一个$W \times W$的图中，因为$1 \leq W \leq 10000$，因此空间的问题就直接解决了。然后是时间，对于每一个墓地，原始做法是$O(N^2)$的求出上下左右的四个数组，但是最终的时间复杂度是$O(N^4)$。于是对于优化来说这里用到一个扫描线的思想。对于扫描线的具体讲解可以直接$Google$，这里只是针对题目讲方法罢了。将所有的常青树按照$X$为第一关键字，$Y$为第二关键字的方法升序排序。对于同一行的两个常青树，如果中间没有任何常青树，那么发现中间的所有的墓地的$L[i][j]$和$R[i][j]$都相等，因此只需要前缀和预处理出来 \sum_{i}^{N} \sum_{j}^M C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}即可，下面要求的就只剩下了$U[i][j]$和$D[i][j]$。 维护上下所有常青树的乘积，而左右乘积的改变次数就等于常青树的个数，而考虑其他行的时候上下乘积的改变次数也就是常青树的个数。 于是我们要维护上下组合数的乘积的区间和，这种维护显然就可以线段树或者树状数组。 步骤对于同一行的两个数$A$和$B$，$Ans += C_{k}^{L[A]} \times C_{k}^{R[B]}$，然后用树状数组维护$A$和$B$点的$C_{k}^{U[i]} \times C_{k}^{D[i]}$的和。（省略掉了列，因为是同一行嘛） 答案实际上就是 \sum C_{k}^{L[A]} \times C_{k}^{R[B]} \times \sum [C_{k}^{U[i]} \times C_{k}^{D[i]}]从左向右处理的时候，修改树状数组该点横坐标位置上的数值为 C_{k}^{U[i]} \times C_{k}^{D[i]} - C_{k}^{U[i] + 1} \times C_{k}^{D[i] +1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int Inf = 0x7ffffff ;const int Mod = 2147483647 ;int N, M, W, K, S[MAXN], C[MAXN][11] ;int X[MAXN], Y[MAXN], Ans ;struct Node &#123; int X, Y, L, R, U, D ;&#125; E[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;struct BIT &#123; int Sum[MAXN] ; inline int Lowbit(int Now) &#123; return Now &amp; ( - Now) ; &#125; inline void Add(int Now, int K) &#123; while (Now &lt;= W) &#123; Sum[Now] += K ; Now += Lowbit(Now) ; &#125; &#125; inline int Query(int Now) &#123; int Ans = 0 ; while (Now &gt; 0) &#123; Ans += Sum[Now] ; Now -= Lowbit(Now) ; &#125; return Ans ; &#125;&#125; Bit ;inline bool CMP(Node A, Node B) &#123; if (A.Y != B.Y) return A.Y &lt; B.Y ; else return A.X &lt; B.X ;&#125;inline void Init() &#123; for (int i = 0 ; i &lt;= W ; i ++) &#123; C[i][0] = 1 ; for (int j = 1 ; j &lt;= min(K, i); j ++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1] ; &#125; sort(E + 1, E + W + 1, CMP) ; int Ken = 0 ; for (int i = 1 ; i &lt;= W ; i ++) &#123; if (E[i].Y == E[i - 1].Y) Ken ++ ; else Ken = 1 ; E[i].L = Ken ; S[E[i].X] ++ ; E[i].U = S[E[i].X] ; &#125; Ken = 0 ; for (int i = W ; i &gt;= 1 ; i --) &#123; if (E[i].Y == E[i + 1].Y) Ken ++ ; else Ken = 1 ; E[i].R = Ken ; E[i].D = S[E[i].X] - E[i].U ; &#125;&#125;int main() &#123; N = Read(), M = Read(), W = Read() ; for (int i = 1 ; i &lt;= W ; i ++) &#123; E[i].X = Read(), E[i].Y = Read() ; X[i] = E[i].X ; Y[i] = E[i].Y ; &#125; K = Read() ; sort(X + 1, X + W + 1) ; sort(Y + 1, Y + W + 1) ; for (int i = 1; i &lt;= W ; i ++) &#123; E[i].X = lower_bound(X + 1, X + W + 1, E[i].X) - X ; E[i].Y = lower_bound(Y + 1, Y + W + 1, E[i].Y) - Y ; &#125; Init() ; for (int i = 1 ; i &lt;= W ; i ++) &#123; int V = Bit.Query(E[i].X) - Bit.Query(E[i].X - 1) ; Bit.Add(E[i].X, - V) ; Bit.Add(E[i].X, C[E[i].U][K] * C[E[i].D][K]) ; if (E[i].Y == E[i - 1].Y) Ans = Ans + C[E[i - 1].L][K] * C[E[i].R][K] * (Bit.Query(E[i].X - 1) - Bit.Query(E[i - 1].X)); &#125; printf("%d", Ans &amp; Mod) ; return 0 ;&#125; 后记有人说可不可以搞一个二维线段树，思路上来说是可行的，但是空间上大概会爆炸吧~。最后在冲浪的时候发现由于模数为$2147483647$所以可以自然溢出然后最后$ \&amp; 2147483646$就可以了。]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>组合数学</tag>
        <tag>线段树</tag>
        <tag>离散化</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2012]FES-Festival]]></title>
    <url>%2F2019%2F02%2F23%2FPOI2012-FES-Festival%2F</url>
    <content type="text"><![CDATA[Link看到题目首先肯定想到差分约束，当然这也是一个差分约束的题。题目比较难想的地方在于建图，设$Dist[i][j]$表示$max\{A_i - A_j\}$，也就是$A_i$最多能比$A_j$大多少。那么根据题意我们知道对于第一种情况，应该是 Dist[X][Y] = 1,~Dist[Y][X] = - 1然后对于第二种情况，题目对数量上并没有限制，限制的只是大小关系，然而我们转化一下依然能知道$A_Y - A_X \geq 0$，对此我们选择从$Y$向$X$连一条边权为零的单项边，然后$Dist[Y][X] = 0$，对于这种情况我们连边的目的不是为了限制数值，而是为了限制关系，大小关系。由于限制条件可以叠加，于是对于每一个建边都要取$min$。然后首先要考虑的肯定是合法问题。稍加分析我们可以知道图如果存在非零环，肯定是不合法的，于是我们考虑判断非零环。一般来说判负环就是简单地跑一遍$Spfa$然后记录每一个点入队的次数就可以解决。但是这个题有一点问题。就是这个图并不一定是联通的。所以不论以哪一个节点作为起点都是不能保证的。因此舍弃$Spfa$，观察数据发现$N \leq 600$非常的小，完全可以考虑$Floyed$，使用弗洛伊德的判断负环的方式就是看有没有$Dist[i][i] != 0$，然后弗洛伊德怎么解决问题了呢？因为图并不是联通的，但是只要每一个强连通分量合法就可以了，于是我们考虑$Tarjan$缩点，然后对于每一个强联通分量分别求解。在三重循环的过程中判断$i,j,k$是不是都属于一个强连通分量，然后就可以有一个小小的优化。缩完点之后发现剩下的就是连接每一个联通块的零权边，对答案并没有影响，只会影响关系，并且我们设的$Dist[i][j]$表示的是$i,j$的最大差值，于是就可以寻找每一个强联通分量里面的最大值。并且每一个强联通分量在数值上没有关系，因此将答案直接累加即可，最后输出答案加上强连通分量的数量。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define RE registerusing namespace std ;typedef long long LL ;const int MAXN = 610 ;const int MAXM = 100010 ;const int Inf = 1000000000 ;int N, M1, M2, D[MAXN], H[MAXN], Tot ;int Low[MAXN], Dfn[MAXN], B[MAXN] ;int S[MAXN], Top, Ken, Cnt, Ans ; bool Insta[MAXN], Inq[MAXN], V[MAXN] ;int Num[MAXN], Max, Dist[MAXN][MAXN] ;queue &lt;int&gt; Q ;struct Node &#123; int F, T, L, Next ;&#125; E[MAXM &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F, E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = Low[Now] = ++ Ken ; S[++ Top] = Now ; Insta[Now] = 1 ; for (RE int i = H[Now] ; i ; i = E[i].Next) if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ; &#125; else if (Insta[E[i].T]) Low[Now] = min(Dfn[E[i].T], Low[Now]) ; if (Dfn[Now] == Low[Now]) &#123; Cnt ++ ; int Pass ; do &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Insta[Pass] = false ; &#125; while (Pass != Now) ; &#125;&#125;int main() &#123; N = Read(), M1 = Read(), M2 = Read() ; for (RE int i = 1 ; i &lt;= N ; i ++) for (RE int j = 1 ; j &lt;= N ; j ++) Dist[i][j] = Inf ; for (RE int i = 1 ; i &lt;= M1 ; i ++) &#123; int X = Read(), Y = Read() ; Add(X, Y, 1) ; Add(Y, X, - 1) ; Dist[X][Y] = min(Dist[X][Y], 1) ; Dist[Y][X] = min(Dist[Y][X], - 1) ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) Dist[i][i] = 0 ; for (RE int i = 1 ; i &lt;= M2 ; i ++) &#123; int X = Read(), Y = Read() ; Add(Y, X, 0) ; Dist[Y][X] = min(Dist[Y][X], 0) ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) if (! Dfn[i]) Tarjan(i) ; for (RE int k = 1 ; k &lt;= N ; k ++) for (RE int i = 1 ; i &lt;= N ; i ++) if (B[k] == B[i]) for (RE int j = 1 ; j &lt;= N ; j ++) if (B[i] == B[j]) Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]) ; for (RE int i = 1 ; i &lt;= N ; i ++) if (Dist[i][i] != 0) &#123; puts("NIE") ; return 0 ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) for (RE int j = 1 ; j &lt;= N ; j ++) if (B[i] == B[j]) D[B[i]] = max(D[B[i]], Dist[i][j]) ; for (RE int i = 1 ; i &lt;= N ; i ++) Ans += D[i] ; printf("%d\n", Ans + Cnt) ; return 0 ;&#125; 最后发现弗洛伊德跑还是比较慢，最后加了很多$register$和$inline$才勉强卡过去。后来知道有一个非常神奇的深搜版$Spfa$，应该是可以更好地解决这个问题的。]]></content>
      <categories>
        <category>题解</category>
        <category>POI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
        <tag>Floyed</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]墨墨的等式]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%A2%A8%E5%A2%A8%E7%9A%84%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Link题意大概就是求$B_l,B_r$范围内$B$的个数使等式 \sum_{i = 1}^N a_Nx_N = B存在非负整数解。其实转化一下题意也就是 在N种物品中任意选择，物品有一个价值，使得最后的总价值处于给定区间内。 这很显然是一个完全背包，而且是类似于一种模板题，但是这道题的数据范围是$B \leq 10^{12}$，因此这么做显然是不行的，但是我们可以从完全背包的视角出发思考题目。我们取出最小的$a$为$a_{min}$,并且假设我们现在知道了一种方案，物体的总重为$D[i]$，并且满足K ~mod~ a_{min} = i，在这两种条件下$D[i]$为最小值。那么显然，对于任意一个同样满足上述两个条件的总重X，$X \leq D[i]$，并且因为$X ~mod~ a_{min} = D[i] ~mod~ a_{min}$，所以可以知道$X$方案可以由$D[i]$方案加上若干个$a_{min}$得到。现在我们考虑加入一个物体$Now$，那么有 D[(i + Now) ~mod~ a_{min}]可以从$d[i] + Now$而来。于是可以考虑从i向$(i + Now) ~mod~ a_{min}$连一条比边权为$Now$的边，而求$D[i]$的最小值也就被转化成了最短路问题。那么算法就得出来了： 首先求一下$a_{min}$的最小值保存下来。 跑最短路，预处理出D数组。 枚举所有的D，计算mod T = i的数在区间$B_l,B_r$中有多少个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 15 ;const int MAXM = 500010 ;LL Inf = (LL)1 &lt;&lt; 60 ;LL N, L, R, a[MAXN], H[MAXN], Tot, D[MAXM] ;struct Edge &#123;int F, T, L, Next ;&#125; E[MAXN] ;queue&lt;int&gt; Q ; bool F[MAXM] ; LL K, Ans ; inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline void Spfa(int S) &#123; memset(F, 0, sizeof(F)) ; for (int i = 1 ; i &lt; K ; i ++) D[i] = Inf ; D[S] = 0 ; F[S] = 1 ; Q.push(S) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; F[Now] = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; int T = (Now + a[i]) % K ; if (D[T] &gt; D[Now] + a[i]) &#123; D[T] = D[Now] + a[i] ; if (! F[T]) Q.push(T), F[T] = 1 ; &#125; &#125; &#125;&#125;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read(), L = Read(), R = Read() ; for (int i = 1 ; i &lt;= N ; i ++) a[i] = Read() ; sort (a + 1, a + N + 1) ; K = a[1] ; //储存最小的a。 Spfa(0) ; for (int i = 0 ; i &lt; K ; i ++) if (D[i] != Inf) D[i] = (D[i] - i) / K ; for (int i = 0 ; i &lt; K ; i ++) if (D[i] != Inf) &#123; int K1 = (L - i - 1) / K - D[i] + 1 ; int K2 = (R - i) / K - D[i] + 1 ; Ans = Ans - max(K1, 0) + max(K2, 0) ; &#125; printf("%lld", Ans) ; return 0 ;&#125; 这种在求解用$\{a_i\}$能组成多少个在$B_l, B_r$范围内的数的问题其实是很经典的图论问题，像这种建图困难，但是最短路很好跑的题目便可以称为是建图题了。]]></content>
      <categories>
        <category>题解</category>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]Crash的数字表格]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Link如题，给定$N$和$M$，求 \sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)有人说这道题是BZOJ上面的JZPTAB，但其实不是，JZBTAB虽然具体问题和改题是一样的，但是那道题是多组询问，比这道题还要难一些。首先我们知道$lcm(i,j) = \frac{i \times j}{gcd(i,j)}$，那么题目转化为 \sum_{i = 1}^N \sum_{j=1}^M \frac{i \times j}{gcd(i,j)}然后我们枚举最大公约数，式子转化为 \sum_{d = 1}^{min(N,M)} \sum_{i = 1} ^ N \sum_{j = 1}^ M \frac{i \times j}{d} [gcd(i,j) == d]提出d,式子变成 \sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d}[gcd(i, j) == 1] \times ij并且我们知道 \sum_{d|N}\mu (d) = [N == 1]直接带入上面的式子可以得到 \sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d} \sum_{x|gcd(i,j)} \mu (x) \times ij保留前缀和$S[i]$，优先枚举$x$。 \sum _{d = 1} ^ N d \sum_{x = 1}^{n / d} x ^ 2 μ (x) S(\frac {N}{dx}) S(\frac {M}{dx})优先枚举$S$ \sum_{dx = 1}^{N} S(\frac{N}{dx} S(\frac{M}{dx})dx \sum_{e|dx}e \mu(dx))对于其中的$f(dx) = dx \sum_{e|dx}e \mu(dx)$可以线性筛，有式子 f(dxp) = f(dx)f(p)之后的式子可以整除分块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;const int MAXM = 10000010 ;const int Mod = 20101009 ;int N, M, F[MAXN], P[MAXN], Tot ;bool V[MAXN] ; int Sum[MAXN], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline int MOD (int Now) &#123; if (Now &gt;= Mod) return Now - Mod ; else return Now ;&#125;inline void Init() &#123; F[1] = 1 ; for (int i = 2 ; i &lt;= min(N, M) ; i ++) &#123; if (! V[i]) &#123; P[++ Tot] = i, F[i] = MOD (Mod + 1 - i) ; &#125; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt;= min(N, M) ; j ++) &#123; V[i * P[j]] = true ; if (i % P[j]) F[i * P[j]] = 1LL * F[i] * F[P[j]] % Mod ; else &#123; F[i * P[j]] = F[i] ; break ; &#125; &#125; &#125; for (int i = 1 ; i &lt;= min(N, M) ; i ++) F[i] = MOD(F[i - 1] + 1ll * F[i] * i % Mod) ; for (int i = 1 ; i &lt;= max(N, M) ; i ++) Sum[i] = MOD(Sum[i - 1] + i) ;&#125;int main() &#123; N = Read() ; M = Read() ; Init() ; Ans = 0 ; for (int l = 1, r ; l &lt;= min(N, M) ; l = r + 1) &#123; r = min(N / (N / l), M / (M / l)) ; int Ans2 = MOD(F[r] - F[l - 1] + Mod) ; Ans = MOD(Ans + 1LL * Ans2 * Sum[N / l] % Mod * Sum[M / l] % Mod) ; &#125; printf("%d", Ans % Mod) ; return 0 ;&#125; 这道题的式子确实难推，但是时间复杂度化简到$O(N)$左右也就可以了，据说BZOJ上面的题目是真正的JZPTAB是多组数据，时间复杂度要推倒$O(\sqrt N)$才行。至于那种级别的题目，即使没有眼见为实，笔者也是有做不了的自知之明的…如果有想要了解的朋友还请另寻高就吧。]]></content>
      <categories>
        <category>题解</category>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得与扩展中国剩余定理ExCrt]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt%2F</url>
    <content type="text"><![CDATA[欧几里得算法为什么要放欧几里得算法，因为这个玩意是扩展欧几里得的铺垫，为什么要将扩展欧几里得，因为这个玩意是中国剩余定理的铺垫。很简单，就是要我们求$gcd(i,j)$。由于证明过程十分繁琐并且没有什么很大的意义，所以便不多管闲事地证明了，结论也很简单：$gcd(i,j) = gcd(j, i \% j)$。于是可以不断递归，直到j变成0，然后返回i就可以了，很常见的方法，直接放代码了。1234inline int Gcd(int X, int Y) &#123; if (Y == 0) return X ; return Gcd(Y, X % Y) ;&#125; 裴蜀定理裴蜀定理是扩展欧几里得算法的第二个铺垫，也是一个关于最大公约数的定理。假设有一个线性方程$ax + by = c$，问这个方程有没有整数解，那么根据裴蜀定理我们就知道当$gcd(a,b) | c$的时候线性方程才可能有整数解。简单的证明就是$gcd(a,b)$显然$|(ax+by)$。对于$gcd(a,b)|c$的情况有没有整数解我们便需要用到扩展欧几里得。 扩展欧几里得对于 ax + by = gcd(a,b)当$a &lt; 0$的时候，式子就可以变成 |a| (-x) + by = gcd(|a|, b)可以知道这个式子必然是有整数解的。我们可以对于$(a,b)$进行欧几里得算法，得到最大公约数，然后保存辗转相除法中的式子倒推便可以得到$ax + by = gcd(a,b)$的整数解。那么也就是证明了裴蜀定理，同时也给出了计算线性方程的整数解的方法。关于推导呢？$xa + yb = d$且有$x’b + y’(a \% b) = d$则$x’b + y’(a = \lfloor \frac ab \rfloor b) = d$$y’a + (x’ - y’ \lfloor \frac a b \rfloor) b = d$可得$x = y’, y = x’ - y \lfloor \frac ab \rfloor$推导完毕。。。123456inline int Exgcd(int a, int b, int &amp; X, int &amp; Y) &#123; if (b == 0) &#123;X = 1, Y = 0 ; return a ;&#125; int R = Exgcd(b, a % b, X, Y) ; int E = X ; X = Y ; Y = E - a / b * Y ; return R ;&#125; 中国剩余定理此算法称为扩展中国剩余定理，而中国剩余定理满足$m_i$之间两两互质，我们先从中国剩余定理说起。还是使用上面的式子，假设方程组有解。那么我们设$M = \prod_{i = 1}^nm_i$，（当然也可以设$M = Lct({m_i})$，效果是一样的）且有n个$M_i = M / m_i$，也就是除了第i个以外其他n-1个$m_i$的乘积。以及$t_i = M_i^{-1}$，则我们知道 t_iM_i \equiv 1 (mod ~ m_i)于是有结论：方程组的通解形式为 \sum _{i = 1}^n a_it_iM_i + kM以上是通解形式，而通解有无数个，对于每一个解加上$kM$依然是方程组的解，其中$k \in Z$。 证明关于证明，因为我们知道t_iM_i \equiv 1 (mod ~ 1)所以有 a_it_iM_i \equiv a_i (mod ~ m_i)而因为所有的$m_i$之间两两互质，因此对于除了$m_i$之外的所有的$m_j$都有 a_it_iM_i \equiv 0 (mod ~ m_j)因此 x = \sum _{i = 1}^ n a_it_iM_i满足 x = a_i t_i M_i + \sum _{j ≠ i}a_j t_j+M j \equiv a_i + \sum_{j ≠ i} 0 \equiv a_i (mod ~ m_i)因此，$x \equiv a_i (mod ~ m_i)$，所以$x$就是方程的一个特殊解。而至于为什么加上若干个$M$都是解我想就不用我再证明了吧。 123456789101112long long a[MAXN], m[MAXN], n ;inline long long Crt() &#123; long long M = 1 ; for (int i = 1 ; i &lt;= n ; i ++) M *= m[i] ; long long X = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; long long x, y ; long long M_i = M / m[i] ; Exgcd(M_i, m[i], x, y) ; X = (X + M_i * x * a[i]) % M ; &#125; return (X + M) % M ;&#125; 扩展中国剩余定理然后关于扩展中国剩余定理，相较之就是取消掉了$m_i$两两互质这个条件。我们依然假设$M = \sum_{i = 1}^{k - 1} m_i$，那么假设我们已经知道了前$k-1$个式子的方程通解为$x + i \times M$，那么在加入第$i$个方程后的通解，只消求出一个满足 x + t * M \equiv a_k (mod~m_k)的$t$就可以。 t \times M \equiv a_k - x~(mod ~ m_k)直接欧几里得求解$t$即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;int N ;long long A[MAXN], B[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline long long Exgcd(LL a, LL b, LL &amp; X, LL &amp; Y) &#123; if (b == 0) &#123; X = 1 ; Y = 0 ; return a ; &#125; LL R = Exgcd(b, a % b, X, Y), E = X ; X = Y ; Y = E - a / b * Y ;return R ;&#125;inline long long Quick_Mul(LL X, LL Y, LL Mod) &#123; long long Ans = 0 ; while (Y) &#123; if (Y &amp; 1) Ans = (Ans + X) % Mod ; X = (X + X) % Mod ; Y &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline long long Excrt() &#123; long long X, Y, M = B[1], Ans = A[1] ; for (int i = 2 ; i &lt;= N ; i ++) &#123; LL a = M, b = B[i], C = (A[i] - Ans % b + b) % b ; LL R = Exgcd(a, b, X, Y), E = b / R ; if (C % R != 0) return - 1 ; X = Quick_Mul(X, C / R, E) ; Ans += X * M ; M = M * E ; Ans = (Ans % M + M) % M ; &#125; return (Ans % M + M) % M ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) B[i] = Read(), A[i] = Read() ; printf("%lld", Excrt()) ; return 0 ;&#125; 后记培训的时候听$zhx$神仙讲了大骗分法：大数翻倍法。很简单，就是对于最大的$a_i$不断地把它加上$p_i$，然后合法检查就可以了。时间复杂度大概在$O(\sum_i p_i)$到$O(max(p))0$之间，据说是可以用来做题的，但是唯一不能适用的情况就是两组方程，其中$p \in 10^9$。嗯，骗分大法好。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
        <tag>扩展欧几里得</tag>
        <tag>扩展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性积分与傅里叶变换]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[文章被题目大致分为了两个部分：线性积分和 傅里叶变换。其实这么分实际上是不甚妥当的，因为傅里叶变换就是线性积分变换中的一种。如果要结合题目细讲，写起来怕是一个浩大的工程了，因此讲解的内容大多就仅止步于在信息学奥赛中的应用。当然，博主也会尽力深挖，争取让文章不只是初步。 写在前面很多人学快速傅里叶变换，学它的微分关系，学它的卷积特性，但是始终都没有思考过这个玩意是干嘛用的。毕竟本篇文章实际上想要讲的就是傅里叶变换，我们也首先要了解到傅里叶变换的作用是什么。 从数学上来说，傅里叶变换是用于解决两个多项式的 卷积，简单来说就是两个多项式相乘的次数，如果直接暴力计算，那么时间复杂度应该是$O(N^2)$，而快速傅里叶变换可以将时间复杂度降为$O(NlogN)$。这在时间维度上就体现了它宝贵的价值，因为多项式相乘的普遍性，复杂的快速傅里叶变换也渐渐走进人们的视野。 而从物理学或者工程学中，傅里叶变换的常见用途是 信号处理，而所属的信息与系统又是大学中大部分工科的基础，足以见其重要性。具体的讲就是 将给定信号把时间映射到振幅。而关于时间和频率的有关内容还请参考Heinrich关于傅里叶变换的教程：傅里叶分析之掐死教程 ，例如其在讯号处理的经典应用就是将讯号分解为振幅分量和频率分量。 线性积分变换 积分变换是数学中作用于函数的算子，用以处理微分方程等问题。 一个十分生涩的定义，我们假设当前有一个函数$f(x)$，将操作$T$表示为一个积分转换，而$f$经过此积分变换后的函数表示为$Tf(y)$：Tf(y) = \int_{x_1}^{x_2}K(x, y)f(x) dx。 其中$K()$是一个确定的含有两个参数的函数，称为此次积分变换的核函数（简称核）。而核使我们自己选择的，当我们选择不同的核函数$K()$或者积分域$(x_1,x_2)$就得到了不同的积分变换，这应该是很显然的。而相对应的，积分变换也有相对的反积分变换，也就是：f(x) = \int_{y_1}^{y_2}K^{-1}(y, x)Tf(y)dy 其中$K^{-1}(y, x)$被称为反核。 而积分变换与反积分变换构成了傅里叶变换的框架，在傅里叶变换中，核函数为$\frac{e^{ixy}}{\sqrt{2 \pi}}$，其积分域为$-\infty, \infty$。 下面我们会从基础开始一步步地将傅里叶变换拆成我们好理解的东西。 傅里叶变换多项式我想来到这里的人肯定不需要我再讲这东西了，如果果真有人不会，还请自行维基。为了讲解需要，在此强调几个多项式的概念性内容： 多项式的框架式形式：\sum_{i = 0}^{N - 1}a_ix_i 若其最高次的非零系数为$a_k$，则该多项式的次数为k。 任何一个严格大于其次数的整数都是这个多项式的次数界。 对于多项式的计算，加法显然很简单。C(x) = A(x) + B(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i = \sum_{i = 1}^{N - 1}c_ix^i 只需要将对应次数的系数相加即可，我们可以在$O(N)$的时间复杂度内得到答案。 而对于多项式乘法，方法是将$A(x)$中的每一项与$B(x)$中的每一项相乘，之后合并同类项即可。C(x) = \sum_{i = 0}^{2N - 2}c_ix_i其中$c_i = \sum_{j = 0}^ia_jb_i-j$称为两个多项式的卷积，表示为$a \otimes b$ 对于一个多项式来说我们有两种表示方法：系数表示法和点值表示法，其实两种表示方法应该是等价的，但是在计算上来说，对于点值表示的多项式，求解的时间复杂度是$O(N)$，这已经非常优秀，但是系数表示的多项式的暴力求解却是$O(N^2)$，而快速傅里叶变换就可以做到将系数表示的多项式在$O(NlogN)$的时间内求解。 对于点值表示的多项式求值运算的逆运算（已知点值表示的多项式求系数表示）称为插值，关于插值内容还请参照博主的另一篇博客：对插值法及拉格朗日插值多项式的初步理解运用。 单位复数根 N次单位复数根$\omega$满足$\omega ^N = 1$ 定义很好理解，但是这一部分作为前置知识的内容实际上算是难点了。下图表示了$n$个单位复数根均匀的分布在以复平面的原点为圆心的单位半径的圆上。 而这究竟是怎么理解呢？Heinrich的教程很形象的做了解释： 我们假设有一条长度为1的线段在一条数轴上，那么乘以-1之后的线段就与其相反，而$i = \sqrt{-1}$，那么我们将其乘以i的线段就在一个垂直的虚数轴上，于是我们就得到了一个由一个实数轴做x轴，一个虚数轴做y轴的复平面。 然后这里就可以引入另一个重要的公式：欧拉公式：$e^{ix} = cosx + i sinx$。运用这个式子我们就得到了上图的8次单位复数根，并且也知道n次单位复数根一共有n个。而这些单位根就是$e^{\frac{2 \pi i k}{n}}$我们把n次单位根的第m个写作$\omega_n^m$。 下面是单位复数根的几个性质或推论： $\omega _{d \times n}^{d \times m} = \omega _n^m$，其中$d &gt; 0$ 对于任何偶数$n&gt;0$有$\omega _n^{n/2} = \omega_2 = -1$ 对于偶数$n&gt;0$，n个n次单位复数根的平方的集合就是$\frac n2$个$\frac n2$次单位复数根的集合。 对于任意$n \geq1$ 和不能被n整除的非负整数k，有$\sum_{i = 0}^{N - 1}(\omega_n^m)^i = 0$ 至于具体的证明就不再说了，都是很简单的推论，博友们大可自行脑补，权当是练习了。 离散傅里叶变换好了铺垫完所有的前置知识之后我们终于开始了傅里叶变换的内容。对于一个次数界为n的多项式$F(x) = \sum_{i = 1} ^{n - 1}a_ix^i$，我们在插值方面的知识可以知道n个点就可以确定这个多项式，那么我们同样也可以代入n次的n个单位复数根，来确定这个多项式，可以 求出其结果k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}。 而$y​$就被称为是系数向量a的离散傅里叶变换。 这个东西计算的时间复杂度依然是$O(N^2)$，那它到底有什么用处呢？这在算法上或许无法体现，但是它是傅里叶变换在时域和频域上都呈现离散的形式，具体依然可以参考Heinrich的讲解，使其在频谱分析和数据压缩等领域发挥了巨大优势。 快速傅里叶变换也就是常说的FFT，可以说是对于DFT（离散傅里叶变换）在时间复杂度上的一大改进。 设多项式$F(x)$的系数向量$a(a_0, a_1, a_2…a_{n - 1})$，对于多项式$F(x) = \sum_{i = 0} ^ {n - 1}a_ix_i$来说，可以按照下标的奇偶性分为两个部分： F(x) = (a_0 + a_2x^2 +...+ a_{n - 2}x^{n - 2}) + (a_1 + a_3x^3...a_{n - 1}x^{n - 1})我们设 F_1(x) = a_0 + a_2x + a_4x^+...+ a_{n - 2}x^{\frac n2 - 1}F_2(x) = a_1 + a_3x + a_5x^+...+ a_{n - 1}x^{\frac n2 - 1}则 F(x) = F_1(x^2) + xF_2(x^2)和离散傅里叶变换一样，我们把$\omega _n^k$代入得到 F(\omega _n^k) = F_1(\omega _n^{2k}) + \omega _n^kF_2(\omega _n^{2k})然后同理，将$\omega _n^{k + \frac n2}$代入可以得到： F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k + n}) - F(\omega _n^kF_2(F(\omega _n^{2k} \times \omega_n^n)最后得到 F(F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k}) - \omega _n^kF_2(\omega _n^{2k})如此我们发现，两个式子化简后，只有一个常数项相反，其他都相同，于是再计算出第一个式子的时候我们可以$O(1)$求出第二个式子，并且发现两个式子将最初的范围缩小了一半，于是原问题缩小了一般，然后我们发现子问题也满足原问题性质，$k$与$k +\frac n2$同时取遍了(0, n - 1)，于是时间复杂度缩小到$O(NlogN)$。 这个算法在FFT的计算中最为常见，是在1965年由J.W.Cooley和J.W.Tuky提出的，因此也被称为Cooley-Tukey算法，实际上是基于分治的思想实现的， 快速傅里叶逆变换也称为傅里叶反变换，上文我们在线性积分变换中提到过反积分变换，而傅里叶反变换就是傅里叶变换的反积分变换，在数学中的意义是点值表示的多项式转化为系数表示，也就是说我们要从点值向量$(a_0, a_1, a_2…a_{n - 1})$得到系数向量$(y_0, y_1, y_2…y_{n - 1})$。则我们可以设$(y_0, y_1, y_2…y_{n - 1})$是$(a_0, a_1, a_2…a_{n - 1})$进行傅里叶逆变换后的结果，并设有多项式$F(x) = \sum_{i = 0} ^{n - 1}y_0x^i$，假设有向量$(c_0, c_1, c_2…c_{n - 1})$表示多项式在$\omega_n^0, \omega_n^{-1}…\omega_n^{1 - n}$上的点值表示，则向量c满足 c_k = \sum_{i = 0} ^{n - 1}y_i(\omega_n^{-k})^i然后我们考虑将式子展开。 c_k = \sum_{i = 0} ^ {n - 1}y_i(\omega _n^{-k}) ^ i= \sum_{i = 0} ^ {n - 1}(\sum_{j = 0} ^ {n - 1}a_j(\omega _n^{j} k) ^ j)(\omega_n^{-k})^i= \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i ~=~ \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)= \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1}a_j(\omega_n^{j - k})^i ~=~ \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)设一个式子 S(\omega_n^k) = \sum_{i = 0} ^{n - 1}(\omega_n^k)^i在两边同时乘一个$\omega_n^k$得： \omega_n^kS(\omega_n^k) = \sum_{i = 0} ^{n - 1}(\omega_n^k)^{(i+1)}将前后两个式子相减，得到 \omega _n^kS(\omega_n^k) - S(\omega _n^k) = (\omega_n^k)^n - 1S(\omega _n^k) = \frac {(\omega_n^k)^n - 1}{\omega_n^k - 1}= 0则当$k = 0$的时候，其值为0 而原来的式子 c_k = \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0} ^ {j - k})^i = \sum_{j = 0} ^ {n-1}a_jS(\omega_n^{j - k})当$j = k$的时候$S = n$，否则$S = 0$，所以a_i = \frac 1n c_i 这样我们得到了点值和系数的关系式，所以，从结论来说，将单位根幂上-1，然后做一次快速傅里叶变换，将结果的数除以n就是傅里叶逆变换的结果。 代码实现一般的分治都会采用递归操作实现，但是在FFT中递归实现的效率比较低，所以大多数情况下采用迭代操作实现。我们观察二进制下的序列规律发现分治到边界条件的时候每个数的下标等于原下标的二进制翻转，于是我们省去了分奇偶的操作，直接枚举每一个二进制位，然后向上合并就可以了。下面是迭代操作实现的代码。 1234567int l = 0 ; while ((1 &lt;&lt; l) &lt; N) l ++ ;for (int i = 0 ; i &lt; N ; i ++) &#123; int T = 0 ; for (int j = 0 ; j &lt; l ; j ++) if (i &amp; (1 &lt;&lt; j)) T /= (1 &lt;&lt; (k - j - 1)) ; if (i &lt; t) swap(a[i], a[T]) ;&#125; 蝴蝶操作我们把$\omega_n^k$称为旋转因子并保留下来，进入两个向量$a_k^0$和$a_k^1$时，旋转因子$\omega_n^k$乘以$a_k^1$，输出与$a_k^0$的和与差，这一个操作被称为蝴蝶操作。那这个东西究竟有什么作用呢？ 重新考虑我们向上合并两个子问题时，假设有$A_1(\omega_{n/2}^k)$储存在$a(k)$中，$A_2(\omega _{n/2}^k)$储存在$a(k +\frac n2)$中，并且这两个值将要被储存在$b(k)$和$b(k + \frac n2)$中，则合并的操作可以如下表示： b(k) ← a(k) + a(k +\frac n2) \times\omega_n^kb(k +\frac n2) ← a(k) - a(k +\frac n2) \times\omega_n^k于是我们考虑将两个值存放在原来的a中，取消b数组的存在，但是需要覆盖原来的值，所以就需要一个临时变量T。 T ←a(k +\frac n2) \times\omega_n^ka(k +\frac n2) ← a(k) - Ta(k) ← a(k) - T名字很好听，其实操作很简单，仅仅有一行而已。 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int N, M, l, r[MAXN], L = 1 ;const double Pi = acos(-1.0);struct complex &#123; double x, y ; complex (double xx = 0, double yy = 0) &#123;x = xx, y = yy ;&#125;&#125; a[MAXN], b[MAXN] ;complex operator + (complex a, complex b) &#123; return complex(a.x + b.x , a.y + b.y) ;&#125;complex operator - (complex a, complex b) &#123; return complex(a.x - b.x , a.y - b.y) ;&#125;complex operator * (complex a, complex b) &#123; return complex(a.x * b.x - a.y * b.y , a.x * b.y + a.y * b.x) ; &#125;inline void FFT(complex *A, int type) &#123; for (int i = 0 ; i &lt; L ; i ++) if (i &lt; r[i]) swap(A[i], A[r[i]]) ; for (int Mid = 1 ; Mid &lt; L ; Mid &lt;&lt;= 1) &#123; complex W(cos(Pi / Mid), type * sin(Pi / Mid)) ; for (int R = Mid &lt;&lt; 1, j = 0 ; j &lt; L ; j += R) &#123; complex w(1, 0) ; for (int k = 0 ; k &lt; Mid ;k ++, w = w * W) &#123; complex x = A[j + k], y = w * A[j + Mid + k] ; A[j + k] = x + y ; A[j + Mid + k] = x - y ; &#125; &#125; &#125;&#125;int main() &#123; int N = Read(), M = Read() ; for (int i = 0 ; i &lt;= N ; i ++) a[i].x = Read() ; for (int i = 0 ; i &lt;= M ; i ++) b[i].x = Read() ; while (L &lt;= N + M) L &lt;&lt;= 1, l ++ ; for (int i = 0 ; i &lt; L ; i ++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; FFT (a, 1) ; FFT (b, 1) ; for (int i = 0 ; i &lt;= L ; i ++) a[i] = a[i] * b[i] ; FFT(a, - 1) ; for (int i = 0 ; i &lt;= N + M ; i ++) printf("%d ", (int)(a[i].x/ L + 0.5)) ; &#125; 参考文献同济高等数学，Thomas H.Cormen算法导论，Miskcoo 从多项式乘法到快速傅里叶变换，郭晓旭 FFT讲义，维基百科 傅里叶变换，白霂凡 Fast Fourier Transform，Menci FFT学习笔记，Heinrich 傅里叶分析之掐死教程，attack 快速傅里叶变换(FFT)详解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>傅里叶变换</tag>
        <tag>线性积分变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2015]约数个数和]]></title>
    <url>%2F2019%2F02%2F13%2FSDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[如题，设$d(x)$表示$x$的约数个数，求\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)首先要知道约数个数的一种表示方法：d(i,j) = \sum_{x|i} \sum_{y_j}[gcd(x,y) == 1]然后题目所求就变成了 \sum_{i = 1}^N \sum_{j = 1}^M \sum_{k | i} \sum_{l | j}[gcd(k,l) == 1]化简，改变量之后式子变为 \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == 1)(\frac Mi)(\frac Mj)考虑莫比乌斯反演,设 f(X) = \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == x)(\frac Ni)(\frac Mj) F(x) = \sum_{x|n}f(n) → F(x) = \sum_{i = }^N \sum_{j = 1}^{N / x}(x|gcd())(\frac Ni)(\frac Mj) → F(x) = \sum_{i = }^N \sum_{j = 1}^{M / x}(\frac {N}{ix})(\frac {M}{jx})考虑优化算法时间复杂度，可以预处理出$\sum_{i = 1}^N(\frac Ni)$和$\sum_{j = 1}^M (\frac Mj)$，连带着莫比乌斯函数可以直接O(N)预处理。12345678910111213141516171819inline void Init() &#123; U[1] = F[1] = 1 ; for (int i = 2 ; i &lt;= MAXN ; i ++) V[i] = true ; for (int i = 2 ; i &lt;= MAXN ; i ++) &#123; if (V[i]) U[i] = - 1, P[++ Tot] = i, F[i] = 2, G[i] = 1 ; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = false ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] / (G[i] + 1) * (G[i] + 2) ; G[i * P[j]] = G[i] + 1 ; break ; &#125; else U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; 1), G[i * P[j]] = 1 ; &#125; &#125; for (int i = 1 ; i &lt;= MAXN ; i ++) S[i] = S[i - 1] + U[i], Sum[i] = Sum[i - 1] + F[i] ;&#125; 问题答案化简为$f(1)$。反演后得到f(1) = \sum{x = 1}^N \mu (x) F(x) = \sum_{x = 1}^N \mu(x) \sum_{i = 1}^{N/x} \sum _{j = 1}^{M / x} (\frac Ni) (\frac Mj)进行数论分块就可以了，总体时间复杂度$O(T\sqrt N)$，其中T为数据组数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 50010 ;const int MAXM = 50010 ;int N, M, U[MAXN], P[MAXN], Tot ;int S[MAXN], Sum[MAXN], F[MAXN], G[MAXN] ;bool V[MAXN] ; long long Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Init() &#123; U[1] = F[1] = 1 ; for (int i = 2 ; i &lt;= MAXN ; i ++) V[i] = true ; for (int i = 2 ; i &lt;= MAXN ; i ++) &#123; if (V[i]) U[i] = - 1, P[++ Tot] = i, F[i] = 2, G[i] = 1 ; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = false ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] / (G[i] + 1) * (G[i] + 2) ; G[i * P[j]] = G[i] + 1 ; break ; &#125; else U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; 1), G[i * P[j]] = 1 ; &#125; &#125; for (int i = 1 ; i &lt;= MAXN ; i ++) S[i] = S[i - 1] + U[i], Sum[i] = Sum[i - 1] + F[i] ;&#125;int main() &#123; int T = Read() ; Init () ; while (T --) &#123; Ans = 0 ; N = Read() ; M = Read() ; for (int l = 1, r ; l &lt;= min(N, M) ; l = r + 1) &#123; r = min(N / (N / l), M / (M / l)) ; Ans += 1ll * (S[r] - S[l - 1]) * Sum[N / l] * Sum[M / l] ; &#125; printf("%lld\n", Ans) ; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数论 莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演初步与实际应用]]></title>
    <url>%2F2019%2F02%2F02%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%88%9D%E6%AD%A5%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演初步和实际应用定义和一般形式及其证明 假设有数论函数关系式$F(N) = \sum_{x|N}f(x)$，则有$f(N) = \sum_{x|N}\mu(x)F(\frac Nx) = \sum_{x|N}\mu(\frac xN)F(x)$ 此为基本定义，但是看到这个函数也有限制就是必须是数论函数。，也就是定义域为正整数，对应集合为复数的函数。下面是函数的一般形式。 假设d定义在$[1,∞)$上的复值函数$G(N) = \sum_{x = 1}^NF(\frac Nx)$，则有$F(N) = \sum_{x = 1}^N\mu(x)G(\frac Nx)$ 而这个$\mu(x)$函数就是莫比乌斯函数，其定义如下： $x= 1$时，$\mu(x) = 1$。 $x = P_1P_2…P_M$，（$P$为互异素数），则$\mu(x) = (-1)^M$ 其他情况下$\mu(x) = 0$ 由定义可以得到莫比乌斯函数的两个重要性质： 对任意正整数$N$有$\sum_{x|N}\frac{\mu(x)}{x} = \frac{\varphi(N)}{N}$ 证明 : 设有 \sum_{x|N}\mu(x) = [N = 1], f(N) = \sum_{x|N}[\frac Nx = 1]f(x)代入得 f(N) = \sum_{x|N}\sum_{y|\frac Nx}\mu(y)f(x)由于$\sum_{x|N}\sum_{y|\frac Nx}$的限制条件为$xy|N$，所以等式写成: f(N) = \sum_{y|N}\mu(y)\sum_{x|\frac Ny}f(x) = \sum_{y|N}\mu(y)F(\frac Ny)证明完毕。 代码实现用线性筛法求莫比乌斯函数，时间复杂度$O(N)$ 123456789101112131415inline void Init() &#123; memset(V, 0, sizeof(V)) ; Mu[1] = 1 ; Tot = 0 ;&#125;inline void MU() &#123; for (int i = 2 ; i &lt; N ; i ++) &#123; if (! V[i]) P[++ Tot] = i, Mu[i] = - 1 ; for (int j = 0 ; j &lt;= Tot &amp;&amp; P[j] &lt; N ; j ++) &#123; V[i * P[j]] = 1 ; if (i % P[j]) Mu[i * P[j]] = - Mu[i] ; else &#123;Mu[i * P[j]] = 0 ; break ; &#125; &#125; &#125;&#125; 例题：YY的GCD 给定$N, M$，求所有的$X \leq N,~Y \leq M$中$gcd(X, Y)$是质数的点对有多少对。 类似于一个模板题，因为其思维难度不是很大。考虑公式化题目描述，即求：\sum_{X = 1}^N \sum_{Y = 1}^M [gcd(i,j) == P] 设$f(x)​$为满足$gcd(X, Y) = X​$的$(X, Y)​$的对数，$F(X)​$为满足$X|gcd(X, Y)​$二点$(X, Y)​$的对数。得到 F(N) = \sum_{x|N}f(x)​所以根据莫比乌斯反演定理，得​ f(N) = \sum_{x|N}\mu(\frac xN)F(x) =\sum_{x|N}\mu(\frac xN)\frac{N \times M}{X^2}​而题目要求其$gcd(X,Y)$是一个质数也就是说 Ans = \sum_P^{min(N, M} \sum_i^N\sum_j^M[gcd(i,j) = P] = \sum_P^{Minn(N,M)}f(P)设$T = PX$，则式子变为 \sum_{T = 1}^{Min(N,M)}\frac{N \times M}{T^2}(\sum_{G|T}\mu(\frac TG))于是为了提高速度，可以预处理$\sum_{G|T}\mu(\frac TG)$。于是此题就以较快得速度解决了。 但是如果是多组数据还是有可能会$TLE$，所以如果想要更快，还可以使用整除分块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;long long T, N, M, V[MAXN], P[MAXN], Mu[MAXN], Tot ;long long S[MAXN], Ans, G[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void MU() &#123; memset(V, 0, sizeof(V)) ; Mu[1] = 1 ; Tot = 0 ; for (int i = 2 ; i &lt; MAXN ; i ++) &#123; if (! V[i]) P[Tot ++] = i, Mu[i] = - 1, G[i] = 1 ; for (int j = 0 ; j &lt; Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = 1 ; if (i % P[j]) Mu[i * P[j]] = - Mu[i], G[i * P[j]] = Mu[i] - G[i] ; else &#123; Mu[i * P[j]] = 0 ; G[i * P[j]] = Mu[i] ; break ; &#125; &#125; &#125; for (int i = 1 ; i &lt; MAXN ; i ++) S[i] = S[i - 1] + G[i] ;&#125;int main() &#123; MU() ; T = Read() ; while (T --) &#123; Ans = 0 ; N = Read(), M = Read() ; for (int i = 1, j ; i &lt;= min(N, M) ; i = j + 1) &#123; j = min(N / (N / i), M / (M / i)) ; Ans += (N / i) * (M / i) * (S[j] - S[i - 1]) ; &#125; printf("%lld\n", Ans) ; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值法及拉格朗日插值多项式]]></title>
    <url>%2F2019%2F02%2F01%2F%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[$Interpolation$：“插值”，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。 一：什么是插值插值是属于数学数值分析领域的内容，常被称作内插或者插值。接下来给出定义： 给定N个数据离散点$(x_k,y_k)$，其中$k = 1,2,3…N$。对于$x$求$x$对应的$y$值叫做内插。 L_n(x) = \sum_{k = 0}^ny_kl_k(x)定义域在区间$[A,B]$上有意函数$F$，已知函数$G$在$[A,B]$范围内满足$G(x_i) = F(x_i) = 1,2…N$ 则称$G(x)$为$F(x)$关于节点${x_i}_{i = 0}^N$上的插值函数。 假设我们已经求得$x_i$集合中的最大值$MAX$和最小值$MIN$ 用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in (MIN, MAX)$处的近似值的方法称为内插法。 用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in [A, B]$但$x \notin [MIN, MAX]$处的近似值的方法称为外插法。 那么你现在已经基本了解了什么是插值，下面我们来看一些关于插值方法的东西。 二：插值方法简介1.片段插值这种插值方法几乎不能算是插值了，所实话如果没有维基百科编者根本就不知道有这种插值方法以及这样也能算是插值。 简单来说就是找到离$x$最近的采样点$x_i$，然后将$y$值分配为$y_i$。因此它的别称就是最近邻插值。但是就和wiki说的一样，这种插值方法是几乎碰不到的，因为出不了什么很高深的符合当前阶段学习的题目，但同时如果可以使用这种方法，无疑将使时间和复杂性都大大降低。 2.线性插值这种插值从某种意义上说是利用了斜率，但实际上就是很简单的取平均值而已。 假设我们已知了所有自然数采样点${x_i}$，而我们要求的插值点是$x_{i+0.5}$,那么发现当前插值点是处于$x_i和x_{i+1}$之间，那么我们取的分配值就是$\frac{y_i+y_{i + 1}}{2}$。以数学公式的方法表达就是： $y = y_a + (y_b - y_a) \frac{x - x_a}{x_b - x_a}$ $G(x) = y_a \frac{x - x_b}{x_a - x_b} + y_b \frac{x - x_a}{x_b - x_a}$ 发现$G(x)$实际上是两个一次多项式的组合。也就是说，我们过这两个点分别作一次多项式$l_a = \frac{x - x_b}{x_a - x_b},~l_2 = \frac{x - x_a}{x_b - x_a}$，那么$G(x) = y_al_a + y_bl_b$。 而实际上上述两种插值方法都存在误差，撇开片段插值不谈，线性插值的误差来源只要是因为插值点$x_k$是不可微分的，而计算得出的误差是$|F(x) - G(x)| \leq C(x_b - x_a)^2~where~C= \frac18max_{r \in[x_a, x_b]}|g^{‘’}(r)|$ 其与数据点的距离平方成正比。 我们发现前两者的不同在于第一个找到了一个采样点进行插值，而线性插值则找到了两个点，因为两点确定一个一次函数。相同的，我们也有三点确定的二次函数的抛物线插值法，这里不再进行分析。 3.多项式插值 已知函数$F(x)$在$[A, B]$上$N + 1$个点处的函数值$\{y_i\}_{i = 0}^N$，求次数不超过$N$的多项式$G(x) = c_0 +c_1x+…+c_Nx^N$使得$G(x) = F(x)$称为多项式插值。 定理：多项式插值函数存在且唯一：我们都知道过$N + 1$个点做一个$N$次函数最多只能做一个，而做一个$≥N$次的函数却可以有无数个。 三：拉格朗日插值法建立插值多项式的方法（简称为插值法）最基本的是需要求解线性方程组，而这是最为冗杂，最为复杂的算法，一般没有特殊情况是不会用这种方法构造插值多项式的。因此经过前人的努力，引入了一种更为简单，实现更为便捷的插值法：拉格朗日插值法。与之相通的有牛顿插值法，而我们又知道多项式插值函数的唯一性，因此恒有$L_n(x) = N_n(x)$。（L：拉格朗日，N：牛顿）。 在准备好了解拉格朗日插值法之前，我们先引入一个基函数的概念。 记$H_n(x)$为次数不超过$N$的多项式全集，也就是有$H_0(x),H_1(x)…H_n(x)$，设其构成$H_n(x)$的一组基，则插值多项式可表示为$G(x) = a_0H_0(x) + … + a_nH_n(x)$。 那么我们只要寻找到合适的基函数和插值多项式在这组基下的线性表示系数，就可以通过基函数构造插值多项式，也就是基函数插值法。 回到拉格朗日插值上来，我们首先寻找基函数。 设$l_k(x)$是$n$次多项式，在节点$x_0，x_1…x_n$上满足$l_k(x_i) = 1 ~(i = k)$或$l_k(x_i) = 0~(i ≠ k)$，则称$l_k(x)$为节点$\{x_i\}_{i = 0}^N$上的$n$次拉格朗日插值基函数。 构造法可以知道$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$ 知道基函数之后我们用基函数求$G(x) = a_0l_0(x) + … + a_nl_n(x)$，带入$G(x_i) = y_i$可得 $L_n(x) = \sum_{k = 0}^ny_kl_k(x)$ 上方的$L_n(x)$就是我们的拉格朗日插值多项式，具有结构清晰紧凑的特点，是用于理论分析的一般手法。根据插值误差估计定理可以估计出误差为：$\frac{y_{n + 1}(ζ)}{(n + 1) !} \omega_{n+1}(x)$，其小于$\frac{M_{n+1}}{(n+1)!}|\omega_{n+1}|(x)$。 重心拉格朗日插值法按照维基百科说的，这是对拉格朗日插值法的一种改进。当然，指的是速度上的，误差方面并没有什么差别。 按照均摊来说，如果用朴素拉格朗日插值法求插值函数，时间复杂度是$O(N^2)$，而中心拉格朗日插值法可以将时间复杂度压缩到$O(N)$。讲了整整一个量级，不可谓不改进。但从大多数方面来说，朴素拉格朗日也足足够用了。 实质上一致的前提下，中心拉格朗日插值法改写了拉格朗日基本多项式$l_j(x)$。 $l(x) = \prod_{i = 0}^K(X - X_K)$，使$l_j(x) = \frac{l(x)}{x - x_j} \times \frac{1}{\prod _{i = 0}^K(x_j - x_i)}$ 然后定义一个重心权$w_j = \prod_{i = 0}^K\frac{1}{x_j - x_i}$，则$L(x) = l(x)\sum_{j = 0}^K \frac{w_j \times y_j}{x - x_j}$。 然后这个玩意怎么改进拉格朗日了呢？ 当插值点的个数增加一个的时候，将每一个$w_j$都除以)$(x_j - x_{K + 1})$，得到$w_{k + 1}$，直接省掉了一个循环，因此复杂度变为了$O(N)$。 （维基百科原话，还是能看懂的。） 据说这个重心拉格朗日插值法不仅仅速度更优，并且省掉了多项式$l(x)$的计算，还有说什么不同于第一型的拉格朗日插值函数的向后稳定，这个改进后的第二型拉格朗日插值函数是向前稳定的，勒贝格常数非常小，因为什么切比雪夫节点插值的极佳稳定性之类的。 当然，这种切比雪夫节点、勒贝格常数之类的就不是我们此次要学习的范围了，读者只要重心拉格朗日插值法把朴素拉格朗日插值法速度上甩了一大截就可以了。追求完美的读者可以试着一学。 拉格朗日插值基函数的性质及其应用 当$F(x)$为一个多项式且次数$\leq n$时，有$F^{(n+1)}(x) \equiv 0$，所以$R_n(x) = F(x) - L_n(X) \equiv 0$，（R为误差）因此$n$次插值多项式对于次数$\leq n$的多项式是精确的。 若$F(x) = x^k$其中$k \leq n$，那么$R_n(x) = x^k - \sum_{j = 0}^nX^kl_j(x) = 0$。特别的，当$k = 0$的时候有$\sum_{j = 0}^nl_j(x) = 1$。 结合上面的性质及其公式，我们尝试解决一些实际问题。从最经典的应用开始，熟练地运用拉格朗日公式解决插值类问题。 连续自然数幂和（差分表） 已知$K$，求$\sum _{i = 1}^Ni^K$ 首先介绍一个叫做“差分表”的小知识点。这个名字我们很自然想到差分的思想，而我们平常用的差分（$a[i + 1] - a[i]$）只是叫做一阶差分，根据这个最基本的，我们定义出”差分表“的东西。 对于函数$F(x)$，把$F’(X) = F(X + 1) - F(X)$叫做一阶差分，称$F’(X)$叫做差分算子。引申出对于$K &gt; 1$，有$F’^K(X) = F’^{K - 1}(X + 1) - F’^{K - 1}(X)$为$K$阶差分。 算出所有的$F’^K(X)$，将$X = 1,2,3…H$，代入每一个$F’^K(X)$，得到一个二维的表。即是差分表。 可以观察到列数递减，我们把所有的数插空排列，便形成了差分表的基本形状。 接着是引入的两个定理，可以直接使用： 如果多项式的次数为$N$，则对于所有大于$N$的$K$，多项式的$K$阶差分都恒等于$0$。 假设多项式$F(X)$的差分表的左斜列中各个元素依次是$D_0,D_1…D_M$，那么对于这个多项式的和恒有： $Sum(X) = \sum_{X = 0}^NF(X) = D_0C_{N + 1}^1 + D_1C_{N + 2}^1 + H + D_MC_{N + 1}^{M + 1}$ 以这个差分表作为工具，我们尝试从简单开始逐步解决这个问题。 首先假设$F(X) = X$，那么 我们构造出差分表的样子大概是这样的： 1230 1 2 3 4 5 6 …… 1 1 1 1 1 1 …… 0 0 0 0 0 …… 所以$Ans = 1 + 2 + H + N = 0 \times C_{N + 1}^1 + 1 \times C_{N + 2}^2$ 所以$Ans = \frac{N(N + 1)}{2}$ 接着引申到$F(X) = X^2$，建立出差分表 12340^2 1^2 2^2 3^2 4^2 5^2 6^2 …… 1 3 5 7 9 11 …… 2 2 2 2 2 …… 0 0 0 0 …… 答案就是$1^2 + 2^2 + H + N^2 = 0C_{N + 1}^1 + 1C_{N + 2}^1 + H + 2C_{N + 1}^{M + 1}$ 所以答案为$\frac{N(N + 1)(2N + 1)}{6}$ 因此我们引出了$Ans(K)$就是一个关于$N$的$K + 1$次多项式。 知道如此结论，我们就可以选择$K + 1$个点然后利用拉格朗日插值公式进行计算了。夫再度$O(K)$。 例题：Study 给定了$K, A, N, D$，求$\sum_{i = 0}^N \sum_{j = 1}^{A + iD} \sum_{l = 1}^jl^K$ 实际上和上面那个题没有什么很大的区别，式子虽然很长，我们从里到外分开考虑即可 最里面的$\sum_{l=1}^jl^k$是一个关于$j$的$k+1$次的多项式。把其差分表的第一条对角线求出来。 然后$\sum_{j=1}^{A+iD}\sum_{l=1}^jl^k$是关于$i$的$k+2$次的多项式。$O(k^2)$求出$i=0,1,…k+2$的值。 所以答案就是一个关于$N$的$k+3$次的多项式。求其第一条对角线即可。 拉格朗日插值法的代码实现经过上述的学习之后，代码实现可能反而是小事了。给出模板题的连接：拉格朗日插值法 给出$N$个点$(X_i,Y_i)$，确定一个唯一的$N - 1$次多项式，代入$k$求值。 代入所有的点，按照上述的讲解，爆搞就可以了。 1234567891011121314151617181920212223inline long long QuickPow(LL X, LL Y) &#123; long long Ans = 1 ; while (Y) &#123; if (Y &amp; 1) Ans = Ans * X % Mod ; Y &gt;&gt;= 1 ; X = X * X % Mod ; &#125; return Ans ;&#125;int main() &#123; N = Read() ; K = Read() ; for (int i = 1 ; i &lt;= N ; i ++) X[i] = Read(), Y[i] = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; int Ken = 1 ; for (int j = 1 ; j &lt;= N ; j ++) &#123; if (i == j) continue ; Ken = Ken * (X[i] - X[j] + Mod) % Mod ; &#125; Ken = QuickPow(Ken, Mod - 2) ; for(int j = 1 ; j &lt;= N ; j ++) &#123; if (i == j) continue ; Ken = Ken * (K - X[j] + Mod) % Mod ; &#125; Ken = Ken * Y[i] % Mod ; Ans = Ans + Ken % Mod ; &#125; printf("%lld", Ans % Mod) ; return 0 ;&#125; 后记都是说拉格朗日插值法好用，之后才知道它的优点在哪： 代替线性，抛物线之类的插值方法繁琐的公式结构和计算方法，其公式结构整齐紧凑，好看得多。 可能有人感觉很好笑，但是这确实是很重要的一点。考场上推出来超级复杂繁琐的方程式会让你心态爆炸的，因此简单整齐的公式结构也是十分重要的，好写好看，这可能也是他广为人用的原因之一吧。 但当然，数学仍然是不完整的，对于采样点较多的情况时出现的龙格现象，也表明拉格朗日插值法具有数值不稳定的特点，因此大多数情况，拉格朗日插值法仍用于解决次数较低的插值多项式问题。 牛顿插值法不再将了，因为其本质是一样的，充其量走了不同的路子而已，想学的朋友可以去了解一下。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>拉格朗日插值法</tag>
        <tag>差分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于动态规划问题的优化方案]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[浅谈关于动态规划问题的优化方案1.单调队列优化 单调队列是一种具有单调性的队列，其中的元素全部按照递增或者递减的顺序排列，就比如下面这个递减队列。 假如说我们要在队尾加入一个$5$，那么我们入队的步骤就是这样的： 发现队尾$1$，(q[tail])，$1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列优化</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
</search>
